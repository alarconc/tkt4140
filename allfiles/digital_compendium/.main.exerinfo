
# Information about all exercises in the file main.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u"Write the following ODE as a system of first order ODEs:\n!bt\n\\begin{align*}\ny'''-y'y''-(y')^2+2y=x^3 \\\\ \ny(0)=a,\\ y'(0)=b,\\ y''(0)=c\n\\end{align*}\n\n!et\n\n#!bsol\nFirst we write $y'''=y'y''+(y')^2-2y+x^3$.\n\nBy use of (ref{eq:1128}) we get\n!bt\n\\begin{align*}\n&y_1'=y_2\\\\ \n&y_2'=y_3\\\\ \n&y_3'=y_2y_3+(y_2)^2-2y_1+x^3\\\\ \n&y_1(0)=a,\\ y_2(0)=b,\\ y_3=c\n\\end{align*}\n\n!et\n#!esol\n#!ec\n!ebox",
  'title': u'Reduction of higher order systems',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'example:sphere_freefall',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'FIGURE:[chapter1/programs_and_modules/2.png, width=200]\n\nThe figure shows a falling sphere with a diameter $d$ and mass $m$\nthat falls vertically in a fluid. Use of Newton\'s 2nd law in the\n$z$-direction gives\n!bt\n\\begin{equation}\nlabel{eq:newton_2nd_sphere}\nm\\frac{dv}{dt} = mg-m_fg-\\frac{1}{2}m_f\\frac{dv}{dt}-\\frac{1}{2}\\rho_fv\\left|v\\right|A_kC_D,\n\\end{equation}\n\n!et\nwhere the different terms are interpreted as follows: $m=\\rho_k V$,\nwhere $\\rho_k$ is the density of the sphere and $V$ is the sphere\nvolume.  The mass of the displaced fluid is given by $m_f=\\rho_f V$,\nwhere $\\rho_f$ is the density of the fluid, whereas buoyancy and the\ndrag coefficient are expressed by $m_f \\, g$ and $C_D$, respectively.\nThe projected area of the sphere is given by $A_k = \\frac{\\pi}{4}d^2$\nand $\\frac{1}{2}m_f$ is the hydro-dynamical mass (added mass). The\nexpression for the hydro-dynamical mass is derived in White\ncite{white1999fluid}, page 539-540. To write Equation\n(ref{eq:newton_2nd_sphere}) on a more convenient form we introduce the\nfollowing abbreviations:\n!bt\n\\begin{equation}\n\\rho=\\frac{\\rho_f}{\\rho_k},\\ A=1+\\frac{\\rho}{2}, \\ B=(1-\\rho)g,\\ C=\\frac{3\\rho}{4d}.\n\\end{equation}\n\n!et\nin addition to the drag coefficient $C_D$ which is a function of the Reynolds number $\\displaystyle R_e = \\frac{vd}{\\nu}$, where $\\nu$ is the kinematical viscosity. Equation (ref{eq:newton_2nd_sphere}) may then be written as\n!bt\n\\begin{equation}\nlabel{eq:sphere_1st_order}\n\\frac{dv}{dt}=\\frac{1}{A}(B-C\\cdot v\\left|v\\right|C_d).\n\\end{equation}\n\n!et\nIn air we may often neglect the buoyancy term and the hydro-dynamical\nmass, whereas this is not the case for a liquid. Introducing\n$v=\\frac{dz}{dt}$ in Equation (ref{eq:sphere_1st_order}), we get a 2nd\norder ODE as follows\n!bt\n\\begin{equation}\nlabel{eq:sphere_second_order}\n\\frac{d^2z}{dt^2}=\\frac{1}{A}\\left(B-C\\cdot \\frac{dz}{dt}\\bigg|\\frac{dz}{dt}\\bigg|C_d\\right)\n\\end{equation}\n\n!et\nFor Equation (ref{eq:sphere_second_order}) two initial conditions must\nbe specified, e.g. $v=v_0$ and $z=z_0$ for $t=0$.\n\nFigure ref{fig:CDsphere} illustrates $C_D$ as a function of $Re$. The values in the plot are not as accurate as the number of digits in the\nprogram might indicate. For example is the location and the size of\nthe "valley" in the diagram strongly dependent of the degree of\nturbulence in the free stream and the roughness of the sphere. As\nthe drag coefficient $C_D$ is a function of the Reynolds number, it is\nalso a function of the solution $v$ (i.e. the velocity) of the ODE in\nEquation (ref{eq:sphere_1st_order}). We will use the function\n$C_D(Re)$ as an example of how functions may be implemented in Python.\n\nFIGURE:[chapter1/programs_and_modules/example_sphere.png, height=400 width=600] Drag coefficient $C_D$ as function of the Reynold\'s number $R_e$. label{fig:CDsphere}\n\n#@@@CODE ./chapter1/programs_and_modules/CDsphere.py from-to: # Define the function cd_sphere@^# Make plot\n\n!ebox',
  'title': u'Sphere in free fall',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'ex:falling_sphere',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'title': u'Falling sphere with constant and varying drag',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'ex:num_error',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'title': u'Numerical error as a function of $\\Delta t$',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u"Let's use Heun's method to solve Newton's equation from section ref{section:introduction},\n!bt\n\\begin{equation}\nlabel{eq:1405a}\ny'(x)=1-3x+y+x^2+xy,\\ y(0)=0\n\\end{equation}\n\n!et\nwith analytical solution\n!bt\n\\begin{align}\ny(x)=&3\\sqrt{2\\pi e}\\cdot \\exp\\left(x\\left(1+\\frac{x}{2}\\right)\\right)\\cdot \\left[\\mbox{erf}\\left(\\frac{\\sqrt{2}}{2}(1+x)\\right)-\\mbox{erf}\\left(\\frac{\\sqrt{2}}{2}\\right)\\right]\\nonumber \\\\ \n\t+&4\\cdot \\left[1-\\exp\\left(x\\left(1+\\frac{x}{2}\\right)\\right)\\right]-x\nlabel{eq:1405b}\n\\end{align}\n\n!et\n\nHere we have $f(x,y)=1-3x+y+x^2+xy = 1+x(x-3)+(1+x)y$\n\nThe following program _NewtonHeun.py_ solves this problem using Heun's method, and the resulting figure is shown in Figure ref{fig:newton_heun}.\n\n!bc pypro\n# chapter1/programs_and_modules/NewtonHeun.py\r\n# Program Newton\r\n# Computes the solution of Newton's 1st order equation (1671):\r\n# dy/dx = 1-3*x + y + x^2 +x*y , y(0) = 0\r\n# using Heun's method.\r\n\r\nimport numpy as np\r\n\r\nxend = 2\r\ndx = 0.1\r\nsteps = np.int(np.round(xend/dx, 0)) + 1 \r\ny, x = np.zeros((steps,1), float), np.zeros((steps,1), float)\r\ny[0], x[0] = 0.0, 0.0\r\n\r\nfor n in range(0,steps-1):\r\n    x[n+1] = (n+1)*dx\r\n    xn = x[n]\r\n    fn = 1 + xn*(xn-3) + y[n]*(1+xn)\r\n    yp = y[n] + dx*fn    \r\n    xnp1 = x[n+1]\r\n    fnp1 = 1 + xnp1*(xnp1-3) + yp*(1+xnp1)\r\n    y[n+1] = y[n] + 0.5*dx*(fn+fnp1)\r\n\r\n# Analytical solution\r\nfrom scipy.special import erf\r\na = np.sqrt(2)/2\r\nt1 = np.exp(x*(1+ x/2))\r\nt2 = erf((1+x)*a)-erf(a)\r\nya = 3*np.sqrt(2*np.pi*np.exp(1))*t1*t2 + 4*(1-t1)-x\r\n\r\n# plotting\r\nimport matplotlib.pylab as py\r\npy.plot(x, y, '-b.', x, ya, '-g.')\r\npy.xlabel('x')\r\npy.ylabel('y')\r\nfont = {'size' : 16}\r\npy.rc('font', **font)\r\npy.title('Solution to Newton\\'s equation')\r\npy.legend(['Heun', 'Analytical'], loc='best', frameon=False)\r\npy.grid()\r\npy.savefig('newton_heun.png', transparent=True)\r\npy.show()\n\n!ec\n\nFIGURE:[chapter1/programs_and_modules/newton_heun.png, width=400] Velocity of falling sphere using Euler's and Heun's methods. label{fig:newton_heun}\n\n!ebox",
  'title': u"Newton's equation",
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'title': u"Falling sphere with Heun's method",
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'example:falling_sphere_RK4',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'title': u'Falling sphere using RK4',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'title': u'Particle motion in two dimensions',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'To investigate whether the various ODE-schemes in our module \'ODEschemes.py\' \nhave the expected, theoretical order, we proceed in the same manner as\noutlined in ref{ex:num_error}. The complete code is listed at the end\nof this section but we will highlight and explain some details in the\nfollowing. \n\nTo test the numerical order for the schemes we solve a somewhat general linear ODE:\n!bt\n\\begin{align}\n label{eq:gen_lin_ode}\n u\'(t)&= a \\, u + b \\\\ \n u(t_0)&= u_0 \\nonumber\n\\end{align}\n\n!et\nwhich has the analytical solutions:\n!bt\n\\begin{equation}\nu =\\begin{cases}\n \\left (u_0 + \\frac{b}{a} \\right )   \\; e^{a\\, t} -\\frac{b}{a},& \\quad a \\neq 0 \\\\ \n u_0 + b\\, t, &\\quad a = 0 \n\\end{cases}\n\\end{equation}\n\n!et\n\nThe right hand side defining the differential equation has been\nimplemented in function `f3` and the corresponding\nanalytical solution is computed by `u_nonlin_analytical`:\n\n!bc pycod\n    def f3(z, t,a=2.0,b=-1.0):\r\n        """ """\r\n        return a*z + b\r\n\r\n    def u_nonlin_analytical(u0, t, a=2.0, b=-1.0):\r\n        from numpy import exp\r\n        TOL = 1E-14\r\n        if (abs(a)>TOL):\r\n            return (u0 + b/a)*exp(a*t)-b/a\r\n        else:\r\n            return u0 + b*t\n\n!ec\n-----\nThe basic idea for the convergence test in  the function `convergence_test` is that we start out by\nsolving numerically an ODE with an analytical solution on a relatively\ncoarse grid, allowing for direct computations of the error. We then\nreduce the timestep by a factor two (or double the grid size),\nrepeatedly, and compute the error for each grid and compare it with\nthe error of previous grid.\n\nThe Euler scheme (ref{eq:1302}) is $O(h)$, whereas the Heun scheme\n(ref{eq:1403a}) is $O(h^2)$, and Runge-Kutta (ref{eq:1501}) is\n$O(h^4)$, where the $h$ denote a generic step size which for the\ncurrent example is the timestep $\\Delta t$. The order of a particular\nscheme is given exponent $n$ in the error term $O(h^n)$. Consequently, the Euler scheme is a first oder scheme, Heun is second order, whereas Runge-Kutta is fourth order. \n\nBy letting $\\epsilon_{i+1}$ and $\\epsilon_i$ denote the errors on to consecutive grids with corresponding timesteps $\\displaystyle \\Delta t_{i+1} = \\frac{\\Delta t_i}{2}$. The errors $\\epsilon_{i+1}$ and $\\epsilon_{i}$ for a scheme of order $n$ are then related by:\n!bt\n\\begin{equation}\nlabel{eq:eps}\n\\epsilon_{i+1} = \\frac{1}{2^n} \\epsilon_{i}\n\\end{equation}\n\n!et\nConsequently, whenever  $\\epsilon_{i+1}$ and $\\epsilon_{i}$ are known from consecutive simulations and estimate of the order of the scheme may be obtained by:\n!bt\n\\begin{equation}\nlabel{eq:epsapprox}\n n \\approx \\log_2 \\frac{\\epsilon_{i}}{\\epsilon_{i+1}}\n\\end{equation}\n\n!et\n\nIn the function `convergence_test` the schemes we will subject to a\nconvergence test in a list `scheme_list`. This allows for a convenient\nloop over all schemes with the clause: `for scheme in\nscheme_list:`. Subsequently, for each scheme we refine the initial\ngrid (`N=30`) `Ndts` times in the loop `for i in range(Ndts+1)` and\nsolve and compute the order estimate given by (ref{eq:epsapprox}) with\nthe clause `order_approx.append(previous_max_log_err -\nmax_log_err)`. Note that we can not compute this for the first\niteration (`i=0`), and that we use a an initial empty list\n`order_approx` to store the approximation of the order `n` for each\ngrid refinement. For each grid and for each grid we plot the\n$\\log_2(\\epsilon)$ as a function of time with: `plot(time[1:],\nlog_error, linestyles[i]+colors[iclr], markevery=N/5)` and for each\nplot we construct the corresponding legend by appending a new element\nto the legends-list `legends.append(scheme.func_name +\': N = \' + str(N))`.   This construct produces a string with both the scheme name and the number of elements $N$. The plot is not reproduced below, but you may see the result by downloading and running the module yourself. \n\nHaving completed the given number of refinements `Ndts` for a specific scheme\nwe store the `order_approx` for the scheme in a dictionary using the\nname of the scheme as a key by `schemes_orders[scheme.func_name] =\norder_approx`. This allows for an illustrative plot of the order estimate for each scheme with the clause:\n!bc\nfor key in schemes_orders:\n            plot(N_list, (np.asarray(schemes_orders[key])))\n\n!ec \nand the resulting plot is shown in Figure ref{fig:convergence_rate}, and we see that our numerical approximations for the orders of our schemes approach the theoretical values as the number of timesteps increase (or as the timestep is reduced by a factor two consecutively).  \nFIGURE:[chapter1/programs_and_modules/ConvergenceODEschemes.png, width=700] The convergence rate for the various ODE-solvers a function of the number of timesteps. label{fig:convergence_rate}\n\n\nThe complete function `convergence_test` is a part of the module `ODEschemes` and is isolated below:\n\n!bc pycod\n    def convergence_test():\r\n        """ Test convergence rate of the methods """\r\n        from numpy import linspace, size, abs, log10, mean, log2\r\n        figure()\r\n        tol = 1E-15\r\n        T = 8.0   # end of simulation\r\n        Ndts = 5 # Number of times to refine timestep in convergence test\r\n\r\n        z0 = 2\r\n\r\n        schemes =[euler, heun, rk4]\r\n        legends=[]\r\n        schemes_order={}\r\n        \r\n        colors = [\'r\', \'g\', \'b\', \'m\', \'k\', \'y\', \'c\']\r\n        linestyles = [\'-\', \'--\', \'-.\', \':\', \'v--\', \'*-.\']\r\n        iclr = 0\r\n        for scheme in schemes:\r\n            N = 30    # no of time steps\r\n            time = linspace(0, T, N+1)\r\n\r\n            order_approx = []\r\n            \r\n            for i in range(Ndts+1):\r\n                z = scheme(f3, z0, time)   \r\n                abs_error = abs(u_nonlin_analytical(z0, time)-z[:,0])\r\n                log_error = log2(abs_error[1:]) # Drop 1st elt to avoid log2-problems (1st elt is zero)\r\n                max_log_err = max(log_error)\r\n                plot(time[1:], log_error, linestyles[i]+colors[iclr], markevery=N/5)\r\n                legends.append(scheme.func_name +\': N = \' + str(N))\r\n                hold(\'on\')\r\n                \r\n                if i > 0: # Compute the log2 error difference\r\n                    order_approx.append(previous_max_log_err - max_log_err) \r\n                previous_max_log_err = max_log_err\r\n\r\n                N *=2\r\n                time = linspace(0, T, N+1)\r\n            \r\n            schemes_order[scheme.func_name] = order_approx\r\n            iclr += 1\r\n\r\n        legend(legends, loc=\'best\')\r\n        xlabel(\'Time\')\r\n        ylabel(\'log(error)\')\r\n        grid()\r\n        \r\n        N = N/2**Ndts\r\n        N_list = [N*2**i for i in range(1, Ndts+1)]\r\n        N_list = np.asarray(N_list)\r\n        \r\n        figure()\r\n        for key in schemes_order:\r\n            plot(N_list, (np.asarray(schemes_order[key])))\r\n        \r\n        # Plot theoretical n for 1st, 2nd and 4th order schemes\r\n        axhline(1.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        axhline(2.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        axhline(4.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        xticks(N_list)\r\n        legends = schemes_order.keys()\r\n        legends.append(\'theoretical\') \r\n        legend(legends, loc=\'best\', frameon=False)\r\n        xlabel(\'Number of unknowns\')\r\n        ylabel(\'Scheme order approximation\')\r\n        axis([0, max(N_list), 0, 5])\r\n        savefig(\'ConvergenceODEschemes.png\', transparent=True)\n\n!ec\n\n\nThe complete module `ODEschemes` is listed below and may easily be downloaded in your Eclipse/LiClipse IDE:\n!bc pypro\n# chapter1/programs_and_modules/ODEschemes.py\r\n\r\nimport numpy as np\r\nfrom matplotlib.pyplot import plot, show, legend, hold,rcParams,rc, figure, axhline, close,\\\r\n    xticks, xlabel, ylabel, savefig, axis, grid\r\n\r\n# change some default values to make plots more readable \r\nLNWDT=3; FNT=11\r\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\r\nfont = {\'size\' : 16}; rc(\'font\', **font)\r\n\r\n\r\n# define Euler solver\r\ndef euler(func, z0, time):\r\n    """The Euler scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    z = np.zeros((np.size(time), np.size(z0)))\r\n    z[0,:] = z0\r\n\r\n    for i in range(len(time)-1):\r\n        dt = time[i+1] - time[i]\r\n        z[i+1,:]=z[i,:] + np.asarray(func(z[i,:], time[i]))*dt\r\n\r\n    return z\r\n\r\n\r\n# define Heun solver\r\ndef heun(func, z0, time):\r\n    """The Heun scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    def f_np(z,t):\r\n        """A local function to ensure that the return of func is an np array\r\n        and to avoid lengthy code for implementation of the Heun algorithm"""\r\n        return np.asarray(func(z,t))\r\n\r\n    z = np.zeros((np.size(time), np.size(z0)))\r\n    z[0,:] = z0\r\n    zp = np.zeros_like(z0)\r\n\r\n    for i, t in enumerate(time[0:-1]):\r\n        dt = time[i+1] - time[i]\r\n        zp = z[i,:] + f_np(z[i,:],t)*dt   # Predictor step\r\n        z[i+1,:] = z[i,:] + (f_np(z[i,:],t) + f_np(zp,t+dt))*dt/2.0 # Corrector step\r\n\r\n    return z\r\n\r\n\r\n# define rk4 scheme\r\ndef rk4(func, z0, time):\r\n    """The Runge-Kutta 4 scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    z = np.zeros((np.size(time),np.size(z0)))\r\n    z[0,:] = z0\r\n    zp = np.zeros_like(z0)\r\n\r\n    for i, t in enumerate(time[0:-1]):\r\n        dt = time[i+1] - time[i]\r\n        dt2 = dt/2.0\r\n        k1 = np.asarray(func(z[i,:], t))                # predictor step 1\r\n        k2 = np.asarray(func(z[i,:] + k1*dt2, t + dt2)) # predictor step 2\r\n        k3 = np.asarray(func(z[i,:] + k2*dt2, t + dt2)) # predictor step 3\r\n        k4 = np.asarray(func(z[i,:] + k3*dt, t + dt))   # predictor step 4\r\n        z[i+1,:] = z[i,:] + dt/6.0*(k1 + 2.0*k2 + 2.0*k3 + k4) # Corrector step\r\n\r\n    return z\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    a = 0.2\r\n    b = 3.0\r\n    u_exact = lambda t: a*t   +  b\r\n\r\n    def f_local(u,t):\r\n        """A function which returns an np.array but less easy to read\r\n        than f(z,t) below. """\r\n        return np.asarray([a + (u - u_exact(t))**5])\r\n\r\n    def f(z, t):\r\n        """Simple to read function implementation """\r\n        return [a + (z - u_exact(t))**5]\r\n\r\n\r\n    def test_ODEschemes():\r\n        """Use knowledge of an exact numerical solution for testing."""\r\n        from numpy import linspace, size\r\n\r\n        tol = 1E-15\r\n        T = 2.0  # end of simulation\r\n        N = 20  # no of time steps\r\n        time = linspace(0, T, N+1)\r\n\r\n\r\n        z0 = np.zeros(1)\r\n        z0[0] = u_exact(0.0)\r\n\r\n        scheme  = [euler, heun, rk4]\r\n\r\n        for scheme in scheme:\r\n            z = scheme(f, z0, time)\r\n            max_error = np.max(u_exact(time) - z[:,0])\r\n            msg = \'%s failed with error = %g\' % (scheme.func_name, max_error)\r\n            assert max_error < tol, msg\r\n\r\n    # f3 defines an ODE with ananlytical solution in u_nonlin_analytical\r\n    def f3(z, t,a=2.0,b=-1.0):\r\n        """ """\r\n        return a*z + b\r\n\r\n    def u_nonlin_analytical(u0, t, a=2.0, b=-1.0):\r\n        from numpy import exp\r\n        TOL = 1E-14\r\n        if (abs(a)>TOL):\r\n            return (u0 + b/a)*exp(a*t)-b/a\r\n        else:\r\n            return u0 + b*t\r\n            \r\n         \r\n    # Function for convergence test\r\n    def convergence_test():\r\n        """ Test convergence rate of the methods """\r\n        from numpy import linspace, size, abs, log10, mean, log2\r\n        figure()\r\n        tol = 1E-15\r\n        T = 8.0   # end of simulation\r\n        Ndts = 5 # Number of times to refine timestep in convergence test\r\n\r\n        z0 = 2\r\n\r\n        schemes =[euler, heun, rk4]\r\n        legends=[]\r\n        schemes_order={}\r\n        \r\n        colors = [\'r\', \'g\', \'b\', \'m\', \'k\', \'y\', \'c\']\r\n        linestyles = [\'-\', \'--\', \'-.\', \':\', \'v--\', \'*-.\']\r\n        iclr = 0\r\n        for scheme in schemes:\r\n            N = 30    # no of time steps\r\n            time = linspace(0, T, N+1)\r\n\r\n            order_approx = []\r\n            \r\n            for i in range(Ndts+1):\r\n                z = scheme(f3, z0, time)   \r\n                abs_error = abs(u_nonlin_analytical(z0, time)-z[:,0])\r\n                log_error = log2(abs_error[1:]) # Drop 1st elt to avoid log2-problems (1st elt is zero)\r\n                max_log_err = max(log_error)\r\n                plot(time[1:], log_error, linestyles[i]+colors[iclr], markevery=N/5)\r\n                legends.append(scheme.func_name +\': N = \' + str(N))\r\n                hold(\'on\')\r\n                \r\n                if i > 0: # Compute the log2 error difference\r\n                    order_approx.append(previous_max_log_err - max_log_err) \r\n                previous_max_log_err = max_log_err\r\n\r\n                N *=2\r\n                time = linspace(0, T, N+1)\r\n            \r\n            schemes_order[scheme.func_name] = order_approx\r\n            iclr += 1\r\n\r\n        legend(legends, loc=\'best\')\r\n        xlabel(\'Time\')\r\n        ylabel(\'log(error)\')\r\n        grid()\r\n        \r\n        N = N/2**Ndts\r\n        N_list = [N*2**i for i in range(1, Ndts+1)]\r\n        N_list = np.asarray(N_list)\r\n        \r\n        figure()\r\n        for key in schemes_order:\r\n            plot(N_list, (np.asarray(schemes_order[key])))\r\n        \r\n        # Plot theoretical n for 1st, 2nd and 4th order schemes\r\n        axhline(1.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        axhline(2.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        axhline(4.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        xticks(N_list)\r\n        legends = schemes_order.keys()\r\n        legends.append(\'theoretical\') \r\n        legend(legends, loc=\'best\', frameon=False)\r\n        xlabel(\'Number of unknowns\')\r\n        ylabel(\'Scheme order approximation\')\r\n        axis([0, max(N_list), 0, 5])\r\n        savefig(\'ConvergenceODEschemes.png\', transparent=True)\r\n        \r\n    def plot_ODEschemes_solutions():\r\n        """Plot the solutions for the test schemes in schemes"""\r\n        from numpy import linspace\r\n        figure()\r\n        T = 1.5  # end of simulation\r\n        N = 50  # no of time steps\r\n        time = linspace(0, T, N+1)\r\n\r\n        z0 = 2.0\r\n\r\n        schemes  = [euler, heun, rk4]\r\n        legends = []\r\n\r\n        for scheme in schemes:\r\n            z = scheme(f3, z0, time)\r\n            plot(time, z[:,-1])\r\n            legends.append(scheme.func_name)\r\n\r\n        plot(time, u_nonlin_analytical(z0, time))\r\n        legends.append(\'analytical\')\r\n        legend(legends, loc=\'best\', frameon=False)\r\n\r\n\r\n    test_ODEschemes()\r\n    convergence_test()\r\n    plot_ODEschemes_solutions()\r\n    show()\n\n!ec\n\n!ebox\n\nBIBFILE: references/papers.pub',
  'title': u'Numerical error as  a function of $\\Delta t$ for ODE-schemes',
  'type': u'Example',
  'type_visible': True}]