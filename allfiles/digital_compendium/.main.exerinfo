
# Information about all exercises in the file main.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u"Write the following ODE as a system of first order ODEs:\n!bt\n\\begin{align*}\ny'''-y'y''-(y')^2+2y=x^3 \\\\ \ny(0)=a,\\ y'(0)=b,\\ y''(0)=c\n\\end{align*}\n\n!et\n\n#!bsol\nFirst we write $y'''=y'y''+(y')^2-2y+x^3$.\n\nBy use of (ref{eq:1128}) we get\n!bt\n\\begin{align*}\n&y_1'=y_2\\\\ \n&y_2'=y_3\\\\ \n&y_3'=y_2y_3+(y_2)^2-2y_1+x^3\\\\ \n&y_1(0)=a,\\ y_2(0)=b,\\ y_3=c\n\\end{align*}\n\n!et\n#!esol\n#!ec\n!ebox",
  'title': u'Reduction of higher order systems',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'example:sphere_freefall',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'FIGURE:[chapter1/programs_and_modules/2.png, width=200]\n\nThe figure shows a falling sphere with a diameter $d$ and mass $m$\nthat falls vertically in a fluid. Use of Newton\'s 2nd law in the\n$z$-direction gives\n!bt\n\\begin{equation}\nlabel{eq:newton_2nd_sphere}\nm\\frac{dv}{dt} = mg-m_fg-\\frac{1}{2}m_f\\frac{dv}{dt}-\\frac{1}{2}\\rho_fv\\left|v\\right|A_kC_D,\n\\end{equation}\n\n!et\nwhere the different terms are interpreted as follows: $m=\\rho_k V$,\nwhere $\\rho_k$ is the density of the sphere and $V$ is the sphere\nvolume.  The mass of the displaced fluid is given by $m_f=\\rho_f V$,\nwhere $\\rho_f$ is the density of the fluid, whereas buoyancy and the\ndrag coefficient are expressed by $m_f \\, g$ and $C_D$, respectively.\nThe projected area of the sphere is given by $A_k = \\frac{\\pi}{4}d^2$\nand $\\frac{1}{2}m_f$ is the hydro-dynamical mass (added mass). The\nexpression for the hydro-dynamical mass is derived in White\ncite{white1999fluid}, page 539-540. To write Equation\n(ref{eq:newton_2nd_sphere}) on a more convenient form we introduce the\nfollowing abbreviations:\n!bt\n\\begin{equation}\n\\rho=\\frac{\\rho_f}{\\rho_k},\\ A=1+\\frac{\\rho}{2}, \\ B=(1-\\rho)g,\\ C=\\frac{3\\rho}{4d}.\n\\end{equation}\n\n!et\nin addition to the drag coefficient $C_D$ which is a function of the Reynolds number $\\displaystyle R_e = \\frac{vd}{\\nu}$, where $\\nu$ is the kinematical viscosity. Equation (ref{eq:newton_2nd_sphere}) may then be written as\n!bt\n\\begin{equation}\nlabel{eq:sphere_1st_order}\n\\frac{dv}{dt}=\\frac{1}{A}(B-C\\cdot v\\left|v\\right|C_d).\n\\end{equation}\n\n!et\nIn air we may often neglect the buoyancy term and the hydro-dynamical\nmass, whereas this is not the case for a liquid. Introducing\n$v=\\frac{dz}{dt}$ in Equation (ref{eq:sphere_1st_order}), we get a 2nd\norder ODE as follows\n!bt\n\\begin{equation}\nlabel{eq:sphere_second_order}\n\\frac{d^2z}{dt^2}=\\frac{1}{A}\\left(B-C\\cdot \\frac{dz}{dt}\\bigg|\\frac{dz}{dt}\\bigg|C_d\\right)\n\\end{equation}\n\n!et\nFor Equation (ref{eq:sphere_second_order}) two initial conditions must\nbe specified, e.g. $v=v_0$ and $z=z_0$ for $t=0$.\n\nFigure ref{fig:CDsphere} illustrates $C_D$ as a function of $Re$. The values in the plot are not as accurate as the number of digits in the\nprogram might indicate. For example is the location and the size of\nthe "valley" in the diagram strongly dependent of the degree of\nturbulence in the free stream and the roughness of the sphere. As\nthe drag coefficient $C_D$ is a function of the Reynolds number, it is\nalso a function of the solution $v$ (i.e. the velocity) of the ODE in\nEquation (ref{eq:sphere_1st_order}). We will use the function\n$C_D(Re)$ as an example of how functions may be implemented in Python.\n\nFIGURE:[chapter1/programs_and_modules/example_sphere.png, height=400 width=600] Drag coefficient $C_D$ as function of the Reynold\'s number $R_e$. label{fig:CDsphere}\n\n#@@@CODE ./chapter1/programs_and_modules/CDsphere.py from-to: # Define the function cd_sphere@^# Make plot\n\n!ebox',
  'title': u'Sphere in free fall',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'ex:falling_sphere',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'We write (ref{eq:sphere_1st_order}) and (ref{eq:sphere_second_order}) as a system as follows,\n!bt\n\\begin{align}\n& \\frac{dz}{dt}=v label{eq:1303a}\\\\ \n& \\frac{dv}{dt}=g-\\alpha v^2 label{eq:1303b}\n\\end{align}\n\n!et\nwhere\n!bt\n\\begin{equation*}\n\\alpha =\\frac{3\\rho _f}{4\\rho _k\\cdot d}\\cdot C_D\n\\end{equation*}\n\n!et\nThe analytical solution with $z(0)=0$ and $v(0)=0$ is given by\n!bt\n\\begin{align} label{eq:1304a}\n z(t)& =\\frac{\\ln(\\cosh(\\sqrt{\\alpha g}\\cdot t)}{\\alpha} \\\\ \nv(t) &=\\sqrt{\\frac{g}{\\alpha}}\\cdot \\tanh (\\sqrt{\\alpha g}\\cdot t)\n\\end{align}\n\n!et\nThe terminal velocity $v_t$ is found by $\\displaystyle \\frac{dv}{dt}=0$ which gives $\\displaystyle v_t=\\sqrt{\\frac{g}{\\alpha}}$.\n\nWe use data from a golf ball: $d= 41\\text{ mm}$, $\\rho_k = 1275 \\text{ kg/m}^3$, $\\rho_k = 1.22 \\text{ kg/m}^3$, and choose $C_D = 0.4$ which gives $\\alpha = 7\\cdot 10^{-3}$. The terminal velocity then becomes\n!bt\n\\begin{equation*}\nv_t = \\sqrt{\\frac{g}{\\alpha}} = 37.44\n\\end{equation*}\n\n!et\n\nIf we use Taylor\'s method from section ref{sec:taylor} we get the following expression by using four terms in the series expansion:\n!bt\n\\begin{align}\nlabel{eq:1305}\nz(t)=&\\frac{1}{2}gt^2\\cdot (1-\\frac{1}{6}\\alpha gt^2)\\\\ \nv(t)=&g t\\cdot (1-\\frac{1}{3}\\alpha gt^2)\n\\end{align}\n\n!et\n\nThe Euler scheme (ref{eq:1302}) used on (ref{eq:1303b}) gives\n!bt\n\\begin{equation}\nlabel{eq:1306}\nv_{n+1}=v_n+\\Delta t\\cdot (g-\\alpha\\cdot v^2_n),\\ n=0,1,\\dots\n\\end{equation}\n\n!et\nwith $v(0)=0$.\n\nOne way of implementing the integration scheme is given in the following function `euler()`:\n!bc pycod\ndef euler(func,z0, time):\n    """The Euler scheme for solution of systems of ODEs. \n    z0 is a vector for the initial conditions, \n    the right hand side of the system is represented by func which returns \n    a vector with the same size as z0 ."""\n    \n    z = np.zeros((np.size(time),np.size(z0)))\n    z[0,:] = z0\n\n    for i in range(len(time)-1):\n        dt = time[i+1]-time[i]\n        z[i+1,:]=z[i,:] + np.asarray(func(z[i,:],time[i]))*dt\n\n    return z\n\n!ec\n\nThe program _FallingSphereEuler.py_  computes the solution for the first 10 seconds, using a time step of $\\Delta t=0.5$ s, and generates the plot in Figure ref{fig:faling_sphere_euler}. In addition to the case of constant drag coefficient, a solution for the case of varying $C_D$ is included. To find $C_D$ as function of velocity we use the function `cd_sphere()` that we implemented in (ref{example:sphere_freefall}). The complete program is as follows,\n\n!bc pypro\n# chapter1/programs_and_modules/FallingSphereEuler.py;DragCoefficientGeneric.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/DragCoefficientGeneric.py;\nfrom DragCoefficientGeneric import cd_sphere    \nfrom matplotlib.pyplot import *\nimport numpy as np\n\n# change some default values to make plots more readable \nLNWDT=5; FNT=11\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\n\n\ng = 9.81      # Gravity m/s^2\nd = 41.0e-3   # Diameter of the sphere\nrho_f = 1.22  # Density of fluid [kg/m^3]\nrho_s = 1275  # Density of sphere [kg/m^3]\nnu = 1.5e-5   # Kinematical viscosity [m^2/s]\nCD = 0.4      # Constant drag coefficient\n\ndef f(z, t):\n    """2x2 system for sphere with constant drag."""\n    zout = np.zeros_like(z)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout \n\ndef f2(z, t):\n    """2x2 system for sphere with Re-dependent drag."""\n    zout = np.zeros_like(z)\n    v = abs(z[1]) \n    Re = v*d/nu\n    CD = cd_sphere(Re)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout\n\n# define euler scheme\ndef euler(func,z0, time):\n    """The Euler scheme for solution of systems of ODEs. \n    z0 is a vector for the initial conditions, \n    the right hand side of the system is represented by func which returns \n    a vector with the same size as z0 ."""\n    \n    z = np.zeros((np.size(time),np.size(z0)))\n    z[0,:] = z0\n\n    for i in range(len(time)-1):\n        dt = time[i+1]-time[i]\n        z[i+1,:]=z[i,:] + np.asarray(func(z[i,:],time[i]))*dt\n\n    return z\n\ndef v_taylor(t):\n#    z = np.zeros_like(t)\n    v = np.zeros_like(t)\n\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    v=g*t*(1-alpha*g*t**2)\n    return v\n     \n# main program starts here\n\nT = 10  # end of simulation\nN = 20  # no of time steps\ntime = np.linspace(0, T, N+1)\n\nz0=np.zeros(2)\nz0[0] = 2.0\n\nze = euler(f, z0, time)     # compute response with constant CD using Euler\'s method\nze2 = euler(f2, z0, time)   # compute response with varying CD using Euler\'s method\n\nk1 = np.sqrt(g*4*rho_s*d/(3*rho_f*CD))\nk2 = np.sqrt(3*rho_f*g*CD/(4*rho_s*d))\nv_a = k1*np.tanh(k2*time)   # compute response with constant CD using analytical solution\n\n# plotting\n\nlegends=[]\nline_type=[\'-\',\':\',\'.\',\'-.\',\'--\']\n\nplot(time, v_a, line_type[0])\nlegends.append(\'Analytical (constant CD)\')\n\nplot(time, ze[:,1], line_type[1])\nlegends.append(\'Euler (constant CD)\')\n\nplot(time, ze2[:,1], line_type[3])\nlegends.append(\'Euler (varying CD)\')\n\ntime_taylor = np.linspace(0, 4, N+1)\n\nplot(time_taylor, v_taylor(time_taylor))\nlegends.append(\'Taylor (constant CD)\')\n\nlegend(legends, loc=\'best\', frameon=False)\nfont = {\'size\' : 16}\nrc(\'font\', **font)\nxlabel(\'Time [s]\')\nylabel(\'Velocity [m/s]\')\n#savefig(\'example_sphere_falling_euler.png\', transparent=True)\nshow()\n\n!ec\n\nFIGURE:[chapter1/programs_and_modules/example_sphere_falling_euler.png, width=400] Euler\'s method with $\\Delta t=0.5$ s. label{fig:faling_sphere_euler}\n\n!ebox',
  'title': u'Falling sphere with constant and varying drag',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'ex:num_error',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'In this example we will assess how the error of our implementation of\nthe Euler method depends on the time step $\\Delta t$ in a systematic\nmanner. We will solve a problem with an analytical solution in a loop,\nand for each new solution we do the following:\n* Divide the time step by two (or double the number of time steps)\n* Compute the error\n* Plot the error\n\nEuler\'s method is a first order method and we expect the error to be\n$O(h)=O(\\Delta t)$. Consequently if the timestep is divided by two,\nthe error should also be divided by two.\nAs errors normally are small values and are expected to be smaller and\nsmaller for decreasing time steps, we normally do not plot the error\nitself, but rather the logarithm of the absolute value of the\nerror. The latter we do due to the fact that we are only interested in\nthe order of magnitude of the error, whereas errors may be both\npositive and negative. As the initial value is always correct we\ndiscard the first error at time zero to avoid problems with the\nlogarithm of zero in `log_error = np.log10(abs_error[1:])`.\n\n!bc pypro\n# chapter1/programs_and_modules/Euler_timestep_ctrl.py;DragCoefficientGeneric.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/DragCoefficientGeneric.py;\nfrom DragCoefficientGeneric import cd_sphere    \nfrom matplotlib.pyplot import *\nimport numpy as np\n\n# change some default values to make plots more readable \nLNWDT=5; FNT=11\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\nfont = {\'size\' : 16}; rc(\'font\', **font)\n\n\n\ng = 9.81      # Gravity m/s^2\nd = 41.0e-3   # Diameter of the sphere\nrho_f = 1.22  # Density of fluid [kg/m^3]\nrho_s = 1275  # Density of sphere [kg/m^3]\nnu = 1.5e-5   # Kinematical viscosity [m^2/s]\nCD = 0.4      # Constant drag coefficient\n\ndef f(z, t):\n    """2x2 system for sphere with constant drag."""\n    zout = np.zeros_like(z)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout \n\n# define euler scheme\ndef euler(func,z0, time):\n    """The Euler scheme for solution of systems of ODEs. \n    z0 is a vector for the initial conditions, \n    the right hand side of the system is represented by func which returns \n    a vector with the same size as z0 ."""\n    \n    z = np.zeros((np.size(time),np.size(z0)))\n    z[0,:] = z0\n\n    for i in range(len(time)-1):\n        dt = time[i+1]-time[i]\n        z[i+1,:]=z[i,:] + np.asarray(func(z[i,:],time[i]))*dt\n    return z\n\ndef v_taylor(t):\n#    z = np.zeros_like(t)\n    v = np.zeros_like(t)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    v=g*t*(1-alpha*g*t**2)\n    return v\n     \n# main program starts here\n\nT = 10  # end of simulation\nN = 10  # no of time steps\n\n\nz0=np.zeros(2)\nz0[0] = 2.0\n\n# Prms for the analytical solution \nk1 = np.sqrt(g*4*rho_s*d/(3*rho_f*CD))\nk2 = np.sqrt(3*rho_f*g*CD/(4*rho_s*d))\n\nNdts = 4  # Number of times to divide the dt by 2 \nlegends=[]\nerror_diff = []\n\nfor i in range(Ndts+1):\n    time = np.linspace(0, T, N+1)\n    ze = euler(f, z0, time)     # compute response with constant CD using Euler\'s method\n    v_a = k1*np.tanh(k2*time)   # compute response with constant CD using analytical solution\n    abs_error=np.abs(ze[:,1] - v_a)\n    log_error = np.log10(abs_error[1:])\n    max_log_error = np.max(log_error)\n    #plot(time, ze[:,1])\n    plot(time[1:], log_error)\n    legends.append(\'Euler scheme: N \' + str(N) + \' timesteps\' )\n    N*=2\n    if i > 0:\n        error_diff.append(previous_max_log_err-max_log_error)\n\n    previous_max_log_err = max_log_error\n    \nprint 10**(np.mean(error_diff)), np.mean(error_diff)\n\n\n# plot analytical solution\n# plot(time,v_a)\n# legends.append(\'analytical\')\n\n# fix plot \nlegend(legends, loc=\'best\', frameon=False)\nxlabel(\'Time [s]\')\n#ylabel(\'Velocity [m/s]\')\nylabel(\'log10-error\')\nsavefig(\'example_euler_timestep_study.png\', transparent=True)\nshow()\n\n!ec\n\nThe plot resulting from the code above is shown in Figure\n(ref{fig:error_evolution}). The difference or distance between the\ncurves seems to be rather constant after an initial transient. As we\nhave plotted the logarithm of the absolute value of the error $\\epsilon_i$, the difference $d_{i+1}$ between two curves is $d_{i+1}=\n\\log10 \\epsilon_{i}-\\log10 \\epsilon_{i+1} = \\displaystyle \\log10\n\\frac{\\epsilon_{i}}{\\epsilon_{i+1}}$. A rough visual inspection of Figure\n(ref{fig:error_evolution}) yields $d_{i+1} \\approx 0.3$, from which we may deduce:\n!bt\n\\begin{equation}\n\\log10\n\\frac{\\epsilon_{i}}{\\epsilon_{i+1}} \\approx 0.3 \\Rightarrow \\epsilon_{i+1} \\approx 10^{-0.3}\\, \\epsilon_{i} \\approx 0.501\\, \\epsilon_{i}\nlabel{eq:error_approx}\n\\end{equation}\n\n!et\n\nThe     print     statement     `print     10**(np.mean(error_diff)),\nnp.mean(error_diff)`  returns `2.04715154702  0.311149993907`, thus  we\nsee  that   the  error  is   reduced  even  slightly  more   than  the\ntheoretically expected value for a first order scheme, i.e. $\\Delta t_{i+1} = \\Delta t_{i}/2$ yields $\\epsilon_{i+1} \\approx\\epsilon_{i}/2$.\n\n\nFIGURE:[chapter1/programs_and_modules/example_euler_timestep_study.png, width=600 frac=0.4] Plots for the logarithmic errors for a falling sphere with constant drag. The timestep $\\Delta t$ is reduced by a factor two from one curve to the one immediately below.label{fig:error_evolution}\n\n!ebox',
  'title': u'Numerical error as a function of $\\Delta t$',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u"Let's use Heun's method to solve Newton's equation from section ref{section:introduction},\n!bt\n\\begin{equation}\nlabel{eq:1405a}\ny'(x)=1-3x+y+x^2+xy,\\ y(0)=0\n\\end{equation}\n\n!et\nwith analytical solution\n!bt\n\\begin{align}\ny(x)=&3\\sqrt{2\\pi e}\\cdot \\exp\\left(x\\left(1+\\frac{x}{2}\\right)\\right)\\cdot \\left[\\mbox{erf}\\left(\\frac{\\sqrt{2}}{2}(1+x)\\right)-\\mbox{erf}\\left(\\frac{\\sqrt{2}}{2}\\right)\\right]\\nonumber \\\\ \n\t+&4\\cdot \\left[1-\\exp\\left(x\\left(1+\\frac{x}{2}\\right)\\right)\\right]-x\nlabel{eq:1405b}\n\\end{align}\n\n!et\n\nHere we have $f(x,y)=1-3x+y+x^2+xy = 1+x(x-3)+(1+x)y$\n\nThe following program _NewtonHeun.py_ solves this problem using Heun's method, and the resulting figure is shown in Figure ref{fig:newton_heun}.\n\n!bc pypro\n# chapter1/programs_and_modules/NewtonHeun.py\n# Program Newton\n# Computes the solution of Newton's 1st order equation (1671):\n# dy/dx = 1-3*x + y + x^2 +x*y , y(0) = 0\n# using Heun's method.\n\nimport numpy as np\n\nxend = 2\ndx = 0.1\nsteps = np.int(np.round(xend/dx, 0)) + 1 \ny, x = np.zeros((steps,1), float), np.zeros((steps,1), float)\ny[0], x[0] = 0.0, 0.0\n\nfor n in range(0,steps-1):\n    x[n+1] = (n+1)*dx\n    xn = x[n]\n    fn = 1 + xn*(xn-3) + y[n]*(1+xn)\n    yp = y[n] + dx*fn    \n    xnp1 = x[n+1]\n    fnp1 = 1 + xnp1*(xnp1-3) + yp*(1+xnp1)\n    y[n+1] = y[n] + 0.5*dx*(fn+fnp1)\n\n# Analytical solution\nfrom scipy.special import erf\na = np.sqrt(2)/2\nt1 = np.exp(x*(1+ x/2))\nt2 = erf((1+x)*a)-erf(a)\nya = 3*np.sqrt(2*np.pi*np.exp(1))*t1*t2 + 4*(1-t1)-x\n\n# plotting\nimport matplotlib.pylab as py\npy.plot(x, y, '-b.', x, ya, '-g.')\npy.xlabel('x')\npy.ylabel('y')\nfont = {'size' : 16}\npy.rc('font', **font)\npy.title('Solution to Newton\\'s equation')\npy.legend(['Heun', 'Analytical'], loc='best', frameon=False)\npy.grid()\npy.savefig('newton_heun.png', transparent=True)\npy.show()\n\n!ec\n\nFIGURE:[chapter1/programs_and_modules/newton_heun.png, width=400] Velocity of falling sphere using Euler's and Heun's methods. label{fig:newton_heun}\n\n!ebox",
  'title': u"Newton's equation",
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'Let\'s go back to (ref{ex:falling_sphere}), and implement a new function `heun()` in the program "FallingSphereEuler.py": "https://lrhgit.github.io/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/FallingSphereEuler.py".\n\nWe recall the system of equations as\n!bt\n\\begin{align*}\n&\\frac{dz}{dt}=v\\\\ \n&\\frac{dv}{dt}=g-\\alpha v^2\n\\end{align*}\n\n!et\nwhich by use of Heun\'s method in (ref{eq:1404a}) and (ref{eq:1404b}) becomes\n\nPredictor:\n!bt\n\\begin{align}\nz^p_{n+1}&=z_n+\\Delta t v_n \\\\ \nv^p_{n+1}&= v_n +\\Delta t \\cdot (g-\\alpha v^2_n) \\nonumber\n\\end{align}\n\n!et\nCorrector:\n!bt\n\\begin{align}\nz_{n+1}&=z_n+0.5\\Delta t \\cdot (v_n+v^p_{n+1}) \\\\ \nv_{n+1}&=v_n+0.5\\Delta t \\cdot \\left[2g-\\alpha[v^2_n+(v^p_{n+1})^2\\right] \\nonumber\n\\end{align}\n\n!et\nwith initial values $z_0=z(0)=0,\\ v_0=v(0)=0$. Note that we don\'t use the predictor $z^p_{n+1}$ since it doesn\'t appear on the right hand side of the equation system.\n\nOne possible way of implementing this scheme is given in the following function named `heun()`, in the program _ODEschemes.py_:\n!bc pycod\ndef heun(func, z0, time):\r\n    """The Heun scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    def f_np(z,t):\r\n        """A local function to ensure that the return of func is an np array\r\n        and to avoid lengthy code for implementation of the Heun algorithm"""\r\n        return np.asarray(func(z,t))\r\n\r\n    z = np.zeros((np.size(time), np.size(z0)))\r\n    z[0,:] = z0\r\n    zp = np.zeros_like(z0)\r\n\r\n    for i, t in enumerate(time[0:-1]):\r\n        dt = time[i+1] - time[i]\r\n        zp = z[i,:] + f_np(z[i,:],t)*dt   # Predictor step\r\n        z[i+1,:] = z[i,:] + (f_np(z[i,:],t) + f_np(zp,t+dt))*dt/2.0 # Corrector step\n\n!ec\n\nUsing the same time steps as in (ref{ex:falling_sphere}), we get the response plotted in Figure ref{fig:falling_sphere_euler_heun}.\n\nFIGURE:[chapter1/programs_and_modules/example_sphere_falling_euler_heun.png, width=400] Velocity of falling sphere using Euler\'s and Heun\'s methods. label{fig:falling_sphere_euler_heun}\n\nThe complete program _FallingSphereEulerHeun.py_ is listed below. Note that the solver functions `euler` and `heun` are imported from the script _ODEschemes.py_.\n\n!bc pypro\n# chapter1/programs_and_modules/FallingSphereEulerHeun.py;ODEschemes.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/ODEschemes.py;\nfrom DragCoefficientGeneric import cd_sphere\nfrom ODEschemes import euler, heun\nfrom matplotlib.pyplot import *\nimport numpy as np\n\n# change some default values to make plots more readable \nLNWDT=5; FNT=11\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\n\ng = 9.81      # Gravity m/s^2\nd = 41.0e-3   # Diameter of the sphere\nrho_f = 1.22  # Density of fluid [kg/m^3]\nrho_s = 1275  # Density of sphere [kg/m^3]\nnu = 1.5e-5   # Kinematical viscosity [m^2/s]\nCD = 0.4      # Constant drag coefficient\n\ndef f(z, t):\n    """2x2 system for sphere with constant drag."""\n    zout = np.zeros_like(z)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout \n\ndef f2(z, t):\n    """2x2 system for sphere with Re-dependent drag."""\n    zout = np.zeros_like(z)\n    v = abs(z[1]) \n    Re = v*d/nu\n    CD = cd_sphere(Re)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout\n        \n# main program starts here\n\nT = 10  # end of simulation\nN = 20  # no of time steps\ntime = np.linspace(0, T, N+1)\n\nz0=np.zeros(2)\nz0[0] = 2.0\n\nze = euler(f, z0, time)     # compute response with constant CD using Euler\'s method\nze2 = euler(f2, z0, time)   # compute response with varying CD using Euler\'s method\n\nzh = heun(f, z0, time)     # compute response with constant CD using Heun\'s method\nzh2 = heun(f2, z0, time)   # compute response with varying CD using Heun\'s method\n\nk1 = np.sqrt(g*4*rho_s*d/(3*rho_f*CD))\nk2 = np.sqrt(3*rho_f*g*CD/(4*rho_s*d))\nv_a = k1*np.tanh(k2*time)   # compute response with constant CD using analytical solution\n\n# plotting\n\nlegends=[]\nline_type=[\'-\',\':\',\'.\',\'-.\',\'--\']\n\nplot(time, v_a, line_type[0])\nlegends.append(\'Analytical (constant CD)\')\n\nplot(time, ze[:,1], line_type[1])\nlegends.append(\'Euler (constant CD)\')\n\nplot(time, zh[:,1], line_type[2])\nlegends.append(\'Heun (constant CD)\')\n\nplot(time, ze2[:,1], line_type[3])\nlegends.append(\'Euler (varying CD)\')\n\nplot(time, zh2[:,1], line_type[4])\nlegends.append(\'Heun (varying CD)\')\n\nlegend(legends, loc=\'best\', frameon=False)\nfont = {\'size\' : 16}\nrc(\'font\', **font)\nxlabel(\'Time [s]\')\nylabel(\'Velocity [m/s]\')\nsavefig(\'example_sphere_falling_euler_heun.png\', transparent=True)\nshow()\n\n!ec\n\n!ebox',
  'title': u"Falling sphere with Heun's method",
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'example:falling_sphere_RK4',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'Let\'s implement the RK4 scheme and add it to the falling sphere example. The scheme has been implemented in the function `rk4()`, and is given below\n\n!bc pycod\ndef rk4(func, z0, time):\r\n    """The Runge-Kutta 4 scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    z = np.zeros((np.size(time),np.size(z0)))\r\n    z[0,:] = z0\r\n    zp = np.zeros_like(z0)\r\n\r\n    for i, t in enumerate(time[0:-1]):\r\n        dt = time[i+1] - time[i]\r\n        dt2 = dt/2.0\r\n        k1 = np.asarray(func(z[i,:], t))                # predictor step 1\r\n        k2 = np.asarray(func(z[i,:] + k1*dt2, t + dt2)) # predictor step 2\r\n        k3 = np.asarray(func(z[i,:] + k2*dt2, t + dt2)) # predictor step 3\r\n        k4 = np.asarray(func(z[i,:] + k3*dt, t + dt))   # predictor step 4\r\n        z[i+1,:] = z[i,:] + dt/6.0*(k1 + 2.0*k2 + 2.0*k3 + k4) # Corrector step\n\n!ec\n\nFigure ref{fig:falling_sphere_euler_heun_rk4} shows the results using Euler, Heun and RK4. AS seen, RK4 and Heun are more accurate than Euler. The complete program _FallingSphereEulerHeunRK4.py_ is listed below. The functions `euler`, `heun` and `rk4` are imported from the program _ODEschemes.py_. \n\nFIGURE:[chapter1/programs_and_modules/example_sphere_falling_euler_heun_rk4.png, width=400] Velocity of falling sphere using Euler, Heun and RK4. label{fig:falling_sphere_euler_heun_rk4}\n\n!bc pypro\n# chapter1/programs_and_modules/FallingSphereEulerHeunRK4.py;ODEschemes.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/ODEschemes.py;\n\nfrom DragCoefficientGeneric import cd_sphere\nfrom ODEschemes import euler, heun, rk4 \nfrom matplotlib.pyplot import *\nimport numpy as np\n\n# change some default values to make plots more readable \nLNWDT=5; FNT=11\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\n\ng = 9.81      # Gravity m/s^2\nd = 41.0e-3   # Diameter of the sphere\nrho_f = 1.22  # Density of fluid [kg/m^3]\nrho_s = 1275  # Density of sphere [kg/m^3]\nnu = 1.5e-5   # Kinematical viscosity [m^2/s]\nCD = 0.4      # Constant drag coefficient\n\ndef f(z, t):\n    """2x2 system for sphere with constant drag."""\n    zout = np.zeros_like(z)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout \n\ndef f2(z, t):\n    """2x2 system for sphere with Re-dependent drag."""\n    zout = np.zeros_like(z)\n    v = abs(z[1]) \n    Re = v*d/nu\n    CD = cd_sphere(Re)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout\n\n# main program starts here\n\nT = 10  # end of simulation\nN = 20  # no of time steps\ntime = np.linspace(0, T, N+1)\n\nz0=np.zeros(2)\nz0[0] = 2.0\n\nze = euler(f, z0, time)     # compute response with constant CD using Euler\'s method\nze2 = euler(f2, z0, time)   # compute response with varying CD using Euler\'s method\n\nzh = heun(f, z0, time)     # compute response with constant CD using Heun\'s method\nzh2 = heun(f2, z0, time)   # compute response with varying CD using Heun\'s method\n\nzrk4 = rk4(f, z0, time)     # compute response with constant CD using RK4\nzrk4_2 = rk4(f2, z0, time)  # compute response with varying CD using RK4\n\nk1 = np.sqrt(g*4*rho_s*d/(3*rho_f*CD))\nk2 = np.sqrt(3*rho_f*g*CD/(4*rho_s*d))\nv_a = k1*np.tanh(k2*time)   # compute response with constant CD using analytical solution\n\n# plotting\n\nlegends=[]\nline_type=[\'-\',\':\',\'.\',\'-.\',\':\',\'.\',\'-.\']\n\nplot(time, v_a, line_type[0])\nlegends.append(\'Analytical (constant CD)\')\n\nplot(time, ze[:,1], line_type[1])\nlegends.append(\'Euler (constant CD)\')\n\nplot(time, zh[:,1], line_type[2])\nlegends.append(\'Heun (constant CD)\')\n\nplot(time, zrk4[:,1], line_type[3])\nlegends.append(\'RK4 (constant CD)\')\n\nplot(time, ze2[:,1], line_type[4])\nlegends.append(\'Euler (varying CD)\')\n\nplot(time, zh2[:,1], line_type[5])\nlegends.append(\'Heun (varying CD)\')\n\nplot(time, zrk4_2[:,1], line_type[6])\nlegends.append(\'RK4 (varying CD)\')\n\nlegend(legends, loc=\'best\', frameon=False)\n\nfont = {\'size\' : 16}\nrc(\'font\', **font)\nxlabel(\'Time [s]\')\nylabel(\'Velocity [m/s]\')\nsavefig(\'example_sphere_falling_euler_heun_rk4.png\', transparent=True)\nshow()\n\n!ec\n\n!ebox',
  'title': u'Falling sphere using RK4',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'In this example we will calculate the motion of a particle in two dimensions. First we will calculate the motion of a smooth ball with drag coefficient given by the previously defined function `cd_sphere()` (see ref{example:sphere_freefall}), and then of a golf ball with drag and lift.\n\nThe problem is illustrated in the following figure:\nFIGURE:[chapter1/14.png, width=400]\n\nwhere $v$ is the absolute velocity, $v_f=$ is the velocity of the fluid, $v_r=v-v_f$ is the relative velocity between the fluid and the ball, $\\alpha$ is the elevation angle, $v_0$ is the initial velocity and $\\phi$ is the angle between the $x$-axis and $v_r$.\n\n$\\mathbf{F}_l$ is the lift force stemming from the rotation of the ball (the Magnus-effect) and is normal to $v_r$. With the given direction the ball rotates counter-clockwise (backspin). $\\mathbf{F}_d$ is the fluids resistance against the motion and is parallel to $v_r$. These forces are given by\n!bt\n\\begin{align}\n\\mathbf{F}_d=\\frac{1}{2}\\rho _f AC_Dv_r^2\nlabel{eq:1504a}\\\\ \n\\mathbf{F}_l=\\frac{1}{2}\\rho _f AC_Lv_r^2\nlabel{eq:150b}\n\\end{align}\n\n!et\n\n$C_D$ is the drag coefficient, $C_L$ is the lift coefficient, $A$ is the area projected in the velocity direction and $\\rho_F$ is the density of the fluid.\n\nNewton\'s law in $x$- and $y$-directions gives\n!bt\n\\begin{align}\nlabel{eq:1505a}\n\\frac{dv_x}{dt}&= -\\rho _f\\frac{A}{2m}v_r^2(C_D\\cdot \\cos(\\phi)+C_L\\sin(\\phi)) \\\\ \n\\frac{dv_y}{dt}&=\\rho _f\\frac{A}{2m}v_r^2(C_L\\cdot \\cos(\\phi)-C_D\\sin(\\phi))-g\nlabel{eq:1505b}\n\\end{align}\n\n!et\n\nFrom the figure we have\n!bt\n\\begin{align*}\n\\cos (\\phi)&=\\frac{v_{rx}}{v_r} \\\\ \n\\sin(\\phi)&=\\frac{v_{ry}}{v_r}\n\\end{align*}\n\n!et\n\nWe assume that the particle is a sphere, such that $C=\\rho _f\\frac{A}{2m}=\\frac{3\\rho_f}{4\\rho_kd}$ as in (ref{example:sphere_freefall}). Here $d$ is the diameter of the sphere and $\\rho_k$ the density of the sphere.\n\nNow (ref{eq:1505a}) and (ref{eq:1505b}) become\n!bt\n\\begin{align}\nlabel{eq:1506a}\n\\frac{dv_x}{dt} &= -C\\cdot v_r(C_D\\cdot v_{rx}+C_L\\cdot v_{ry})\\\\ \n\\frac{dv_y}{dt} &= C\\cdot v_r(C_L\\cdot v_{rx}-C_D\\cdot v_{ry})-\nlabel{eq:1506b}g\n\\end{align}\n\n!et\n\nWith $\\frac{dx}{dt}=v_x$ and $\\frac{dy}{dt}=v_y$ we get a system of 1st order equations as follows,\n!bt\n\\begin{align}\n&\\frac{dx}{dt}=v_x \\nonumber \\\\ \n& \\frac{dy}{dt}=v_y \\nonumber\\\\ \n& \\frac{dv_x}{dt} = -C\\cdot v_r(C_D\\cdot v_{rx}+C_L\\cdot v_{ry})\nlabel{eq:1507}\\\\ \n&\\frac{dv_y}{dt} = C\\cdot v_r(C_L\\cdot v_{rx}-C_D\\cdot v_{ry})-g \\nonumber\n\\end{align}\n\n!et\n\nIntroducing the notation $x=y_1$, $y=y_2$, $v_x=y_3$, $v_y=y_4$, we get\n!bt\n\\begin{align}\n&\\frac{dy_1}{dt}=y_3\\nonumber\\\\ \n& \\frac{dy_2}{dt}=y_4\\nonumber\\\\ \n& \\frac{dy_3}{dt} = -C\\cdot v_r(C_D\\cdot v_{rx}+C_L\\cdot v_{ry})\nlabel{eq:1508}\\\\ \n&\\frac{dy_4}{dt} = C\\cdot v_r(C_L\\cdot v_{rx}-C_D\\cdot v_{ry})-g\\nonumber\n\\end{align}\n\n!et\n\nHere we have $v_{rx}=v_x-v_{fx}=y_3-v_{fx},\\ v_{ry}=v_y-v_{fy}=y_4-v_{fy},\\\\ v_r=\\sqrt{v_{rx}^2+v_{ry}^2}$\n\nInitial conditions for $t=0$ are\n!bt\n\\begin{align*}\ny_1&=y_2=0 \\\\ \ny_3&=v_0\\cos(\\alpha)\\\\ \ny_4&=v_0\\sin(\\alpha)\n\\end{align*}\n\n!et\n\n-----\n\nLet\'s first look at the case of a smooth ball. We use the following data (which are the data for a golf ball):\n!bt\n\\begin{equation*}\nlabel{eq:1509}\n\\text{Diameter } d = 41 \\text{mm},\\text{ mass } m = 46\\text{g which gives } \\rho_k=\\frac{6m}{\\pi d^3} = 1275 \\text{kg/m}^3\n\\end{equation*}\n\n!et\nWe use the initial velocity $v_0=50$ m/s and solve (ref{eq:1508}) using the Runge-Kutta 4 scheme. In this example we have used the Python package _Odespy_ (ODE Software in Python), which offers a large collection of functions for solving ODE\'s. The RK4 scheme available in Odespy is used herein.\n\nThe right hand side in (ref{eq:1508}) is implemented as the following function:\n!bc pycod\ndef f(z, t):\n    """4x4 system for smooth sphere with drag in two directions."""\n    zout = np.zeros_like(z)\n    C = 3.0*rho_f/(4.0*rho_s*d)\n    vrx = z[2] - vfx\n    vry = z[3] - vfy\n    vr = np.sqrt(vrx**2 + vry**2)\n    Re = vr*d/nu\n    CD = cd_sphere(Re) # using the already defined function\n    zout[:] = [z[2], z[3], -C*vr*(CD*vrx), C*vr*(-CD*vry) - g]\n\n!ec\n\nNote that we have used the function `cd_sphere()` defined in (ref{example:sphere_freefall}) to calculate the drag coefficient of the smooth sphere.\n\nThe results are shown for some initial angles in Figure ref{fig:smooth_ball_drag}.\n\nFIGURE:[chapter1/programs_and_modules/example_particle_motion_2d_1.png, width=700] Motion of smooth ball with drag. label{fig:smooth_ball_drag}\n\n-----\n\nNow let\'s look at the same case for a golf ball. The dimension and weight are the same as for the sphere. Now we need to account for the lift force from the spin of the ball. In addition, the drag data for a golf ball are completely different from the smooth sphere. We use the data from Bearman and Harvey cite{Bearman1976112} who measured the drag and lift of a golf ball for different spin velocities in a vindtunnel. We choose as an example 3500 rpm, and an initial velocity of $v_0=50$ m/s.\n\nThe right hand side in (ref{eq:1508}) is now implemented as the following function:\n!bc pycod\ndef f3(z, t):\n    """4x4 system for golf ball with drag and lift in two directions."""\n    zout = np.zeros_like(z)\n    C = 3.0*rho_f/(4.0*rho_s*d)\n    vrx = z[2] - vfx\n    vry = z[3] - vfy\n    vr = np.sqrt(vrx**2 + vry**2)\n    Re = vr*d/nu\n    CD, CL = cdcl(vr, nrpm)\n    zout[:] = [z[2], z[3], -C*vr*(CD*vrx + CL*vry), C*vr*(CL*vrx - CD*vry) - g]\n\n!ec\n\nThe function `cdcl()` (may be downloaded "here": "https://lrhgit.github.io/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/cdclgolfball.py") gives the drag and lift data for a given velocity and spin.\n\nThe results are shown in Figure ref{fig:golf_drag_lift}. The motion of a golf ball with drag but without lift is also included. We see that the golf ball goes much farther than the smooth sphere, due to less drag and the lift.\n\nFIGURE:[chapter1/programs_and_modules/example_particle_motion_2d_2.png, width=700] Motion of golf ball with drag and lift. label{fig:golf_drag_lift}\n\nThe complete program _ParticleMotion2D.py_ is listed below.\n\n!bc pypro\n# chapter1/programs_and_modules/ParticleMotion2D.py;DragCoefficientGeneric.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/DragCoefficientGeneric.py;cdclgolfball.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/cdclgolfball.py;\n\nfrom DragCoefficientGeneric import cd_sphere\nfrom cdclgolfball import cdcl  \nfrom matplotlib.pyplot import *\nimport numpy as np\nimport odespy\n\ng = 9.81      # Gravity [m/s^2]\nnu = 1.5e-5   # Kinematical viscosity [m^2/s]\nrho_f = 1.20  # Density of fluid [kg/m^3]\nrho_s = 1275  # Density of sphere [kg/m^3]\nd = 41.0e-3   # Diameter of the sphere [m]\nv0 = 50.0     # Initial velocity [m/s]\nvfx = 0.0     # x-component of fluid\'s velocity\nvfy = 0.0     # y-component of fluid\'s velocity\n\nnrpm = 3500   # no of rpm of golf ball\n\n# smooth ball\ndef f(z, t):\n    """4x4 system for smooth sphere with drag in two directions."""\n    zout = np.zeros_like(z)\n    C = 3.0*rho_f/(4.0*rho_s*d)\n    vrx = z[2] - vfx\n    vry = z[3] - vfy\n    vr = np.sqrt(vrx**2 + vry**2)\n    Re = vr*d/nu\n    CD = cd_sphere(Re) # using the already defined function\n    zout[:] = [z[2], z[3], -C*vr*(CD*vrx), C*vr*(-CD*vry) - g]\n    return zout \n\n# golf ball without lift\ndef f2(z, t):\n    """4x4 system for golf ball with drag in two directions."""\n    zout = np.zeros_like(z)\n    C = 3.0*rho_f/(4.0*rho_s*d)\n    vrx = z[2] - vfx\n    vry = z[3] - vfy\n    vr = np.sqrt(vrx**2 + vry**2)\n    Re = vr*d/nu\n    CD, CL = cdcl(vr, nrpm)\n    zout[:] = [z[2], z[3], -C*vr*(CD*vrx), C*vr*(-CD*vry) - g]\n    return zout \n\n# golf ball with lift\ndef f3(z, t):\n    """4x4 system for golf ball with drag and lift in two directions."""\n    zout = np.zeros_like(z)\n    C = 3.0*rho_f/(4.0*rho_s*d)\n    vrx = z[2] - vfx\n    vry = z[3] - vfy\n    vr = np.sqrt(vrx**2 + vry**2)\n    Re = vr*d/nu\n    CD, CL = cdcl(vr, nrpm)\n    zout[:] = [z[2], z[3], -C*vr*(CD*vrx + CL*vry), C*vr*(CL*vrx - CD*vry) - g]\n    return zout \n\n\n# main program starts here\n\nT = 7   # end of simulation\nN = 60  # no of time steps\ntime = np.linspace(0, T, N+1)\n\nN2 = 4\nalfa = np.linspace(30, 15, N2)   # Angle of elevation [degrees]\nangle = alfa*np.pi/180.0 # convert to radians\n\nlegends=[]\nline_color=[\'k\',\'m\',\'b\',\'r\']\nfigure(figsize=(20, 8))\nhold(\'on\')\nLNWDT=4; FNT=18\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\n\n# computing and plotting\n\n# smooth ball with drag\nfor i in range(0,N2):\n    z0 = np.zeros(4)\n    z0[2] = v0*np.cos(angle[i])\n    z0[3] = v0*np.sin(angle[i])\n    solver = odespy.RK4(f)\n    solver.set_initial_condition(z0)\n    z, t = solver.solve(time)\n    plot(z[:,0], z[:,1], \':\', color=line_color[i])\n    legends.append(\'angle=\'+str(alfa[i])+\', smooth ball\')\n    \n# golf ball with drag\nfor i in range(0,N2):\n    z0 = np.zeros(4)\n    z0[2] = v0*np.cos(angle[i])\n    z0[3] = v0*np.sin(angle[i])\n    solver = odespy.RK4(f2)\n    solver.set_initial_condition(z0)\n    z, t = solver.solve(time)\n    plot(z[:,0], z[:,1], \'-.\', color=line_color[i])\n    legends.append(\'angle=\'+str(alfa[i])+\', golf ball\')\n     \n# golf ball with drag and lift\nfor i in range(0,N2):\n    z0 = np.zeros(4)\n    z0[2] = v0*np.cos(angle[i])\n    z0[3] = v0*np.sin(angle[i])\n    solver = odespy.RK4(f3)\n    solver.set_initial_condition(z0)\n    z, t = solver.solve(time)\n    plot(z[:,0], z[:,1], \'.\', color=line_color[i])\n    legends.append(\'angle=\'+str(alfa[i])+\', golf ball (with lift)\')\n \nlegend(legends, loc=\'best\', frameon=False)\nxlabel(\'x [m]\')\nylabel(\'y [m]\')\naxis([0, 250, 0, 50])\nsavefig(\'example_particle_motion_2d_2.png\', transparent=True)\nshow()\n\n!ec\n\n!ebox',
  'title': u'Particle motion in two dimensions',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'To investigate whether the various ODE-schemes in our module \'ODEschemes.py\' \nhave the expected, theoretical order, we proceed in the same manner as\noutlined in ref{ex:num_error}. The complete code is listed at the end\nof this section but we will highlight and explain some details in the\nfollowing. \n\nTo test the numerical order for the schemes we solve a somewhat general linear ODE:\n!bt\n\\begin{align}\n label{eq:gen_lin_ode}\n u\'(t)&= a \\, u + b \\\\ \n u(t_0)&= u_0 \\nonumber\n\\end{align}\n\n!et\nwhich has the analytical solutions:\n!bt\n\\begin{equation}\nu =\\begin{cases}\n \\left (u_0 + \\frac{b}{a} \\right )   \\; e^{a\\, t} -\\frac{b}{a},& \\quad a \\neq 0 \\\\ \n u_0 + b\\, t, &\\quad a = 0 \n\\end{cases}\n\\end{equation}\n\n!et\n\nThe right hand side defining the differential equation has been\nimplemented in function `f3` and the corresponding\nanalytical solution is computed by `u_nonlin_analytical`:\n\n!bc pycod\n    def f3(z, t, a=2.0, b=-1.0):\r\n        """ """\r\n        return a*z + b\r\n\r\n    def u_nonlin_analytical(u0, t, a=2.0, b=-1.0):\r\n        from numpy import exp\r\n        TOL = 1E-14\r\n        if (abs(a)>TOL):\r\n            return (u0 + b/a)*exp(a*t)-b/a\r\n        else:\r\n            return u0 + b*t\n\n!ec\n-----\nThe basic idea for the convergence test in  the function `convergence_test` is that we start out by\nsolving numerically an ODE with an analytical solution on a relatively\ncoarse grid, allowing for direct computations of the error. We then\nreduce the timestep by a factor two (or double the grid size),\nrepeatedly, and compute the error for each grid and compare it with\nthe error of previous grid.\n\nThe Euler scheme (ref{eq:1302}) is $O(h)$, whereas the Heun scheme\n(ref{eq:1403a}) is $O(h^2)$, and Runge-Kutta (ref{eq:1501}) is\n$O(h^4)$, where the $h$ denote a generic step size which for the\ncurrent example is the timestep $\\Delta t$. The order of a particular\nscheme is given exponent $n$ in the error term $O(h^n)$. Consequently, the Euler scheme is a first oder scheme, Heun is second order, whereas Runge-Kutta is fourth order. \n\nBy letting $\\epsilon_{i+1}$ and $\\epsilon_i$ denote the errors on two consecutive grids with corresponding timesteps $\\displaystyle \\Delta t_{i+1} = \\frac{\\Delta t_i}{2}$. The errors $\\epsilon_{i+1}$ and $\\epsilon_{i}$ for a scheme of order $n$ are then related by:\n!bt\n\\begin{equation}\nlabel{eq:eps}\n\\epsilon_{i+1} = \\frac{1}{2^n} \\epsilon_{i}\n\\end{equation}\n\n!et\nConsequently, whenever  $\\epsilon_{i+1}$ and $\\epsilon_{i}$ are known from consecutive simulations an estimate of the order of the scheme may be obtained by:\n!bt\n\\begin{equation}\nlabel{eq:epsapprox}\n n \\approx \\log_2 \\frac{\\epsilon_{i}}{\\epsilon_{i+1}}\n\\end{equation}\n\n!et\nThe theoretical value of $n$ is thus $n=1$ for Euler\'s method, $n=2$ for Heun\'s method and $n=4$ for RK4.\n\nIn the function `convergence_test` the schemes we will subject to a\nconvergence test is ordered in a list `scheme_list`. This allows for a convenient loop over all schemes with the clause: `for scheme in\nscheme_list:`. Subsequently, for each scheme we refine the initial\ngrid (`N=30`) `Ndts` times in the loop `for i in range(Ndts+1):` and\nsolve and compute the order estimate given by (ref{eq:epsapprox}) with\nthe clause `order_approx.append(previous_max_log_err -\nmax_log_err)`. Note that we can not compute this for the first\niteration (`i=0`), and that we use a an initial empty list\n`order_approx` to store the approximation of the order `n` for each\ngrid refinement. For each grid we plot\n$\\log_2(\\epsilon)$ as a function of time with: `plot(time[1:],\nlog_error, linestyles[i]+colors[iclr], markevery=N/5)` and for each\nplot we construct the corresponding legend by appending a new element\nto the legends-list `legends.append(scheme.func_name +\': N = \' + str(N))`.   This construct produces a string with both the scheme name and the number of elements $N$. The plot is not reproduced below, but you may see the result by downloading and running the module yourself. \n\nHaving completed the given number of refinements `Ndts` for a specific scheme\nwe store the `order_approx` for the scheme in a dictionary using the\nname of the scheme as a key by `schemes_orders[scheme.func_name] =\norder_approx`. This allows for an illustrative plot of the order estimate for each scheme with the clause:\n!bc pycod\nfor key in schemes_orders:\n            plot(N_list, (np.asarray(schemes_orders[key])))\n\n!ec\nand the resulting plot is shown in Figure ref{fig:convergence_rate}, and we see that our numerical approximations for the orders of our schemes approach the theoretical values as the number of timesteps increase (or as the timestep is reduced by a factor two consecutively).  \nFIGURE:[chapter1/programs_and_modules/ConvergenceODEschemes.png, width=500] The convergence rate for the various ODE-solvers a function of the number of timesteps. label{fig:convergence_rate}\n\n\nThe complete function `convergence_test` is a part of the module `ODEschemes` and is isolated below:\n\n!bc pycod\n    def convergence_test():\r\n        """ Test convergence rate of the methods """\r\n        from numpy import linspace, size, abs, log10, mean, log2\r\n        figure()\r\n        tol = 1E-15\r\n        T = 8.0   # end of simulation\r\n        Ndts = 5 # Number of times to refine timestep in convergence test\r\n\r\n        z0 = 2\r\n\r\n        schemes =[euler, heun, rk4]\r\n        legends=[]\r\n        schemes_order={}\r\n        \r\n        colors = [\'r\', \'g\', \'b\', \'m\', \'k\', \'y\', \'c\']\r\n        linestyles = [\'-\', \'--\', \'-.\', \':\', \'v--\', \'*-.\']\r\n        iclr = 0\r\n        for scheme in schemes:\r\n            N = 30    # no of time steps\r\n            time = linspace(0, T, N+1)\r\n\r\n            order_approx = []\r\n            \r\n            for i in range(Ndts+1):\r\n                z = scheme(f3, z0, time)   \r\n                abs_error = abs(u_nonlin_analytical(z0, time)-z[:,0])\r\n                log_error = log2(abs_error[1:]) # Drop 1st elt to avoid log2-problems (1st elt is zero)\r\n                max_log_err = max(log_error)\r\n                plot(time[1:], log_error, linestyles[i]+colors[iclr], markevery=N/5)\r\n                legends.append(scheme.func_name +\': N = \' + str(N))\r\n                hold(\'on\')\r\n                \r\n                if i > 0: # Compute the log2 error difference\r\n                    order_approx.append(previous_max_log_err - max_log_err) \r\n                previous_max_log_err = max_log_err\r\n\r\n                N *=2\r\n                time = linspace(0, T, N+1)\r\n            \r\n            schemes_order[scheme.func_name] = order_approx\r\n            iclr += 1\r\n\r\n        legend(legends, loc=\'best\')\r\n        xlabel(\'Time\')\r\n        ylabel(\'log(error)\')\r\n        grid()\r\n        \r\n        N = N/2**Ndts\r\n        N_list = [N*2**i for i in range(1, Ndts+1)]\r\n        N_list = np.asarray(N_list)\r\n        \r\n        figure()\r\n        for key in schemes_order:\r\n            plot(N_list, (np.asarray(schemes_order[key])))\r\n        \r\n        # Plot theoretical n for 1st, 2nd and 4th order schemes\r\n        axhline(1.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        axhline(2.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        axhline(4.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        xticks(N_list)\r\n        legends = schemes_order.keys()\r\n        legends.append(\'theoretical\') \r\n        legend(legends, loc=\'best\', frameon=False)\r\n        xlabel(\'Number of unknowns\')\r\n        ylabel(\'Scheme order approximation\')\r\n        axis([0, max(N_list), 0, 5])\r\n        savefig(\'ConvergenceODEschemes.png\', transparent=True)\n\n!ec\n\n\nThe complete module `ODEschemes` is listed below and may easily be downloaded in your Eclipse/LiClipse IDE:\n!bc pypro\n# chapter1/programs_and_modules/ODEschemes.py\r\n\r\nimport numpy as np\r\nfrom matplotlib.pyplot import plot, show, legend, hold,rcParams,rc, figure, axhline, close,\\\r\n    xticks, xlabel, ylabel, savefig, axis, grid\r\n\r\n# change some default values to make plots more readable \r\nLNWDT=3; FNT=11\r\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\r\nfont = {\'size\' : 16}; rc(\'font\', **font)\r\n\r\n\r\n# define Euler solver\r\ndef euler(func, z0, time):\r\n    """The Euler scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    z = np.zeros((np.size(time), np.size(z0)))\r\n    z[0,:] = z0\r\n\r\n    for i in range(len(time)-1):\r\n        dt = time[i+1] - time[i]\r\n        z[i+1,:]=z[i,:] + np.asarray(func(z[i,:], time[i]))*dt\r\n\r\n    return z\r\n\r\n\r\n# define Heun solver\r\ndef heun(func, z0, time):\r\n    """The Heun scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    def f_np(z,t):\r\n        """A local function to ensure that the return of func is an np array\r\n        and to avoid lengthy code for implementation of the Heun algorithm"""\r\n        return np.asarray(func(z,t))\r\n\r\n    z = np.zeros((np.size(time), np.size(z0)))\r\n    z[0,:] = z0\r\n    zp = np.zeros_like(z0)\r\n\r\n    for i, t in enumerate(time[0:-1]):\r\n        dt = time[i+1] - time[i]\r\n        zp = z[i,:] + f_np(z[i,:],t)*dt   # Predictor step\r\n        z[i+1,:] = z[i,:] + (f_np(z[i,:],t) + f_np(zp,t+dt))*dt/2.0 # Corrector step\r\n\r\n    return z\r\n\r\n\r\n# define rk4 scheme\r\ndef rk4(func, z0, time):\r\n    """The Runge-Kutta 4 scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    z = np.zeros((np.size(time),np.size(z0)))\r\n    z[0,:] = z0\r\n    zp = np.zeros_like(z0)\r\n\r\n    for i, t in enumerate(time[0:-1]):\r\n        dt = time[i+1] - time[i]\r\n        dt2 = dt/2.0\r\n        k1 = np.asarray(func(z[i,:], t))                # predictor step 1\r\n        k2 = np.asarray(func(z[i,:] + k1*dt2, t + dt2)) # predictor step 2\r\n        k3 = np.asarray(func(z[i,:] + k2*dt2, t + dt2)) # predictor step 3\r\n        k4 = np.asarray(func(z[i,:] + k3*dt, t + dt))   # predictor step 4\r\n        z[i+1,:] = z[i,:] + dt/6.0*(k1 + 2.0*k2 + 2.0*k3 + k4) # Corrector step\r\n\r\n    return z\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    a = 0.2\r\n    b = 3.0\r\n    u_exact = lambda t: a*t   +  b\r\n\r\n    def f_local(u,t):\r\n        """A function which returns an np.array but less easy to read\r\n        than f(z,t) below. """\r\n        return np.asarray([a + (u - u_exact(t))**5])\r\n\r\n    def f(z, t):\r\n        """Simple to read function implementation """\r\n        return [a + (z - u_exact(t))**5]\r\n\r\n\r\n    def test_ODEschemes():\r\n        """Use knowledge of an exact numerical solution for testing."""\r\n        from numpy import linspace, size\r\n\r\n        tol = 1E-15\r\n        T = 2.0  # end of simulation\r\n        N = 20  # no of time steps\r\n        time = linspace(0, T, N+1)\r\n\r\n\r\n        z0 = np.zeros(1)\r\n        z0[0] = u_exact(0.0)\r\n\r\n        schemes  = [euler, heun, rk4]\r\n\r\n        for scheme in schemes:\r\n            z = scheme(f, z0, time)\r\n            max_error = np.max(u_exact(time) - z[:,0])\r\n            msg = \'%s failed with error = %g\' % (scheme.func_name, max_error)\r\n            assert max_error < tol, msg\r\n\r\n    # f3 defines an ODE with ananlytical solution in u_nonlin_analytical\r\n    def f3(z, t, a=2.0, b=-1.0):\r\n        """ """\r\n        return a*z + b\r\n\r\n    def u_nonlin_analytical(u0, t, a=2.0, b=-1.0):\r\n        from numpy import exp\r\n        TOL = 1E-14\r\n        if (abs(a)>TOL):\r\n            return (u0 + b/a)*exp(a*t)-b/a\r\n        else:\r\n            return u0 + b*t\r\n            \r\n         \r\n    # Function for convergence test\r\n    def convergence_test():\r\n        """ Test convergence rate of the methods """\r\n        from numpy import linspace, size, abs, log10, mean, log2\r\n        figure()\r\n        tol = 1E-15\r\n        T = 8.0   # end of simulation\r\n        Ndts = 5 # Number of times to refine timestep in convergence test\r\n\r\n        z0 = 2\r\n\r\n        schemes =[euler, heun, rk4]\r\n        legends=[]\r\n        schemes_order={}\r\n        \r\n        colors = [\'r\', \'g\', \'b\', \'m\', \'k\', \'y\', \'c\']\r\n        linestyles = [\'-\', \'--\', \'-.\', \':\', \'v--\', \'*-.\']\r\n        iclr = 0\r\n        for scheme in schemes:\r\n            N = 30    # no of time steps\r\n            time = linspace(0, T, N+1)\r\n\r\n            order_approx = []\r\n            \r\n            for i in range(Ndts+1):\r\n                z = scheme(f3, z0, time)   \r\n                abs_error = abs(u_nonlin_analytical(z0, time)-z[:,0])\r\n                log_error = log2(abs_error[1:]) # Drop 1st elt to avoid log2-problems (1st elt is zero)\r\n                max_log_err = max(log_error)\r\n                plot(time[1:], log_error, linestyles[i]+colors[iclr], markevery=N/5)\r\n                legends.append(scheme.func_name +\': N = \' + str(N))\r\n                hold(\'on\')\r\n                \r\n                if i > 0: # Compute the log2 error difference\r\n                    order_approx.append(previous_max_log_err - max_log_err) \r\n                previous_max_log_err = max_log_err\r\n\r\n                N *=2\r\n                time = linspace(0, T, N+1)\r\n            \r\n            schemes_order[scheme.func_name] = order_approx\r\n            iclr += 1\r\n\r\n        legend(legends, loc=\'best\')\r\n        xlabel(\'Time\')\r\n        ylabel(\'log(error)\')\r\n        grid()\r\n        \r\n        N = N/2**Ndts\r\n        N_list = [N*2**i for i in range(1, Ndts+1)]\r\n        N_list = np.asarray(N_list)\r\n        \r\n        figure()\r\n        for key in schemes_order:\r\n            plot(N_list, (np.asarray(schemes_order[key])))\r\n        \r\n        # Plot theoretical n for 1st, 2nd and 4th order schemes\r\n        axhline(1.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        axhline(2.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        axhline(4.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        xticks(N_list)\r\n        legends = schemes_order.keys()\r\n        legends.append(\'theoretical\') \r\n        legend(legends, loc=\'best\', frameon=False)\r\n        xlabel(\'Number of unknowns\')\r\n        ylabel(\'Scheme order approximation\')\r\n        axis([0, max(N_list), 0, 5])\r\n        savefig(\'ConvergenceODEschemes.png\', transparent=True)\r\n        \r\n    def plot_ODEschemes_solutions():\r\n        """Plot the solutions for the test schemes in schemes"""\r\n        from numpy import linspace\r\n        figure()\r\n        T = 1.5  # end of simulation\r\n        N = 50  # no of time steps\r\n        time = linspace(0, T, N+1)\r\n\r\n        z0 = 2.0\r\n\r\n        schemes  = [euler, heun, rk4]\r\n        legends = []\r\n\r\n        for scheme in schemes:\r\n            z = scheme(f3, z0, time)\r\n            plot(time, z[:,-1])\r\n            legends.append(scheme.func_name)\r\n\r\n        plot(time, u_nonlin_analytical(z0, time))\r\n        legends.append(\'analytical\')\r\n        legend(legends, loc=\'best\', frameon=False)\r\n\r\n\r\n    test_ODEschemes()\r\n    convergence_test()\r\n    plot_ODEschemes_solutions()\r\n    show()\n\n!ec\n\n!ebox\n\nBIBFILE: references/papers.pub',
  'title': u'Numerical error as  a function of $\\Delta t$ for ODE-schemes',
  'type': u'Example',
  'type_visible': True}]