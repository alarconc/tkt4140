
# Information about all exercises in the file main.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u"Write the following ODE as a system of first order ODEs:\n!bt\n\\begin{align*}\ny'''-y'y''-(y')^2+2y=x^3 \\\\ \ny(0)=a,\\ y'(0)=b,\\ y''(0)=c\n\\end{align*}\n\n!et\n\n#!bsol\nFirst we write $y'''=y'y''+(y')^2-2y+x^3$.\n\nBy use of (ref{eq:1128}) we get\n!bt\n\\begin{align*}\n&y_1'=y_2\\\\ \n&y_2'=y_3\\\\ \n&y_3'=y_2y_3+(y_2)^2-2y_1+x^3\\\\ \n&y_1(0)=a,\\ y_2(0)=b,\\ y_3=c\n\\end{align*}\n\n!et\n#!esol\n#!ec\n!ebox",
  'title': u'Reduction of higher order systems',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'example:sphere_freefall',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'FIGURE:[chapter1/programs_and_modules/2.png, width=200]\n\nThe figure shows a falling sphere with a diameter $d$ and mass $m$\nthat falls vertically in a fluid. Use of Newton\'s 2nd law in the\n$z$-direction gives\n!bt\n\\begin{equation}\nlabel{eq:newton_2nd_sphere}\nm\\frac{dv}{dt} = mg-m_fg-\\frac{1}{2}m_f\\frac{dv}{dt}-\\frac{1}{2}\\rho_fv\\left|v\\right|A_kC_D,\n\\end{equation}\n\n!et\nwhere the different terms are interpreted as follows: $m=\\rho_k V$,\nwhere $\\rho_k$ is the density of the sphere and $V$ is the sphere\nvolume.  The mass of the displaced fluid is given by $m_f=\\rho_f V$,\nwhere $\\rho_f$ is the density of the fluid, whereas buoyancy and the\ndrag coefficient are expressed by $m_f \\, g$ and $C_D$, respectively.\nThe projected area of the sphere is given by $A_k = \\frac{\\pi}{4}d^2$\nand $\\frac{1}{2}m_f$ is the hydro-dynamical mass (added mass). The\nexpression for the hydro-dynamical mass is derived in White\ncite{white1999fluid}, page 539-540. To write Equation\n(ref{eq:newton_2nd_sphere}) on a more convenient form we introduce the\nfollowing abbreviations:\n!bt\n\\begin{equation}\n\\rho=\\frac{\\rho_f}{\\rho_k},\\ A=1+\\frac{\\rho}{2}, \\ B=(1-\\rho)g,\\ C=\\frac{3\\rho}{4d}.\n\\end{equation}\n\n!et\nin addition to the drag coefficient $C_D$ which is a function of the Reynolds number $\\displaystyle R_e = \\frac{vd}{\\nu}$, where $\\nu$ is the kinematical viscosity. Equation (ref{eq:newton_2nd_sphere}) may then be written as\n!bt\n\\begin{equation}\nlabel{eq:sphere_1st_order}\n\\frac{dv}{dt}=\\frac{1}{A}(B-C\\cdot v\\left|v\\right|C_d).\n\\end{equation}\n\n!et\nIn air we may often neglect the buoyancy term and the hydro-dynamical\nmass, whereas this is not the case for a liquid. Introducing\n$v=\\frac{dz}{dt}$ in Equation (ref{eq:sphere_1st_order}), we get a 2nd\norder ODE as follows\n!bt\n\\begin{equation}\nlabel{eq:sphere_second_order}\n\\frac{d^2z}{dt^2}=\\frac{1}{A}\\left(B-C\\cdot \\frac{dz}{dt}\\bigg|\\frac{dz}{dt}\\bigg|C_d\\right)\n\\end{equation}\n\n!et\nFor Equation (ref{eq:sphere_second_order}) two initial conditions must\nbe specified, e.g. $v=v_0$ and $z=z_0$ for $t=0$.\n\nFigure ref{fig:CDsphere} illustrates $C_D$ as a function of $Re$. The values in the plot are not as accurate as the number of digits in the\nprogram might indicate. For example is the location and the size of\nthe "valley" in the diagram strongly dependent of the degree of\nturbulence in the free stream and the roughness of the sphere. As\nthe drag coefficient $C_D$ is a function of the Reynolds number, it is\nalso a function of the solution $v$ (i.e. the velocity) of the ODE in\nEquation (ref{eq:sphere_1st_order}). We will use the function\n$C_D(Re)$ as an example of how functions may be implemented in Python.\n\nFIGURE:[chapter1/programs_and_modules/example_sphere.png, height=400 width=600] Drag coefficient $C_D$ as function of the Reynold\'s number $R_e$. label{fig:CDsphere}\n\n#@@@CODE ./chapter1/programs_and_modules/CDsphere.py from-to: # Define the function cd_sphere@^# Make plot\n\n!ebox\n\n\n=== Python implementation of the drag coefficient function and how to plot it === \n\nThe complete Python program _CDsphere.py_ used to plot the drag\ncoefficient in the example above is listed below.  The program uses a\nfunction `cd_sphere` which results from a curve fit to the data of\nEvett and Liu cite{evett19892}. In our setting we will use this\nfunction for two purposes, namely to demonstrate how functions and modules are\nimplemented in Python and finally use these functions in the solution of the ODE in Equations (ref{eq:sphere_1st_order}) and  (ref{eq:sphere_second_order}). \n\n!bc pypro\n# chapter1/programs_and_modules/CDsphere.py\n\nfrom numpy import logspace, zeros\n\n# Define the function cd_sphere\ndef cd_sphere(Re):\n    "This function computes the drag coefficient of a sphere as a function of the Reynolds number Re."\n    # Curve fitted after fig . A -56 in Evett and Liu: "Fluid Mechanics and Hydraulics"\n    \n    from numpy import log10, array, polyval\n    \n    if Re <= 0.0:\n        CD = 0.0\n    elif Re > 8.0e6:\n        CD = 0.2\n    elif Re > 0.0 and Re <= 0.5:\n        CD = 24.0/Re\n    elif Re > 0.5 and Re <= 100.0:\n        p = array([4.22, -14.05, 34.87, 0.658])\n        CD = polyval(p, 1.0/Re) \n    elif Re > 100.0 and Re <= 1.0e4:\n        p = array([-30.41, 43.72, -17.08, 2.41])\n        CD = polyval(p, 1.0/log10(Re))\n    elif Re > 1.0e4 and Re <= 3.35e5:\n        p = array([-0.1584, 2.031, -8.472, 11.932])\n        CD = polyval(p, log10(Re))\n    elif Re > 3.35e5 and Re <= 5.0e5:\n        x1 = log10(Re/4.5e5)\n        CD = 91.08*x1**4 + 0.0764\n    else:\n        p = array([-0.06338, 1.1905, -7.332, 14.93])\n        CD = polyval(p, log10(Re))\n    return CD\n\n# Calculate drag coefficient\nNpts = 500\nRe = logspace(-1, 7, Npts, True, 10)\nCD = zeros(Npts)\ni_list = range(0, Npts-1)\nfor i in i_list:\n    CD[i] = cd_sphere(Re[i])\n\n# Make plot\nfrom matplotlib import pyplot\npyplot.plot(Re, CD, \'-b\')\nfont = {\'size\' : 16}\npyplot.rc(\'font\', **font)\npyplot.yscale(\'log\')\npyplot.xscale(\'log\')\npyplot.xlabel(\'$Re$\')\npyplot.ylabel(\'$C_D$\')\npyplot.grid(\'on\', \'both\', \'both\')\npyplot.savefig(\'example_sphere.png\', transparent=True)\npyplot.show()\n\n!ec\n\nIn the following, we will break up the program and explain the different parts. In the first code line,\n\n!bc pycod\nfrom numpy import logspace, zeros\n\n!ec\n\nthe functions `logspace` and `zeros` are imported from the package `numpy`. The `numpy` package (*NumPy* is an abbreviation for *Numerical Python*) enables the use of *array* objects. Using `numpy`  a wide range of mathematical operations can be done directly on complete arrays, thereby removing the need for loops over array elements. This is commonly called *vectorization* and may cause a dramatic increase in computational speed of Python programs. The function `logspace` works on a logarithmic scale just as the function `linspace` works on a regular scale. The function `zeros` creates arrays of a certain size filled with zeros. Several comprehensive guides to the numpy package may be found at URL: "http://www.numpy.org".\n\nIn _CDsphere.py_ a function `cd_sphere` was defined as follows:\n!bc pycod\ndef cd_sphere(Re):\n    "This function computes the drag coefficient of a sphere as a function of the Reynolds number Re."\n    # Curve fitted after fig . A -56 in Evett and Liu: "Fluid Mechanics and Hydraulics"\n    \n    from numpy import log10, array, polyval\n    \n    if Re <= 0.0:\n        CD = 0.0\n    elif Re > 8.0e6:\n        CD = 0.2\n    elif Re > 0.0 and Re <= 0.5:\n        CD = 24.0/Re\n    elif Re > 0.5 and Re <= 100.0:\n        p = array([4.22, -14.05, 34.87, 0.658])\n        CD = polyval(p, 1.0/Re) \n    elif Re > 100.0 and Re <= 1.0e4:\n        p = array([-30.41, 43.72, -17.08, 2.41])\n        CD = polyval(p, 1.0/log10(Re))\n    elif Re > 1.0e4 and Re <= 3.35e5:\n        p = array([-0.1584, 2.031, -8.472, 11.932])\n        CD = polyval(p, log10(Re))\n    elif Re > 3.35e5 and Re <= 5.0e5:\n        x1 = log10(Re/4.5e5)\n        CD = 91.08*x1**4 + 0.0764\n    else:\n        p = array([-0.06338, 1.1905, -7.332, 14.93])\n        CD = polyval(p, log10(Re))\n    return CD\n\n!ec\nThe function takes `Re` as an argument and returns the value `CD`. All Python functions begin with `def`, followed by the function name, and then inside parentheses a comma-separated list of function arguments, ended with a colon. Here we have only one argument, `Re`. This argument acts as a standard variable inside the function. The statements to perform inside the function must be indented. At the end of a function it is common to use the `return` statement to return the value of the function.\n\nVariables defined inside a function, such as `p` and `x1` above, are *local* variables that cannot be accessed outside the function. Variables defined outside functions, in the "main program", are *global* variables and may be accessed anywhere, also inside functions.\n\nThree more functions from the `numpy` package are imported in the function. They are not used outside the function and are therefore chosen to be imported only if the function is called from the main program. We refer to the "documentation of NumPy": "http://www.numpy.org" for details about the different functions.\n\nThe function above contains an example of the use of the `if-elif-else` block. The block begins with `if` and a boolean expression. If the boolean expression evaluates to `true` the *indented* statements following the `if` statement are carried out. If not, the boolean expression following the `elif` is evaluated. If none of the conditions are evaluated to `true` the statements following the `else` are carried out.\n\nIn the code block\n!bc pycod\nNpts = 500\nRe = logspace(-1, 7, Npts, True, 10)\nCD = zeros(Npts)\ni_list = range(0, Npts-1)\nfor i in i_list:\n    CD[i] = cd_sphere(Re[i])\n\n!ec\nthe function `cd_sphere` is called. First, the number of data points to be calculated are stored in the integer variable `Npts`. Using the `logspace` function imported earlier, `Re` is assigned an array object which has float elements with values ranging from $10^{-1}$ to $10^7$. The values are uniformly distributed along a 10-logarithmic scale. `CD` is first defined as an array with `Npts` zero elements, using the `zero` function. Then, for each element in `Re`, the drag coefficient is calculated using our own defined function `cd_sphere`, in a `for` loop, which is explained in the following.\n\nThe function `range` is a built-in function that generates a list containing arithmetic progressions. The `for i in i_list` construct creates a loop over all elements in `i_list`. In each pass of the loop, the variable `i` refers to an element in the list, starting with `i_list[0]` (0 in this case) and ending with the last element `i_list[Npts-1]` (499 in this case). Note that element indices start at 0 in Python. After the colon comes a block of statements which does something useful with the current element; in this case, the return of the function call `cd_sphere(Re[i])` is assigned to `CD[i]`. Each statement in the block must be indented.\n\nLastly, the drag coefficient is plotted and the figure generated:\n!bc pycod\nfrom matplotlib import pyplot\npyplot.plot(Re, CD, \'-b\')\nfont = {\'size\' : 16}\npyplot.rc(\'font\', **font)\npyplot.yscale(\'log\')\npyplot.xscale(\'log\')\npyplot.xlabel(\'$Re$\')\npyplot.ylabel(\'$C_D$\')\npyplot.grid(\'on\', \'both\', \'both\')\npyplot.savefig(\'example_sphere.png\', transparent=True)\npyplot.show()\n\n!ec\n\nTo generate the plot, the package `matplotlib` is used. `matplotlib` is the standard package for curve plotting in Python. For simple plotting the `matplotlib.pyplot` interface provides a Matlab-like interface, which has been used here. For documentation and explanation of this package, we refer to URL: "http://www.matplotlib.org".\n\nFirst, the curve is generated using the function `plot`, which takes the x-values and y-values as arguments (`Re` and `CD` in this case), as well as a string specifying the line style, like in Matlab. Then changes are made to the figure in order to make it more readable, very similarly to how it is done in Matlab. For instance, in this case it makes sense to use logarithmic scales. A png version of the figure is saved using the `savefig` function. Lastly, the figure is showed on the screen with the `show` function.\n\nTo change the font size the function `rc` is used. This function takes in the object `font`, which is a *dictionary* object. Roughly speaking, a dictionary is a list where the index can be a text (in lists the index must be an integer). It is best to think of a dictionary as an unordered set of `key:value` pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: `{}`. Placing a comma-separated list of `key:value` pairs within the braces adds initial `key:value` pairs to the dictionary. In this case the dictionary `font` contains one `key:value` pair, namely `\'size\' : 16`.\n\nDescriptions and explanations of all functions available in `pyplot` may be found "here": "http://matplotlib.org/api/pyplot_summary.html".',
  'title': u'Sphere in free fall',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'ex:falling_sphere',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'We write (ref{eq:sphere_1st_order}) and (ref{eq:sphere_second_order}) as a system as follows,\n!bt\n\\begin{align}\n& \\frac{dz}{dt}=v label{eq:1303a}\\\\ \n& \\frac{dv}{dt}=g-\\alpha v^2 label{eq:1303b}\n\\end{align}\n\n!et\nwhere\n!bt\n\\begin{equation*}\n\\alpha =\\frac{3\\rho _f}{4\\rho _k\\cdot d}\\cdot C_D\n\\end{equation*}\n\n!et\nThe analytical solution with $z(0)=0$ and $v(0)=0$ is given by\n!bt\n\\begin{equation} label{eq:1304a}\nv(t)=\\sqrt{\\frac{g}{\\alpha}}\\cdot \\tanh (\\sqrt{\\alpha g}\\cdot t), \\ z(t)=\\frac{\\ln(\\cosh(\\sqrt{\\alpha g}\\cdot t)}{\\alpha}\n\\end{equation}\n\n!et\nThe terminal velocity $v_t$ is found by $\\frac{dv}{dt}=0$ which gives $v_t=\\sqrt{\\frac{g}{\\alpha}}$.\n\nWe use data from a golf ball: $d= 41\\text{ mm}$, $\\rho_k = 1275 \\text{ kg/m}^3$, $\\rho_k = 1.22 \\text{ kg/m}^3$, and choose $C_D = 0.4$ which gives $\\alpha = 7\\cdot 10^{-3}$. The terminal velocity then becomes\n!bt\n\\begin{equation*}\nv_t = \\sqrt{\\frac{g}{\\alpha}} = 37.44\n\\end{equation*}\n\n!et\n\nIf we use Taylor\'s method from section ref{sec:taylor} we get the following expression by using four terms in the series expansion:\n!bt\n\\begin{align}\nlabel{eq:1305}\nz(t)=&\\frac{1}{2}gt^2\\cdot (1-\\frac{1}{6}\\alpha gt^2)\\\\ \nv(t)=&g t\\cdot (1-\\frac{1}{3}\\alpha gt^2)\n\\end{align}\n\n!et\n\nThe Euler scheme (ref{eq:1302}) used on (ref{eq:1303b}) gives\n!bt\n\\begin{equation}\nlabel{eq:1306}\nv_{n+1}=v_n+\\Delta t\\cdot (g-\\alpha\\cdot v^2_n),\\ n=0,1,\\dots\n\\end{equation}\n\n!et\nwith $v(0)=0$.\n\nOne way of implementing the integration scheme is given in the following function `euler()`:\n!bc pycod\ndef euler(func,z0, time):\n    """The Euler scheme for solution of systems of ODEs. \n    z0 is a vector for the initial conditions, \n    the right hand side of the system is represented by func which returns \n    a vector with the same size as z0 ."""\n    \n    z = np.zeros((np.size(time),np.size(z0)))\n    z[0,:] = z0\n\n    for i in range(len(time)-1):\n        dt = time[i+1]-time[i]\n        z[i+1,:]=z[i,:] + np.asarray(func(z[i,:],time[i]))*dt\n\n    return z\n\ndef v_taylor(t):\n#    z = np.zeros_like(t)\n    v = np.zeros_like(t)\n\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    v=g*t*(1-alpha*g*t**2)\n    return v\n\n!ec\n\nThe program _FallingSphereEuler.py_ (may be downloaded "here": "https://lrhgit.github.io/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/FallingSphereEuler.py") computes the solution for the first 10 seconds, using a time step of $\\Delta t=0.5$ s, and generates the plot in Figure ref{fig:faling_sphere_euler}. In addition to the case of constant drag coefficient, a solution for the case of varying $C_D$ is included. To find $C_D$ as function of velocity we use the function `cd_sphere()` that we implemented in ref{example:sphere_freefall}. The complete program is as follows,\n\n!bc pypro\n# chapter1/programs_and_modules/FallingSphereEuler.py;DragCoefficientGeneric.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/DragCoefficientGeneric.py;\nfrom DragCoefficientGeneric import cd_sphere    \nfrom matplotlib.pyplot import *\nimport numpy as np\n\n# change some default values to make plots more readable \nLNWDT=5; FNT=11\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\n\n\ng = 9.81      # Gravity m/s^2\nd = 41.0e-3   # Diameter of the sphere\nrho_f = 1.22  # Density of fluid [kg/m^3]\nrho_s = 1275  # Density of sphere [kg/m^3]\nnu = 1.5e-5   # Kinematical viscosity [m^2/s]\nCD = 0.4      # Constant drag coefficient\n\ndef f(z, t):\n    """2x2 system for sphere with constant drag."""\n    zout = np.zeros_like(z)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout \n\ndef f2(z, t):\n    """2x2 system for sphere with Re-dependent drag."""\n    zout = np.zeros_like(z)\n    v = abs(z[1]) \n    Re = v*d/nu\n    CD = cd_sphere(Re)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout\n\n# define euler scheme\ndef euler(func,z0, time):\n    """The Euler scheme for solution of systems of ODEs. \n    z0 is a vector for the initial conditions, \n    the right hand side of the system is represented by func which returns \n    a vector with the same size as z0 ."""\n    \n    z = np.zeros((np.size(time),np.size(z0)))\n    z[0,:] = z0\n\n    for i in range(len(time)-1):\n        dt = time[i+1]-time[i]\n        z[i+1,:]=z[i,:] + np.asarray(func(z[i,:],time[i]))*dt\n\n    return z\n\ndef v_taylor(t):\n#    z = np.zeros_like(t)\n    v = np.zeros_like(t)\n\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    v=g*t*(1-alpha*g*t**2)\n    return v\n     \n# main program starts here\n\nT = 10  # end of simulation\nN = 20  # no of time steps\ntime = np.linspace(0, T, N+1)\n\nz0=np.zeros(2)\nz0[0] = 2.0\n\nze = euler(f, z0, time)     # compute response with constant CD using Euler\'s method\nze2 = euler(f2, z0, time)   # compute response with varying CD using Euler\'s method\n\nk1 = np.sqrt(g*4*rho_s*d/(3*rho_f*CD))\nk2 = np.sqrt(3*rho_f*g*CD/(4*rho_s*d))\nv_a = k1*np.tanh(k2*time)   # compute response with constant CD using analytical solution\n\n# plotting\n\nlegends=[]\nline_type=[\'-\',\':\',\'.\',\'-.\',\'--\']\n\nplot(time, v_a, line_type[0])\nlegends.append(\'Analytical (constant CD)\')\n\nplot(time, ze[:,1], line_type[1])\nlegends.append(\'Euler (constant CD)\')\n\nplot(time, ze2[:,1], line_type[3])\nlegends.append(\'Euler (varying CD)\')\n\ntime_taylor = np.linspace(0, 4, N+1)\n\nplot(time_taylor, v_taylor(time_taylor))\nlegends.append(\'Taylor (constant CD)\')\n\nlegend(legends, loc=\'best\', frameon=False)\nfont = {\'size\' : 16}\nrc(\'font\', **font)\nxlabel(\'Time [s]\')\nylabel(\'Velocity [m/s]\')\n#savefig(\'example_sphere_falling_euler.png\', transparent=True)\nshow()\n\n!ec\n\nFIGURE:[chapter1/programs_and_modules/example_sphere_falling_euler.png, width=400] Euler\'s method with $\\Delta t=0.5$ s. label{fig:faling_sphere_euler}\n\n!ebox',
  'title': u'Falling sphere with constant and varying drag',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'In this example we will assess how the error of our implementation of\nthe Euler method depends on the time step $\\Delta t$ in a systematic\nmanner. We will solve a problem with an analytical solution in a loop,\nand for each new solution we do the following: \n* Divide the time step by two (or double the number of time steps) \n* Compute the error \n* Plot the error \n\nEuler\'s method is a first order method and we therefore expect the\nerror to be $O(h)=O(\\Delta t)$ and if the timestep is divided by two\nshould the error should also be divided by two.\n\nAs errors normally are small values and are expected to be smaller and\nsmaller for decreasing time steps, we normally do not plot the error\nitself, but rather the logaritm of the absolute value of the\nerror. The latter we do due to the fact that we are only interested in\nthe order of magnitude of the error, whereas errors may be both\npositive and negative. As the initial value is always correct we discard the first error at time zero to avoid problems with the logarithm of zero in `log_error = np.log10(abs_error[1:])`. \n\n!bc pypro\n# chapter1/programs_and_modules/Euler_timestep_ctrl.py;DragCoefficientGeneric.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/DragCoefficientGeneric.py;\nfrom DragCoefficientGeneric import cd_sphere    \nfrom matplotlib.pyplot import *\nimport numpy as np\n\n# change some default values to make plots more readable \nLNWDT=5; FNT=11\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\nfont = {\'size\' : 16}; rc(\'font\', **font)\n\n\n\ng = 9.81      # Gravity m/s^2\nd = 41.0e-3   # Diameter of the sphere\nrho_f = 1.22  # Density of fluid [kg/m^3]\nrho_s = 1275  # Density of sphere [kg/m^3]\nnu = 1.5e-5   # Kinematical viscosity [m^2/s]\nCD = 0.4      # Constant drag coefficient\n\ndef f(z, t):\n    """2x2 system for sphere with constant drag."""\n    zout = np.zeros_like(z)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout \n\n# define euler scheme\ndef euler(func,z0, time):\n    """The Euler scheme for solution of systems of ODEs. \n    z0 is a vector for the initial conditions, \n    the right hand side of the system is represented by func which returns \n    a vector with the same size as z0 ."""\n    \n    z = np.zeros((np.size(time),np.size(z0)))\n    z[0,:] = z0\n\n    for i in range(len(time)-1):\n        dt = time[i+1]-time[i]\n        z[i+1,:]=z[i,:] + np.asarray(func(z[i,:],time[i]))*dt\n    return z\n\ndef v_taylor(t):\n#    z = np.zeros_like(t)\n    v = np.zeros_like(t)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    v=g*t*(1-alpha*g*t**2)\n    return v\n     \n# main program starts here\n\nT = 10  # end of simulation\nN = 10  # no of time steps\n\n\nz0=np.zeros(2)\nz0[0] = 2.0\n\n# Prms for the analytical solution \nk1 = np.sqrt(g*4*rho_s*d/(3*rho_f*CD))\nk2 = np.sqrt(3*rho_f*g*CD/(4*rho_s*d))\n\nNdts = 4  # Number of times to divide the dt by 2 \nlegends=[]\nerror_diff = []\n\nfor i in range(Ndts+1):\n    time = np.linspace(0, T, N+1)\n    ze = euler(f, z0, time)     # compute response with constant CD using Euler\'s method\n    v_a = k1*np.tanh(k2*time)   # compute response with constant CD using analytical solution\n    abs_error=np.abs(ze[:,1] - v_a)\n    log_error = np.log10(abs_error[1:])\n    max_log_error = np.max(log_error)\n    #plot(time, ze[:,1])\n    plot(time[1:], log_error)\n    legends.append(\'Euler scheme: N \' + str(N) + \' timesteps\' )\n    N*=2\n    if i > 0:\n        error_diff.append(previous_max_log_err-max_log_error)\n\n    previous_max_log_err = max_log_error\n    \nprint 10**(np.mean(error_diff)), np.mean(error_diff)\n\n\n# plot analytical solution\n# plot(time,v_a)\n# legends.append(\'analytical\')\n\n# fix plot \nlegend(legends, loc=\'best\', frameon=False)\nxlabel(\'Time [s]\')\n#ylabel(\'Velocity [m/s]\')\nylabel(\'log10-error\')\nsavefig(\'example_euler_timestep_study.png\', transparent=True)\nshow()\n\n!ec\n\nThe plot resulting from the code above is shown in Figure\n(ref{fig:error_evolution}). The difference or distance between the\ncurves seems to be rather constant after an initial transient. As we\nhave plotted the logarithm of the absolute value of the error\n$\\epsilon_i$, the difference $d_{i+1}$ between two curves is $d_{i+1}=\n\\log10 \\epsilon_{i+1}-\\log10 \\epsilon_{i} = \\Displaystyle \\log10\n\\frac{\\epsilon_{i+1}}{\\epsilon_{i}}$. A rough visual inspection yields\n$d_{i+1} \\approx 0.3$, from which we may deduce:\n!bt\n\\begin{equation}\n\nlabel{eq:error_approx}\n\\end{equation}\n\n!et\n\n\nFIGURE:[chapter1/programs_and_modules/example_euler_timestep_study.png, width=600 frac=0.4] Plots for the logarithmic errors for a falling sphere with constant drag. The timestep $\\Delta t$ is reduced by a factor two from one curve to the one immediately below.label{fig:error_evolution}',
  'title': u'Numerical error as a function of $\\Delta t$',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u"Let's use Heun's method to solve Newton's equation from section ref{section:introduction},\n!bt\n\\begin{equation}\nlabel{eq:1405a}\ny'(x)=1-3x+y+x^2+xy,\\ y(0)=0\n\\end{equation}\n\n!et\nwith analytical solution\n!bt\n\\begin{align}\ny(x)=&3\\sqrt{2\\pi e}\\cdot \\exp\\left(x\\left(1+\\frac{x}{2}\\right)\\right)\\cdot \\left[\\mbox{erf}\\left(\\frac{\\sqrt{2}}{2}(1+x)\\right)-\\mbox{erf}\\left(\\frac{\\sqrt{2}}{2}\\right)\\right]\\nonumber \\\\ \n\t+&4\\cdot \\left[1-\\exp\\left(x\\left(1+\\frac{x}{2}\\right)\\right)\\right]-x\nlabel{eq:1405b}\n\\end{align}\n\n!et\n\nHere we have $f(x,y)=1-3x+y+x^2+xy = 1+x(x-3)+(1+x)y$\n\nThe following program _NewtonHeun.py_ solves this problem using Heun's method, and the resulting figure is shown in Figure ref{fig:newton_heun}.\n\n!bc pypro\n# chapter1/programs_and_modules/NewtonHeun.py\n# Program Newton\n# Computes the solution of Newton's 1st order equation (1671):\n# dy/dx = 1-3*x + y + x^2 +x*y , y(0) = 0\n# using Heun's method.\n\nimport numpy as np\n\nxend = 2\ndx = 0.1\nsteps = np.int(np.round(xend/dx, 0)) + 1 \ny, x = np.zeros((steps,1), float), np.zeros((steps,1), float)\ny[0], x[0] = 0.0, 0.0\n\nfor n in range(0,steps-1):\n    x[n+1] = (n+1)*dx\n    xn = x[n]\n    fn = 1 + xn*(xn-3) + y[n]*(1+xn)\n    yp = y[n] + dx*fn    \n    xnp1 = x[n+1]\n    fnp1 = 1 + xnp1*(xnp1-3) + yp*(1+xnp1)\n    y[n+1] = y[n] + 0.5*dx*(fn+fnp1)\n\n# Analytical solution\nfrom scipy.special import erf\na = np.sqrt(2)/2\nt1 = np.exp(x*(1+ x/2))\nt2 = erf((1+x)*a)-erf(a)\nya = 3*np.sqrt(2*np.pi*np.exp(1))*t1*t2 + 4*(1-t1)-x\n\n# plotting\nimport matplotlib.pylab as py\npy.plot(x, y, '-b.', x, ya, '-g.')\npy.xlabel('x')\npy.ylabel('y')\nfont = {'size' : 16}\npy.rc('font', **font)\npy.title('Solution to Newton\\'s equation')\npy.legend(['Heun', 'Analytical'], loc='best', frameon=False)\npy.grid()\npy.savefig('newton_heun.png', transparent=True)\npy.show()\n\n!ec\n\nFIGURE:[chapter1/programs_and_modules/newton_heun.png, width=400] Velocity of falling sphere using Euler's and Heun's methods. label{fig:newton_heun}\n\n!ebox",
  'title': u"Newton's equation",
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'Let\'s go back to ref{ex:falling_sphere}, and implement a new function `heun()` in the program "FallingSphereEuler.py": "https://lrhgit.github.io/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/FallingSphereEuler.py".\n\nWe recall the system of equations as\n!bt\n\\begin{align*}\n&\\frac{dz}{dt}=v\\\\ \n&\\frac{dv}{dt}=g-\\alpha v^2\n\\end{align*}\n\n!et\nwhich by use of Heun\'s method in (ref{eq:1404a}) and (ref{eq:1404b}) becomes\n\nPredictor:\n!bt\n\\begin{align}\nz^p_{n+1}&=z_n+\\Delta t v_n \\\\ \nv^p_{n+1}&= v_n +\\Delta t \\cdot (g-\\alpha v^2_n) \\nonumber\n\\end{align}\n\n!et\nCorrector:\n!bt\n\\begin{align}\nz_{n+1}&=z_n+0.5\\Delta t \\cdot (v_n+v^p_{n+1}) \\\\ \nv_{n+1}&=v_n+0.5\\Delta t \\cdot \\left[2g-\\alpha[v^2_n+(v^p_{n+1})^2\\right] \\nonumber\n\\end{align}\n\n!et\nwith initial values $z_0=z(0)=0,\\ v_0=v(0)=0$. Note that we don\'t use the predictor $z^p_{n+1}$ since it doesn\'t appear on the right hand side of the equation system.\n\nOne possible way of implementing this scheme is given in the following function named `heun()`, in the program _ODEschemes.py_:\n!bc pycod\ndef heun(func, z0, time):\r\n    """The Heun scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    def f_np(z,t):\r\n        """A local function to ensure that the return of func is an np array\r\n        and to avoid lengthy code for implementation of the Heun algorithm"""\r\n        return np.asarray(func(z,t))\r\n\r\n    z = np.zeros((np.size(time),np.size(z0)))\r\n    z[0,:] = z0\r\n    zp = np.zeros_like(z0)\r\n\r\n    for i, t in enumerate(time[0:-1]):\r\n        dt = time[i+1]-time[i]\r\n        zp = z[i,:] + f_np(z[i,:],t)*dt   # Predictor step\r\n        z[i+1,:] = z[i,:] + (f_np(z[i,:],t) + f_np(zp,t+dt))*dt/2.0 # Corrector step\n\n!ec\n\nUsing the same time steps as in ref{ex:falling_sphere}, we get the response plotted in Figure ref{fig:falling_sphere_euler_heun}.\n\nFIGURE:[chapter1/programs_and_modules/example_sphere_falling_euler_heun.png, width=400] Velocity of falling sphere using Euler\'s and Heun\'s methods. label{fig:falling_sphere_euler_heun}\n\nThe complete program _FallingSphereEulerHeun.py_ is listed below. Note that the solver functions `euler` and `heun` are imported from the script _ODEschemes.py_.\n\n!bc pypro\n# chapter1/programs_and_modules/FallingSphereEulerHeun.py;ODEschemes.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/ODEschemes.py;\nfrom DragCoefficientGeneric import cd_sphere\nfrom ODEschemes import euler, heun\nfrom matplotlib.pyplot import *\nimport numpy as np\n\n# change some default values to make plots more readable \nLNWDT=5; FNT=11\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\n\ng = 9.81      # Gravity m/s^2\nd = 41.0e-3   # Diameter of the sphere\nrho_f = 1.22  # Density of fluid [kg/m^3]\nrho_s = 1275  # Density of sphere [kg/m^3]\nnu = 1.5e-5   # Kinematical viscosity [m^2/s]\nCD = 0.4      # Constant drag coefficient\n\ndef f(z, t):\n    """2x2 system for sphere with constant drag."""\n    zout = np.zeros_like(z)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout \n\ndef f2(z, t):\n    """2x2 system for sphere with Re-dependent drag."""\n    zout = np.zeros_like(z)\n    v = abs(z[1]) \n    Re = v*d/nu\n    CD = cd_sphere(Re)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout\n        \n# main program starts here\n\nT = 10  # end of simulation\nN = 20  # no of time steps\ntime = np.linspace(0, T, N+1)\n\nz0=np.zeros(2)\nz0[0] = 2.0\n\nze = euler(f, z0, time)     # compute response with constant CD using Euler\'s method\nze2 = euler(f2, z0, time)   # compute response with varying CD using Euler\'s method\n\nzh = heun(f, z0, time)     # compute response with constant CD using Heun\'s method\nzh2 = heun(f2, z0, time)   # compute response with varying CD using Heun\'s method\n\nk1 = np.sqrt(g*4*rho_s*d/(3*rho_f*CD))\nk2 = np.sqrt(3*rho_f*g*CD/(4*rho_s*d))\nv_a = k1*np.tanh(k2*time)   # compute response with constant CD using analytical solution\n\n# plotting\n\nlegends=[]\nline_type=[\'-\',\':\',\'.\',\'-.\',\'--\']\n\nplot(time, v_a, line_type[0])\nlegends.append(\'Analytical (constant CD)\')\n\nplot(time, ze[:,1], line_type[1])\nlegends.append(\'Euler (constant CD)\')\n\nplot(time, zh[:,1], line_type[2])\nlegends.append(\'Heun (constant CD)\')\n\nplot(time, ze2[:,1], line_type[3])\nlegends.append(\'Euler (varying CD)\')\n\nplot(time, zh2[:,1], line_type[4])\nlegends.append(\'Heun (varying CD)\')\n\nlegend(legends, loc=\'best\', frameon=False)\nfont = {\'size\' : 16}\nrc(\'font\', **font)\nxlabel(\'Time [s]\')\nylabel(\'Velocity [m/s]\')\nsavefig(\'example_sphere_falling_euler_heun.png\', transparent=True)\nshow()\n\n!ec\n\n!ebox',
  'title': u"Falling sphere with Heun's method",
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'In this example we will calculate the motion of a particle in two dimensions. First we will calculate the motion of a smooth ball with drag coefficient given by the previously defined function `cd_sphere()` (see ref{example:sphere_freefall}), and then of a golf ball with drag and lift.\n\nThe problem is illustrated in the following figure:\nFIGURE:[chapter1/14.png, width=400]\n\nwhere $v$ is the absolute velocity, $v_f=$ is the velocity of the fluid, $v_r=v-v_f$ is the relative velocity between the fluid and the ball, $\\alpha$ is the elevation angle, $v_0$ is the initial velocity and $\\phi$ is the angle between the $x$-axis and $v_r$.\n\n$\\mathbf{F}_l$ is the lift force stemming from the rotation of the ball (the Magnus-effect) and is normal to $v_r$. With the given direction the ball rotates counter-clockwise (backspin). $\\mathbf{F}_d$ is the fluids resistance against the motion and is parallel to $v_r$. These forces are given by\n!bt\n\\begin{align}\n\\mathbf{F}_d=\\frac{1}{2}\\rho _f AC_Dv_r^2\nlabel{eq:1504a}\\\\ \n\\mathbf{F}_l=\\frac{1}{2}\\rho _f AC_Lv_r^2\nlabel{eq:150b}\n\\end{align}\n\n!et\n\n$C_D$ is the drag coefficient, $C_L$ is the lift coefficient, $A$ is the area projected in the velocity direction and $\\rho_F$ is the density of the fluid.\n\nNewton\'s law in $x$- and $y$-directions gives\n!bt\n\\begin{align}\nlabel{eq:1505a}\n\\frac{dv_x}{dt}&= -\\rho _f\\frac{A}{2m}v_r^2(C_D\\cdot \\cos(\\phi)+C_L\\sin(\\phi)) \\\\ \n\\frac{dv_y}{dt}&=\\rho _f\\frac{A}{2m}v_r^2(C_L\\cdot \\cos(\\phi)-C_D\\sin(\\phi))-g\nlabel{eq:1505b}\n\\end{align}\n\n!et\n\nFrom the figure we have\n!bt\n\\begin{align*}\n\\cos (\\phi)&=\\frac{v_{rx}}{v_r} \\\\ \n\\sin(\\phi)&=\\frac{v_{ry}}{v_r}\n\\end{align*}\n\n!et\n\nWe assume that the particle is a sphere, such that $C=\\rho _f\\frac{A}{2m}=\\frac{3\\rho_f}{4\\rho_kd}$ as in ref{example:sphere_freefall}. Here $d$ is the diameter of the sphere and $\\rho_k$ the density of the sphere.\n\nNow (ref{eq:1505a}) and (ref{eq:1505b}) become\n!bt\n\\begin{align}\nlabel{eq:1506a}\n\\frac{dv_x}{dt} &= -C\\cdot v_r(C_D\\cdot v_{rx}+C_L\\cdot v_{ry})\\\\ \n\\frac{dv_y}{dt} &= C\\cdot v_r(C_L\\cdot v_{rx}-C_D\\cdot v_{ry})-\nlabel{eq:1506b}g\n\\end{align}\n\n!et\n\nWith $\\frac{dx}{dt}=v_x$ and $\\frac{dy}{dt}=v_y$ we get a system of 1st order equations as follows,\n!bt\n\\begin{align}\n&\\frac{dx}{dt}=v_x \\nonumber \\\\ \n& \\frac{dy}{dt}=v_y \\nonumber\\\\ \n& \\frac{dv_x}{dt} = -C\\cdot v_r(C_D\\cdot v_{rx}+C_L\\cdot v_{ry})\nlabel{eq:1507}\\\\ \n&\\frac{dv_y}{dt} = C\\cdot v_r(C_L\\cdot v_{rx}-C_D\\cdot v_{ry})-g \\nonumber\n\\end{align}\n\n!et\n\nIntroducing the notation $x=y_1$, $y=y_2$, $v_x=y_3$, $v_y=y_4$, we get\n!bt\n\\begin{align}\n&\\frac{dy_1}{dt}=y_3\\nonumber\\\\ \n& \\frac{dy_2}{dt}=y_4\\nonumber\\\\ \n& \\frac{dy_3}{dt} = -C\\cdot v_r(C_D\\cdot v_{rx}+C_L\\cdot v_{ry})\nlabel{eq:1508}\\\\ \n&\\frac{dy_4}{dt} = C\\cdot v_r(C_L\\cdot v_{rx}-C_D\\cdot v_{ry})-g\\nonumber\n\\end{align}\n\n!et\n\nHere we have $v_{rx}=v_x-v_{fx}=y_3-v_{fx},\\ v_{ry}=v_y-v_{fy}=y_4-v_{fy},\\\\ v_r=\\sqrt{v_{rx}^2+v_{ry}^2}$\n\nInitial conditions for $t=0$ are\n!bt\n\\begin{align*}\ny_1&=y_2=0 \\\\ \ny_3&=v_0\\cos(\\alpha)\\\\ \ny_4&=v_0\\sin(\\alpha)\n\\end{align*}\n\n!et\n\n-----\n\nLet\'s first look at the case of a smooth ball. We use the following data (which are the data for a golf ball):\n!bt\n\\begin{equation*}\nlabel{eq:1509}\n\\text{Diameter } d = 41 \\text{mm},\\text{ mass } m = 46\\text{g which gives } \\rho_k=\\frac{6m}{\\pi d^3} = 1275 \\text{kg/m}^3\n\\end{equation*}\n\n!et\nWe use the initial velocity $v_0=50$ m/s and solve (ref{eq:1508}) using the Runge-Kutta 4 scheme. In this example we have used the Python package _Odespy_ (ODE Software in Python), which offers a large collection of functions for solving ODE\'s. The RK4 scheme available in Odespy is used herein.\n\nThe right hand side in (ref{eq:1508}) is implemented as the following function:\n!bc pycod\ndef f(z, t):\n    """4x4 system for smooth sphere with drag in two directions."""\n    zout = np.zeros_like(z)\n    C = 3.0*rho_f/(4.0*rho_s*d)\n    vrx = z[2] - vfx\n    vry = z[3] - vfy\n    vr = np.sqrt(vrx**2 + vry**2)\n    Re = vr*d/nu\n    CD = cd_sphere(Re) # using the already defined function\n    zout[:] = [z[2], z[3], -C*vr*(CD*vrx), C*vr*(-CD*vry) - g]\n\n!ec\n\nNote that we have used the function `cd_sphere()` defined in ref{example:sphere_freefall} to calculate the drag coefficient of the smooth sphere.\n\nThe results are shown for some initial angles in Figure ref{fig:smooth_ball_drag}.\n\nFIGURE:[chapter1/programs_and_modules/example_particle_motion_2d_1.png, width=700] Motion of smooth ball with drag. label{fig:smooth_ball_drag}\n\n-----\n\nNow let\'s look at the same case for a golf ball. The dimension and weight are the same as for the sphere. Now we need to account for the lift force from the spin of the ball. In addition, the drag data for a golf ball are completely different from the smooth sphere. We use the data from Bearman and Harvey cite{Bearman1976112} who measured the drag and lift of a golf ball for different spin velocities in a vindtunnel. We choose as an example 3500 rpm, and an initial velocity of $v_0=50$ m/s.\n\nThe right hand side in (ref{eq:1508}) is now implemented as the following function:\n!bc pycod\ndef f3(z, t):\n    """4x4 system for golf ball with drag and lift in two directions."""\n    zout = np.zeros_like(z)\n    C = 3.0*rho_f/(4.0*rho_s*d)\n    vrx = z[2] - vfx\n    vry = z[3] - vfy\n    vr = np.sqrt(vrx**2 + vry**2)\n    Re = vr*d/nu\n    CD, CL = cdcl(vr, nrpm)\n    zout[:] = [z[2], z[3], -C*vr*(CD*vrx + CL*vry), C*vr*(CL*vrx - CD*vry) - g]\n\n!ec\n\nThe function `cdcl()` (may be downloaded "here": "https://lrhgit.github.io/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/cdclgolfball.py") gives the drag and lift data for a given velocity and spin.\n\nThe results are shown in Figure ref{fig:golf_drag_lift}. The motion of a golf ball with drag but without lift is also included. We see that the golf ball goes much farther than the smooth sphere, due to less drag and the lift.\n\nFIGURE:[chapter1/programs_and_modules/example_particle_motion_2d_2.png, width=700] Motion of golf ball with drag and lift. label{fig:golf_drag_lift}\n\nThe complete program _ParticleMotion2D.py_ is listed below.\n\n!bc pypro\n# chapter1/programs_and_modules/ParticleMotion2D.py;DragCoefficientGeneric.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/DragCoefficientGeneric.py;cdclgolfball.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/cdclgolfball.py;\n\nfrom DragCoefficientGeneric import cd_sphere\nfrom cdclgolfball import cdcl  \nfrom matplotlib.pyplot import *\nimport numpy as np\nimport odespy\n\ng = 9.81      # Gravity [m/s^2]\nnu = 1.5e-5   # Kinematical viscosity [m^2/s]\nrho_f = 1.20  # Density of fluid [kg/m^3]\nrho_s = 1275  # Density of sphere [kg/m^3]\nd = 41.0e-3   # Diameter of the sphere [m]\nv0 = 50.0     # Initial velocity [m/s]\nvfx = 0.0     # x-component of fluid\'s velocity\nvfy = 0.0     # y-component of fluid\'s velocity\n\nnrpm = 3500   # no of rpm of golf ball\n\n# smooth ball\ndef f(z, t):\n    """4x4 system for smooth sphere with drag in two directions."""\n    zout = np.zeros_like(z)\n    C = 3.0*rho_f/(4.0*rho_s*d)\n    vrx = z[2] - vfx\n    vry = z[3] - vfy\n    vr = np.sqrt(vrx**2 + vry**2)\n    Re = vr*d/nu\n    CD = cd_sphere(Re) # using the already defined function\n    zout[:] = [z[2], z[3], -C*vr*(CD*vrx), C*vr*(-CD*vry) - g]\n    return zout \n\n# golf ball without lift\ndef f2(z, t):\n    """4x4 system for golf ball with drag in two directions."""\n    zout = np.zeros_like(z)\n    C = 3.0*rho_f/(4.0*rho_s*d)\n    vrx = z[2] - vfx\n    vry = z[3] - vfy\n    vr = np.sqrt(vrx**2 + vry**2)\n    Re = vr*d/nu\n    CD, CL = cdcl(vr, nrpm)\n    zout[:] = [z[2], z[3], -C*vr*(CD*vrx), C*vr*(-CD*vry) - g]\n    return zout \n\n# golf ball with lift\ndef f3(z, t):\n    """4x4 system for golf ball with drag and lift in two directions."""\n    zout = np.zeros_like(z)\n    C = 3.0*rho_f/(4.0*rho_s*d)\n    vrx = z[2] - vfx\n    vry = z[3] - vfy\n    vr = np.sqrt(vrx**2 + vry**2)\n    Re = vr*d/nu\n    CD, CL = cdcl(vr, nrpm)\n    zout[:] = [z[2], z[3], -C*vr*(CD*vrx + CL*vry), C*vr*(CL*vrx - CD*vry) - g]\n    return zout \n\n\n# main program starts here\n\nT = 7   # end of simulation\nN = 60  # no of time steps\ntime = np.linspace(0, T, N+1)\n\nN2 = 4\nalfa = np.linspace(30, 15, N2)   # Angle of elevation [degrees]\nangle = alfa*np.pi/180.0 # convert to radians\n\nlegends=[]\nline_color=[\'k\',\'m\',\'b\',\'r\']\nfigure(figsize=(20, 8))\nhold(\'on\')\nLNWDT=4; FNT=18\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\n\n# computing and plotting\n\n# smooth ball with drag\nfor i in range(0,N2):\n    z0 = np.zeros(4)\n    z0[2] = v0*np.cos(angle[i])\n    z0[3] = v0*np.sin(angle[i])\n    solver = odespy.RK4(f)\n    solver.set_initial_condition(z0)\n    z, t = solver.solve(time)\n    plot(z[:,0], z[:,1], \':\', color=line_color[i])\n    legends.append(\'angle=\'+str(alfa[i])+\', smooth ball\')\n    \n# golf ball with drag\nfor i in range(0,N2):\n    z0 = np.zeros(4)\n    z0[2] = v0*np.cos(angle[i])\n    z0[3] = v0*np.sin(angle[i])\n    solver = odespy.RK4(f2)\n    solver.set_initial_condition(z0)\n    z, t = solver.solve(time)\n    plot(z[:,0], z[:,1], \'-.\', color=line_color[i])\n    legends.append(\'angle=\'+str(alfa[i])+\', golf ball\')\n     \n# golf ball with drag and lift\nfor i in range(0,N2):\n    z0 = np.zeros(4)\n    z0[2] = v0*np.cos(angle[i])\n    z0[3] = v0*np.sin(angle[i])\n    solver = odespy.RK4(f3)\n    solver.set_initial_condition(z0)\n    z, t = solver.solve(time)\n    plot(z[:,0], z[:,1], \'.\', color=line_color[i])\n    legends.append(\'angle=\'+str(alfa[i])+\', golf ball (with lift)\')\n \nlegend(legends, loc=\'best\', frameon=False)\nxlabel(\'x [m]\')\nylabel(\'y [m]\')\naxis([0, 250, 0, 50])\nsavefig(\'example_particle_motion_2d_2.png\', transparent=True)\nshow()\n\n!ec\n\n!ebox\n\n\n\n\nBIBFILE: references/papers.pub',
  'title': u'Particle motion in two dimensions',
  'type': u'Example',
  'type_visible': True}]