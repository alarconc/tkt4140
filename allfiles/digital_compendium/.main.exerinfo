
# Information about all exercises in the file main.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u"Write the following ODE as a system of first order ODEs:\n!bt\n\\begin{align*}\ny'''-y'y''-(y')^2+2y=x^3 \\\\ \ny(0)=a,\\ y'(0)=b,\\ y''(0)=c\n\\end{align*}\n\n!et\n\n#!bsol\nFirst we write $y'''=y'y''+(y')^2-2y+x^3$.\n\nBy use of (ref{eq:1128}) we get\n!bt\n\\begin{align*}\n&y_1'=y_2\\\\ \n&y_2'=y_3\\\\ \n&y_3'=y_2y_3+(y_2)^2-2y_1+x^3\\\\ \n&y_1(0)=a,\\ y_2(0)=b,\\ y_3=c\n\\end{align*}\n\n!et\n#!esol\n#!ec\n!ebox",
  'title': u'Reduction of higher order systems',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'example:sphere_freefall',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'FIGURE:[chapter1/programs_and_modules/2.png, width=200]\n\nThe figure shows a falling sphere with a diameter $d$ and mass $m$\nthat falls vertically in a fluid. Use of Newton\'s 2nd law in the\n$z$-direction gives\n!bt\n\\begin{equation}\nlabel{eq:newton_2nd_sphere}\nm\\frac{dv}{dt} = mg-m_fg-\\frac{1}{2}m_f\\frac{dv}{dt}-\\frac{1}{2}\\rho_fv\\left|v\\right|A_kC_D,\n\\end{equation}\n\n!et\nwhere the different terms are interpreted as follows: $m=\\rho_k V$,\nwhere $\\rho_k$ is the density of the sphere and $V$ is the sphere\nvolume.  The mass of the displaced fluid is given by $m_f=\\rho_f V$,\nwhere $\\rho_f$ is the density of the fluid, whereas buoyancy and the\ndrag coefficient are expressed by $m_f \\, g$ and $C_D$, respectively.\nThe projected area of the sphere is given by $A_k = \\frac{\\pi}{4}d^2$\nand $\\frac{1}{2}m_f$ is the hydro-dynamical mass (added mass). The\nexpression for the hydro-dynamical mass is derived in White\ncite{white1999fluid}, page 539-540. To write Equation\n(ref{eq:newton_2nd_sphere}) on a more convenient form we introduce the\nfollowing abbreviations:\n!bt\n\\begin{equation}\n\\rho=\\frac{\\rho_f}{\\rho_k},\\ A=1+\\frac{\\rho}{2}, \\ B=(1-\\rho)g,\\ C=\\frac{3\\rho}{4d}.\n\\end{equation}\n\n!et\nin addition to the drag coefficient $C_D$ which is a function of the Reynolds number $\\displaystyle R_e = \\frac{vd}{\\nu}$, where $\\nu$ is the kinematical viscosity. Equation (ref{eq:newton_2nd_sphere}) may then be written as\n!bt\n\\begin{equation}\nlabel{eq:sphere_1st_order}\n\\frac{dv}{dt}=\\frac{1}{A}(B-C\\cdot v\\left|v\\right|C_d).\n\\end{equation}\n\n!et\nIn air we may often neglect the buoyancy term and the hydro-dynamical\nmass, whereas this is not the case for a liquid. Introducing\n$v=\\frac{dz}{dt}$ in Equation (ref{eq:sphere_1st_order}), we get a 2nd\norder ODE as follows\n!bt\n\\begin{equation}\nlabel{eq:sphere_second_order}\n\\frac{d^2z}{dt^2}=\\frac{1}{A}\\left(B-C\\cdot \\frac{dz}{dt}\\bigg|\\frac{dz}{dt}\\bigg|C_d\\right)\n\\end{equation}\n\n!et\nFor Equation (ref{eq:sphere_second_order}) two initial conditions must\nbe specified, e.g. $v=v_0$ and $z=z_0$ for $t=0$.\n\nFigure ref{fig:CDsphere} illustrates $C_D$ as a function of $Re$. The values in the plot are not as accurate as the number of digits in the\nprogram might indicate. For example is the location and the size of\nthe "valley" in the diagram strongly dependent of the degree of\nturbulence in the free stream and the roughness of the sphere. As\nthe drag coefficient $C_D$ is a function of the Reynolds number, it is\nalso a function of the solution $v$ (i.e. the velocity) of the ODE in\nEquation (ref{eq:sphere_1st_order}). We will use the function\n$C_D(Re)$ as an example of how functions may be implemented in Python.\n\nFIGURE:[chapter1/programs_and_modules/example_sphere.png, height=400 width=600] Drag coefficient $C_D$ as function of the Reynold\'s number $R_e$. label{fig:CDsphere}\n\n#@@@CODE ./chapter1/programs_and_modules/CDsphere.py from-to: # Define the function cd_sphere@^# Make plot\n\n!ebox',
  'title': u'Sphere in free fall',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'ex:falling_sphere',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'title': u'Falling sphere with constant and varying drag',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'ex:num_error',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'In this example we will assess how the error of our implementation of\nthe Euler method depends on the time step $\\Delta t$ in a systematic\nmanner. We will solve a problem with an analytical solution in a loop,\nand for each new solution we do the following:\n* Divide the time step by two (or double the number of time steps)\n* Compute the error\n* Plot the error\n\nEuler\'s method is a first order method and we expect the error to be\n$O(h)=O(\\Delta t)$. Consequently if the timestep is divided by two,\nthe error should also be divided by two.\nAs errors normally are small values and are expected to be smaller and\nsmaller for decreasing time steps, we normally do not plot the error\nitself, but rather the logaritm of the absolute value of the\nerror. The latter we do due to the fact that we are only interested in\nthe order of magnitude of the error, whereas errors may be both\npositive and negative. As the initial value is always correct we\ndiscard the first error at time zero to avoid problems with the\nlogarithm of zero in `log_error = np.log10(abs_error[1:])`.\n\n!bc pypro\n# chapter1/programs_and_modules/Euler_timestep_ctrl.py;DragCoefficientGeneric.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/DragCoefficientGeneric.py;\r\nfrom DragCoefficientGeneric import cd_sphere    \r\nfrom matplotlib.pyplot import *\r\nimport numpy as np\r\n\r\n# change some default values to make plots more readable \r\nLNWDT=5; FNT=11\r\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\r\nfont = {\'size\' : 16}; rc(\'font\', **font)\r\n\r\n\r\n\r\ng = 9.81      # Gravity m/s^2\r\nd = 41.0e-3   # Diameter of the sphere\r\nrho_f = 1.22  # Density of fluid [kg/m^3]\r\nrho_s = 1275  # Density of sphere [kg/m^3]\r\nnu = 1.5e-5   # Kinematical viscosity [m^2/s]\r\nCD = 0.4      # Constant drag coefficient\r\n\r\ndef f(z, t):\r\n    """2x2 system for sphere with constant drag."""\r\n    zout = np.zeros_like(z)\r\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\r\n    zout[:] = [z[1], g - alpha*z[1]**2]\r\n    return zout \r\n\r\n# define euler scheme\r\ndef euler(func,z0, time):\r\n    """The Euler scheme for solution of systems of ODEs. \r\n    z0 is a vector for the initial conditions, \r\n    the right hand side of the system is represented by func which returns \r\n    a vector with the same size as z0 ."""\r\n    \r\n    z = np.zeros((np.size(time),np.size(z0)))\r\n    z[0,:] = z0\r\n\r\n    for i in range(len(time)-1):\r\n        dt = time[i+1]-time[i]\r\n        z[i+1,:]=z[i,:] + np.asarray(func(z[i,:],time[i]))*dt\r\n    return z\r\n\r\ndef v_taylor(t):\r\n#    z = np.zeros_like(t)\r\n    v = np.zeros_like(t)\r\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\r\n    v=g*t*(1-alpha*g*t**2)\r\n    return v\r\n     \r\n# main program starts here\r\n\r\nT = 10  # end of simulation\r\nN = 10  # no of time steps\r\n\r\n\r\nz0=np.zeros(2)\r\nz0[0] = 2.0\r\n\r\n# Prms for the analytical solution \r\nk1 = np.sqrt(g*4*rho_s*d/(3*rho_f*CD))\r\nk2 = np.sqrt(3*rho_f*g*CD/(4*rho_s*d))\r\n\r\nNdts = 4  # Number of times to divide the dt by 2 \r\nlegends=[]\r\nerror_diff = []\r\n\r\nfor i in range(Ndts+1):\r\n    time = np.linspace(0, T, N+1)\r\n    ze = euler(f, z0, time)     # compute response with constant CD using Euler\'s method\r\n    v_a = k1*np.tanh(k2*time)   # compute response with constant CD using analytical solution\r\n    abs_error=np.abs(ze[:,1] - v_a)\r\n    log_error = np.log10(abs_error[1:])\r\n    max_log_error = np.max(log_error)\r\n    #plot(time, ze[:,1])\r\n    plot(time[1:], log_error)\r\n    legends.append(\'Euler scheme: N \' + str(N) + \' timesteps\' )\r\n    N*=2\r\n    if i > 0:\r\n        error_diff.append(previous_max_log_err-max_log_error)\r\n\r\n    previous_max_log_err = max_log_error\r\n    \r\nprint 10**(np.mean(error_diff)), np.mean(error_diff)\r\n\r\n\r\n# plot analytical solution\r\n# plot(time,v_a)\r\n# legends.append(\'analytical\')\r\n\r\n# fix plot \r\nlegend(legends, loc=\'best\', frameon=False)\r\nxlabel(\'Time [s]\')\r\n#ylabel(\'Velocity [m/s]\')\r\nylabel(\'log10-error\')\r\nsavefig(\'example_euler_timestep_study.png\', transparent=True)\r\nshow()\n\n!ec\n\nThe plot resulting from the code above is shown in Figure\n(ref{fig:error_evolution}). The difference or distance between the\ncurves seems to be rather constant after an initial transient. As we\nhave plotted the logarithm of the absolute value of the error $\\epsilon_i$, the difference $d_{i+1}$ between two curves is $d_{i+1}=\n\\log10 \\epsilon_{i}-\\log10 \\epsilon_{i+1} = \\displaystyle \\log10\n\\frac{\\epsilon_{i}}{\\epsilon_{i+1}}$. A rough visual inspection of Figure\n(ref{fig:error_evolution}) yields $d_{i+1} \\approx 0.3$, from which we may deduce:\n!bt\n\\begin{equation}\n\\log10\n\\frac{\\epsilon_{i}}{\\epsilon_{i+1}} \\approx 0.3 \\Rightarrow \\epsilon_{i+1} \\approx 10^{-0.3}\\, \\epsilon_{i} \\approx 0.501\\, \\epsilon_{i}\nlabel{eq:error_approx}\n\\end{equation}\n\n!et\n\nThe     print     statement     `print     10**(np.mean(error_diff)),\nnp.mean(error_diff)`  returns `2.04715154702  0.311149993907`, thus  we\nsee  that   the  error  is   reduced  even  slightly  more   than  the\ntheoretically expected value for a first order scheme, i.e. $\\Delta t_{i+1} = \\Delta t_{i}/2$ yields $\\epsilon_{i+1} \\approx\\epsilon_{i}/2$.\n\n\nFIGURE:[chapter1/programs_and_modules/example_euler_timestep_study.png, width=600 frac=0.4] Plots for the logarithmic errors for a falling sphere with constant drag. The timestep $\\Delta t$ is reduced by a factor two from one curve to the one immediately below.label{fig:error_evolution}\n\n!ebox',
  'title': u'Numerical error as a function of $\\Delta t$',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u"Let's use Heun's method to solve Newton's equation from section ref{section:introduction},\n!bt\n\\begin{equation}\nlabel{eq:1405a}\ny'(x)=1-3x+y+x^2+xy,\\ y(0)=0\n\\end{equation}\n\n!et\nwith analytical solution\n!bt\n\\begin{align}\ny(x)=&3\\sqrt{2\\pi e}\\cdot \\exp\\left(x\\left(1+\\frac{x}{2}\\right)\\right)\\cdot \\left[\\mbox{erf}\\left(\\frac{\\sqrt{2}}{2}(1+x)\\right)-\\mbox{erf}\\left(\\frac{\\sqrt{2}}{2}\\right)\\right]\\nonumber \\\\ \n\t+&4\\cdot \\left[1-\\exp\\left(x\\left(1+\\frac{x}{2}\\right)\\right)\\right]-x\nlabel{eq:1405b}\n\\end{align}\n\n!et\n\nHere we have $f(x,y)=1-3x+y+x^2+xy = 1+x(x-3)+(1+x)y$\n\nThe following program _NewtonHeun.py_ solves this problem using Heun's method, and the resulting figure is shown in Figure ref{fig:newton_heun}.\n\n!bc pypro\n# chapter1/programs_and_modules/NewtonHeun.py\r\n# Program Newton\r\n# Computes the solution of Newton's 1st order equation (1671):\r\n# dy/dx = 1-3*x + y + x^2 +x*y , y(0) = 0\r\n# using Heun's method.\r\n\r\nimport numpy as np\r\n\r\nxend = 2\r\ndx = 0.1\r\nsteps = np.int(np.round(xend/dx, 0)) + 1 \r\ny, x = np.zeros((steps,1), float), np.zeros((steps,1), float)\r\ny[0], x[0] = 0.0, 0.0\r\n\r\nfor n in range(0,steps-1):\r\n    x[n+1] = (n+1)*dx\r\n    xn = x[n]\r\n    fn = 1 + xn*(xn-3) + y[n]*(1+xn)\r\n    yp = y[n] + dx*fn    \r\n    xnp1 = x[n+1]\r\n    fnp1 = 1 + xnp1*(xnp1-3) + yp*(1+xnp1)\r\n    y[n+1] = y[n] + 0.5*dx*(fn+fnp1)\r\n\r\n# Analytical solution\r\nfrom scipy.special import erf\r\na = np.sqrt(2)/2\r\nt1 = np.exp(x*(1+ x/2))\r\nt2 = erf((1+x)*a)-erf(a)\r\nya = 3*np.sqrt(2*np.pi*np.exp(1))*t1*t2 + 4*(1-t1)-x\r\n\r\n# plotting\r\nimport matplotlib.pylab as py\r\npy.plot(x, y, '-b.', x, ya, '-g.')\r\npy.xlabel('x')\r\npy.ylabel('y')\r\nfont = {'size' : 16}\r\npy.rc('font', **font)\r\npy.title('Solution to Newton\\'s equation')\r\npy.legend(['Heun', 'Analytical'], loc='best', frameon=False)\r\npy.grid()\r\npy.savefig('newton_heun.png', transparent=True)\r\npy.show()\n\n!ec\n\nFIGURE:[chapter1/programs_and_modules/newton_heun.png, width=400] Velocity of falling sphere using Euler's and Heun's methods. label{fig:newton_heun}\n\n!ebox",
  'title': u"Newton's equation",
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'title': u"Falling sphere with Heun's method",
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': u'example:falling_sphere_RK4',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'Let\'s implement the RK4 scheme and add it to the falling sphere example. The scheme has been implemented in the function `rk4()`, and is given below\n\n!bc pycod\ndef rk4(func, z0, time):\r\n    """The Runge-Kutta 4 scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    z = np.zeros((np.size(time),np.size(z0)))\r\n    z[0,:] = z0\r\n    zp = np.zeros_like(z0)\r\n\r\n    for i, t in enumerate(time[0:-1]):\r\n        dt = time[i+1] - time[i]\r\n        dt2 = dt/2.0\r\n        k1 = np.asarray(func(z[i,:], t))                # predictor step 1\r\n        k2 = np.asarray(func(z[i,:] + k1*dt2, t + dt2)) # predictor step 2\r\n        k3 = np.asarray(func(z[i,:] + k2*dt2, t + dt2)) # predictor step 3\r\n        k4 = np.asarray(func(z[i,:] + k3*dt, t + dt))   # predictor step 4\r\n        z[i+1,:] = z[i,:] + dt/6.0*(k1 + 2.0*k2 + 2.0*k3 + k4) # Corrector step\n\n!ec\n\nFigure ref{fig:falling_sphere_euler_heun_rk4} shows the results using Euler, Heun and RK4. AS seen, RK4 and Heun are more accurate than Euler. The complete programme _FallingSphereEulerHeunRK4.py_ is listed below. The functions `euler`, `heun` and `rk4` are imported from the programme _ODEschemes.py_. \n\nFIGURE:[chapter1/programs_and_modules/example_sphere_falling_euler_heun_rk4.png, width=400] Velocity of falling sphere using Euler, Heun and RK4. label{fig:falling_sphere_euler_heun_rk4}\n\n!bc pypro\n# chapter1/programs_and_modules/FallingSphereEulerHeunRK4.py;ODEschemes.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/programs_and_modules/ODEschemes.py;\r\n\r\nfrom DragCoefficientGeneric import cd_sphere\r\nfrom ODEschemes import euler, heun, rk4 \r\nfrom matplotlib.pyplot import *\r\nimport numpy as np\r\n\r\n# change some default values to make plots more readable \r\nLNWDT=5; FNT=11\r\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\r\n\r\ng = 9.81      # Gravity m/s^2\r\nd = 41.0e-3   # Diameter of the sphere\r\nrho_f = 1.22  # Density of fluid [kg/m^3]\r\nrho_s = 1275  # Density of sphere [kg/m^3]\r\nnu = 1.5e-5   # Kinematical viscosity [m^2/s]\r\nCD = 0.4      # Constant drag coefficient\r\n\r\ndef f(z, t):\r\n    """2x2 system for sphere with constant drag."""\r\n    zout = np.zeros_like(z)\r\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\r\n    zout[:] = [z[1], g - alpha*z[1]**2]\r\n    return zout \r\n\r\ndef f2(z, t):\r\n    """2x2 system for sphere with Re-dependent drag."""\r\n    zout = np.zeros_like(z)\r\n    v = abs(z[1]) \r\n    Re = v*d/nu\r\n    CD = cd_sphere(Re)\r\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\r\n    zout[:] = [z[1], g - alpha*z[1]**2]\r\n    return zout\r\n\r\n# main program starts here\r\n\r\nT = 10  # end of simulation\r\nN = 20  # no of time steps\r\ntime = np.linspace(0, T, N+1)\r\n\r\nz0=np.zeros(2)\r\nz0[0] = 2.0\r\n\r\nze = euler(f, z0, time)     # compute response with constant CD using Euler\'s method\r\nze2 = euler(f2, z0, time)   # compute response with varying CD using Euler\'s method\r\n\r\nzh = heun(f, z0, time)     # compute response with constant CD using Heun\'s method\r\nzh2 = heun(f2, z0, time)   # compute response with varying CD using Heun\'s method\r\n\r\nzrk4 = rk4(f, z0, time)     # compute response with constant CD using RK4\r\nzrk4_2 = rk4(f2, z0, time)  # compute response with varying CD using RK4\r\n\r\nk1 = np.sqrt(g*4*rho_s*d/(3*rho_f*CD))\r\nk2 = np.sqrt(3*rho_f*g*CD/(4*rho_s*d))\r\nv_a = k1*np.tanh(k2*time)   # compute response with constant CD using analytical solution\r\n\r\n# plotting\r\n\r\nlegends=[]\r\nline_type=[\'-\',\':\',\'.\',\'-.\',\':\',\'.\',\'-.\']\r\n\r\nplot(time, v_a, line_type[0])\r\nlegends.append(\'Analytical (constant CD)\')\r\n\r\nplot(time, ze[:,1], line_type[1])\r\nlegends.append(\'Euler (constant CD)\')\r\n\r\nplot(time, zh[:,1], line_type[2])\r\nlegends.append(\'Heun (constant CD)\')\r\n\r\nplot(time, zrk4[:,1], line_type[3])\r\nlegends.append(\'RK4 (constant CD)\')\r\n\r\nplot(time, ze2[:,1], line_type[4])\r\nlegends.append(\'Euler (varying CD)\')\r\n\r\nplot(time, zh2[:,1], line_type[5])\r\nlegends.append(\'Heun (varying CD)\')\r\n\r\nplot(time, zrk4_2[:,1], line_type[6])\r\nlegends.append(\'RK4 (varying CD)\')\r\n\r\nlegend(legends, loc=\'best\', frameon=False)\r\n\r\nfont = {\'size\' : 16}\r\nrc(\'font\', **font)\r\nxlabel(\'Time [s]\')\r\nylabel(\'Velocity [m/s]\')\r\nsavefig(\'example_sphere_falling_euler_heun_rk4.png\', transparent=True)\r\nshow()\n\n!ec\n\n!ebox',
  'title': u'Falling sphere using RK4',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'title': u'Particle motion in two dimensions',
  'type': u'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': u'=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': u'To investigate whether the various ODE-schemes in our module \'ODEschemes.py\' \nhave the expected, theoretical order, we proceed in the same manner as\noutlined in ref{ex:num_error}. The complete code is listed at the end\nof this section but we will highlight and explain some details in the\nfollowing. \n\nTo test the numerical order for the schemes we solve a somewhat general linear ODE:\n!bt\n\\begin{align}\n label{eq:gen_lin_ode}\n u\'(t)&= a \\, u + b \\\\ \n u(t_0)&= u_0 \\nonumber\n\\end{align}\n\n!et\nwhich has the analytical solutions:\n!bt\n\\begin{equation}\nu =\\begin{cases}\n \\left (u_0 + \\frac{b}{a} \\right )   \\; e^{a\\, t} -\\frac{b}{a},& \\quad a \\neq 0 \\\\ \n u_0 + b\\, t, &\\quad a = 0 \n\\end{cases}\n\\end{equation}\n\n!et\n\nThe right hand side defining the differential equation has been\nimplemented in function `f3` and the corresponding\nanalytical solution is computed by `u_nonlin_analytical`:\n\n!bc pycod\n    def f3(z, t,a=2.0,b=-1.0):\r\n        """ """\r\n        return a*z + b\r\n\r\n    def u_nonlin_analytical(u0, t, a=2.0, b=-1.0):\r\n        from numpy import exp\r\n        TOL = 1E-14\r\n        if (abs(a)>TOL):\r\n            return (u0 + b/a)*exp(a*t)-b/a\r\n        else:\r\n            return u0 + b*t\n\n!ec\n-----\n\nWe have listed the function `test_convergence` below in will comment on some of the details with respect to implementation in the following.\n# u &= \\left { \\left (u_0 + \\frac{b}{a} \\right) e^{a\\, t} -\\frac{b}{a}, \\quad a \\neq 0 \\right .\n\n\n!bc pycod\n    def test_convergence():\r\n        """ Test convergence rate of the methods """\r\n        from numpy import linspace, size, abs, log10, mean\r\n        figure()\r\n        tol = 1E-15\r\n        T = 8.0   # end of simulation\r\n        Ndts = 5 # Number of times to refine timestep in convergence test\r\n\r\n        z0 = 2\r\n\r\n#        scheme_list  = [euler, euler2, euler3, euler4, heun, heun2, rk4]\r\n        scheme_list =[euler, heun, rk4]\r\n        legends=[]\r\n        all_errors={}\r\n        \r\n        colors = [\'r\', \'g\', \'b\', \'m\', \'k\', \'y\', \'c\']\r\n        linestyles = [\'-\', \'--\', \'-.\', \':\', \'v--\', \'*-.\']\r\n        iclr = 0\r\n        for scheme in scheme_list:\r\n            N = 30    # no of time steps\r\n            time = linspace(0, T, N+1)\r\n\r\n            error_diff = []\r\n            \r\n            for i in range(Ndts+1):\r\n                z = scheme(f3, z0, time)   \r\n                abs_error = abs(u_nonlin_analytical(z0, time)-z[:,0])\r\n                log_error = log10(abs_error[1:]) # Drop first element as it is always zero to avoid log10-problems\r\n                max_log_err = max(log_error)\r\n                plot(time[1:], log_error, linestyles[i]+colors[iclr], markevery=N/5)\r\n                legends.append(scheme.func_name +\': N = \' + str(N))\r\n                hold(\'on\')\r\n                \r\n                if i > 0: # Compute the log10 error difference\r\n                    error_diff.append(previous_max_log_err - max_log_err) \r\n                previous_max_log_err = max_log_err\r\n                \r\n                \r\n                N *=2\r\n                time = linspace(0, T, N+1)\r\n            \r\n            all_errors[scheme.func_name] = error_diff\r\n#             print error_diff\r\n#             print mean(error_diff), 10**(mean(error_diff)), error_diff\r\n#             print 10**np.asarray(error_diff)\r\n            iclr += 1\r\n\r\n        legend(legends, loc=\'best\')\r\n        xlabel(\'Time\')\r\n        ylabel(\'log(error)\')\r\n        grid()\r\n        \r\n        N = N/2**Ndts\r\n        N_list = [N*2**i for i in range(1, Ndts+1)]\r\n        N_list = np.asarray(N_list)\r\n#         print N_list         \r\n        \r\n        figure()\r\n        for key in all_errors:\r\n            plot(N_list, 10**(np.asarray(all_errors[key])))\r\n        \r\n        # Plot theoretical error reductions for first, second and fourth order schemes\r\n        axhline(2.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        axhline(4.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        axhline(16.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        xticks(N_list)\r\n        legends = all_errors.keys()\r\n        legends.append(\'theoretical\') \r\n        legend(legends, loc=\'best\', frameon=False)\r\n        xlabel(\'Number of unknowns\')\r\n        ylabel(\'Error reduction when reducing timestep by two\')\r\n        axis([0, max(N_list), 0, 17])\r\n        savefig(\'ConvergenceODEschemes.png\', transparent=True)\n\n!ec\n\nFIGURE:[chapter1/programs_and_modules/ConvergenceODEschemes.png, width=700] The convergence rate for the various ODE-solvers a function of the number of timesteps. label{fig:convergence_rate}\n\nComplete code:\n!bc pypro\n# chapter1/programs_and_modules/ODEschemes.py\r\n\r\nimport numpy as np\r\nfrom matplotlib.pyplot import plot, show, legend, hold,rcParams,rc, figure, axhline, close,\\\r\n    xticks, xlabel, ylabel, savefig, axis, grid\r\n\r\n# change some default values to make plots more readable \r\nLNWDT=3; FNT=11\r\nrcParams[\'lines.linewidth\'] = LNWDT; rcParams[\'font.size\'] = FNT\r\nfont = {\'size\' : 16}; rc(\'font\', **font)\r\n\r\n\r\n# define Euler solver\r\ndef euler(func, z0, time):\r\n    """The Euler scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    z = np.zeros((np.size(time), np.size(z0)))\r\n    z[0,:] = z0\r\n\r\n    for i in range(len(time)-1):\r\n        dt = time[i+1] - time[i]\r\n        z[i+1,:]=z[i,:] + np.asarray(func(z[i,:], time[i]))*dt\r\n\r\n    return z\r\n\r\ndef euler2(func, z0, time):\r\n    """The Euler scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    def f_np(z,t):\r\n        return np.asarray(func(z, t))\r\n\r\n    z = np.zeros((np.size(time), np.size(z0)))\r\n    z[0,:] = z0\r\n\r\n    for i, t in enumerate(time[0:-1]):\r\n        dt = time[i+1] - t\r\n        z[i+1,:]=z[i,:] + f_np(z[i,:],t)*dt\r\n\r\n    return z\r\n\r\ndef euler3(func, z0, time):\r\n    """The Euler scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    time_local = np.asarray(time)\r\n    z = np.zeros((np.size(time_local), np.size(z0)))\r\n    z[0,:] = float(z0)\r\n\r\n    for i, t in enumerate(time_local[0:-1]):\r\n        dt = time_local[i+1] - t\r\n        z[i+1,:] = z[i,:] + np.asarray(func(z[i,:], t))*dt\r\n\r\n    return z\r\n\r\ndef euler4(func, z0, time):\r\n    """The Euler scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    time_local = np.asarray(time)\r\n    z = np.zeros((np.size(time_local), np.size(z0)))\r\n    z[0,:] = float(z0)\r\n\r\n    for i, t in enumerate(time_local[1:]):\r\n        dt = t - time_local[i]\r\n        z[i+1,:]=z[i,:] + np.asarray(func(z[i,:], time_local[i]))*dt\r\n\r\n    return z\r\n\r\n# define Heun solver\r\ndef heun(func, z0, time):\r\n    """The Heun scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    def f_np(z,t):\r\n        """A local function to ensure that the return of func is an np array\r\n        and to avoid lengthy code for implementation of the Heun algorithm"""\r\n        return np.asarray(func(z,t))\r\n\r\n    z = np.zeros((np.size(time), np.size(z0)))\r\n    z[0,:] = z0\r\n    zp = np.zeros_like(z0)\r\n\r\n    for i, t in enumerate(time[0:-1]):\r\n        dt = time[i+1] - time[i]\r\n        zp = z[i,:] + f_np(z[i,:],t)*dt   # Predictor step\r\n        z[i+1,:] = z[i,:] + (f_np(z[i,:],t) + f_np(zp,t+dt))*dt/2.0 # Corrector step\r\n\r\n    return z\r\n\r\ndef heun2(func, z0, time):\r\n    """The Heun scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    z = np.zeros((np.size(time), np.size(z0)))\r\n    z[0,:] = z0\r\n    zp = np.zeros_like(z0)\r\n\r\n    for i, t in enumerate(time[0:-1]):\r\n        dt = time[i+1] - time[i]\r\n        zp = z[i,:] + np.asarray(func(z[i,:],t))*dt   # Predictor step\r\n        z[i+1,:] = z[i,:] + (np.asarray(func(z[i,:],t)) + np.asarray(func(zp,t+dt)))*dt/2.0 # Corrector step\r\n\r\n    return z\r\n\r\n# define rk4 scheme\r\ndef rk4(func, z0, time):\r\n    """The Runge-Kutta 4 scheme for solution of systems of ODEs.\r\n    z0 is a vector for the initial conditions,\r\n    the right hand side of the system is represented by func which returns\r\n    a vector with the same size as z0 ."""\r\n\r\n    z = np.zeros((np.size(time),np.size(z0)))\r\n    z[0,:] = z0\r\n    zp = np.zeros_like(z0)\r\n\r\n    for i, t in enumerate(time[0:-1]):\r\n        dt = time[i+1] - time[i]\r\n        dt2 = dt/2.0\r\n        k1 = np.asarray(func(z[i,:], t))                # predictor step 1\r\n        k2 = np.asarray(func(z[i,:] + k1*dt2, t + dt2)) # predictor step 2\r\n        k3 = np.asarray(func(z[i,:] + k2*dt2, t + dt2)) # predictor step 3\r\n        k4 = np.asarray(func(z[i,:] + k3*dt, t + dt))   # predictor step 4\r\n        z[i+1,:] = z[i,:] + dt/6.0*(k1 + 2.0*k2 + 2.0*k3 + k4) # Corrector step\r\n\r\n    return z\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    a = 0.2\r\n    b = 3.0\r\n    u_exact = lambda t: a*t   +  b\r\n\r\n    def f_local(u,t):\r\n        """A function which returns an np.array but less easy to read\r\n        than f(z,t) below. """\r\n        return np.asarray([a + (u - u_exact(t))**5])\r\n\r\n    def f(z, t):\r\n        """Simple to read function implementation """\r\n        return [a + (z - u_exact(t))**5]\r\n\r\n\r\n    def test_ODEschemes():\r\n        """Use knowledge of an exact numerical solution for testing."""\r\n        from numpy import linspace, size\r\n\r\n        tol = 1E-15\r\n        T = 2.0  # end of simulation\r\n        N = 20  # no of time steps\r\n        time = linspace(0, T, N+1)\r\n\r\n\r\n        z0 = np.zeros(1)\r\n        z0[0] = u_exact(0.0)\r\n\r\n        scheme_list  = [euler, euler2, euler3, euler4, heun, heun2, rk4]\r\n\r\n        for scheme in scheme_list:\r\n            z = scheme(f, z0, time)\r\n            max_error = np.max(u_exact(time) - z[:,0])\r\n            msg = \'%s failed with error = %g\' % (scheme.func_name, max_error)\r\n            assert max_error < tol, msg\r\n\r\n    # f3 defines an ODE with ananlytical solution in u_nonlin_analytical\r\n    def f3(z, t,a=2.0,b=-1.0):\r\n        """ """\r\n        return a*z + b\r\n\r\n    def u_nonlin_analytical(u0, t, a=2.0, b=-1.0):\r\n        from numpy import exp\r\n        TOL = 1E-14\r\n        if (abs(a)>TOL):\r\n            return (u0 + b/a)*exp(a*t)-b/a\r\n        else:\r\n            return u0 + b*t\r\n            \r\n \r\n        \r\n    # Function for convergence test\r\n    def test_convergence():\r\n        """ Test convergence rate of the methods """\r\n        from numpy import linspace, size, abs, log10, mean\r\n        figure()\r\n        tol = 1E-15\r\n        T = 8.0   # end of simulation\r\n        Ndts = 5 # Number of times to refine timestep in convergence test\r\n\r\n        z0 = 2\r\n\r\n#        scheme_list  = [euler, euler2, euler3, euler4, heun, heun2, rk4]\r\n        scheme_list =[euler, heun, rk4]\r\n        legends=[]\r\n        all_errors={}\r\n        \r\n        colors = [\'r\', \'g\', \'b\', \'m\', \'k\', \'y\', \'c\']\r\n        linestyles = [\'-\', \'--\', \'-.\', \':\', \'v--\', \'*-.\']\r\n        iclr = 0\r\n        for scheme in scheme_list:\r\n            N = 30    # no of time steps\r\n            time = linspace(0, T, N+1)\r\n\r\n            error_diff = []\r\n            \r\n            for i in range(Ndts+1):\r\n                z = scheme(f3, z0, time)   \r\n                abs_error = abs(u_nonlin_analytical(z0, time)-z[:,0])\r\n                log_error = log10(abs_error[1:]) # Drop first element as it is always zero to avoid log10-problems\r\n                max_log_err = max(log_error)\r\n                plot(time[1:], log_error, linestyles[i]+colors[iclr], markevery=N/5)\r\n                legends.append(scheme.func_name +\': N = \' + str(N))\r\n                hold(\'on\')\r\n                \r\n                if i > 0: # Compute the log10 error difference\r\n                    error_diff.append(previous_max_log_err - max_log_err) \r\n                previous_max_log_err = max_log_err\r\n                \r\n                \r\n                N *=2\r\n                time = linspace(0, T, N+1)\r\n            \r\n            all_errors[scheme.func_name] = error_diff\r\n#             print error_diff\r\n#             print mean(error_diff), 10**(mean(error_diff)), error_diff\r\n#             print 10**np.asarray(error_diff)\r\n            iclr += 1\r\n\r\n        legend(legends, loc=\'best\')\r\n        xlabel(\'Time\')\r\n        ylabel(\'log(error)\')\r\n        grid()\r\n        \r\n        N = N/2**Ndts\r\n        N_list = [N*2**i for i in range(1, Ndts+1)]\r\n        N_list = np.asarray(N_list)\r\n#         print N_list         \r\n        \r\n        figure()\r\n        for key in all_errors:\r\n            plot(N_list, 10**(np.asarray(all_errors[key])))\r\n        \r\n        # Plot theoretical error reductions for first, second and fourth order schemes\r\n        axhline(2.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        axhline(4.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        axhline(16.0, xmin=0, xmax=N, linestyle=\':\', color=\'k\')\r\n        xticks(N_list)\r\n        legends = all_errors.keys()\r\n        legends.append(\'theoretical\') \r\n        legend(legends, loc=\'best\', frameon=False)\r\n        xlabel(\'Number of unknowns\')\r\n        ylabel(\'Error reduction when reducing timestep by two\')\r\n        axis([0, max(N_list), 0, 17])\r\n        savefig(\'ConvergenceODEschemes.png\', transparent=True)\r\n        \r\n    def plot_ODEschemes_solutions():\r\n        """Plot the solutions for the test schemes in scheme_list"""\r\n        from numpy import linspace\r\n        figure()\r\n        T = 1.5  # end of simulation\r\n        N = 50  # no of time steps\r\n        time = linspace(0, T, N+1)\r\n\r\n        z0 = 2.0\r\n        #scheme_list  = [euler,euler2, euler3, euler4,heun, heun2, rk4]\r\n        scheme_list  = [euler, heun, rk4]\r\n        legends = []\r\n\r\n\r\n        for scheme in scheme_list:\r\n            z = scheme(f3, z0, time)\r\n            plot(time, z[:,-1])\r\n            legends.append(scheme.func_name)\r\n\r\n        plot(time, u_nonlin_analytical(z0, time))\r\n        legends.append(\'analytical\')\r\n\r\n\r\n        legend(legends, loc=\'best\', frameon=False)\r\n\r\n\r\n    test_ODEschemes()\r\n    test_convergence()\r\n    plot_ODEschemes_solutions()\r\n#     print rcParams.keys()\r\n    show()\n\n!ec\n\n!ebox\n\nBIBFILE: references/papers.pub',
  'title': u'Numerical error as  a function of $\\Delta t$ for ODE-schemes',
  'type': u'Example',
  'type_visible': True}]