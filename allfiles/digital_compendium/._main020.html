<!DOCTYPE HTML>
<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Numerical Methods for Engineers">

<title>Numerical Methods for Engineers</title>

<!-- Bootstrap style: bootstrap_bluegray -->
<link href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_bootstrap/css/bootstrap_bluegray.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u' Scientific computing with Python ', 1, None, '___sec0'),
              (u' Chapter 1: Initial value problems for Ordinary Differential Equations ',
               0,
               None,
               '___sec1'),
              (u' Introduction ',
               1,
               u'section:introduction',
               u'section:introduction'),
              (u" Taylor's method ", 1, u'sec:taylor', u'sec:taylor'),
              (u' Reduction of Higher order Equations ',
               1,
               u'subsec:reduction',
               u'subsec:reduction'),
              (u' Example 1: Reduction of higher order systems ',
               2,
               None,
               '___sec5'),
              (u' Example 2: Sphere in free fall ',
               2,
               u'example:sphere_freefall',
               u'example:sphere_freefall'),
              (u' Python implementation of the drag coefficient function and how to plot it ',
               3,
               None,
               '___sec7'),
              (u' Python functions with vector arguments and modules ',
               1,
               None,
               '___sec8'),
              (u' How to make a Python-module and some useful programming features ',
               1,
               u'section:Python_module',
               u'section:Python_module'),
              (u' Differences ', 1, None, '___sec10'),
              (u' Treatment of the term $\\frac{d}{dx} \\left[ p(x) \\frac{d}{dx} u(x)\\right]$ ',
               3,
               None,
               '___sec11'),
              (u" Euler's method ",
               1,
               u'ex:euler_method',
               u'ex:euler_method'),
              (u' Example 3: Falling sphere with constant and varying drag ',
               2,
               u'ex:falling_sphere',
               u'ex:falling_sphere'),
              (u' Example 4: Numerical error as a function of $\\Delta t$ ',
               2,
               u'ex:num_error',
               u'ex:num_error'),
              (u" Euler's method for a system ", 3, None, '___sec15'),
              (u" Heun's method ", 1, None, '___sec16'),
              (u" Example 5: Newton's equation ", 2, None, '___sec17'),
              (u" Example 6: Falling sphere with Heun's method ",
               2,
               None,
               '___sec18'),
              (u' Runge-Kutta of 4th order ', 1, None, '___sec19'),
              (u' Example 7: Falling sphere using RK4 ',
               2,
               u'example:falling_sphere_RK4',
               u'example:falling_sphere_RK4'),
              (u' Example 8: Particle motion in two dimensions ',
               2,
               None,
               '___sec21'),
              (u' Example 9: Numerical error as  a function of $\\Delta t$ for ODE-schemes ',
               2,
               None,
               '___sec22')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="main.html">Numerical Methods for Engineers</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._main001.html#___sec0" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Scientific computing with Python</a></li>
     <!-- navigation toc: --> <li><a href="._main002.html#___sec1" style="font-size: 80%;"><b>Chapter 1: Initial value problems for Ordinary Differential Equations</b></a></li>
     <!-- navigation toc: --> <li><a href="._main002.html#section:introduction" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Introduction</a></li>
     <!-- navigation toc: --> <li><a href="._main003.html#sec:taylor" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Taylor's method</a></li>
     <!-- navigation toc: --> <li><a href="._main004.html#subsec:reduction" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Reduction of Higher order Equations</a></li>
     <!-- navigation toc: --> <li><a href="._main007.html#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Python functions with vector arguments and modules</a></li>
     <!-- navigation toc: --> <li><a href="._main007.html#section:Python_module" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;How to make a Python-module and some useful programming features</a></li>
     <!-- navigation toc: --> <li><a href="._main008.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Differences</a></li>
     <!-- navigation toc: --> <li><a href="._main010.html#ex:euler_method" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Euler's method</a></li>
     <!-- navigation toc: --> <li><a href="._main014.html#___sec16" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Heun's method</a></li>
     <!-- navigation toc: --> <li><a href="._main017.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Runge-Kutta of 4th order</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0020"></a>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._main019.html">&laquo;</a></li>
  <li><a href="._main000.html">1</a></li>
  <li><a href="">...</a></li>
  <li><a href="._main012.html">13</a></li>
  <li><a href="._main013.html">14</a></li>
  <li><a href="._main014.html">15</a></li>
  <li><a href="._main015.html">16</a></li>
  <li><a href="._main016.html">17</a></li>
  <li><a href="._main017.html">18</a></li>
  <li><a href="._main018.html">19</a></li>
  <li><a href="._main019.html">20</a></li>
  <li class="active"><a href="._main020.html">21</a></li>
</ul>
<!-- !split -->

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec22">Example 9: Numerical error as  a function of \( \Delta t \) for ODE-schemes </h2>

<p>
To investigate whether the various ODE-schemes in our module 'ODEschemes.py' 
have the expected, theoretical order, we proceed in the same manner as
outlined in <a href="._main012.html#ex:num_error">Example 4: Numerical error as a function of \( \Delta t \)</a>. The complete code is listed at the end
of this section but we will highlight and explain some details in the
following. 

<p>
To test the numerical order for the schemes we solve a somewhat general linear ODE:
$$
\begin{align}
 \tag{73}
 u'(t)&= a \, u + b \\ 
 u(t_0)&= u_0 \nonumber
\end{align}
$$

which has the analytical solutions:
$$
\begin{equation}
u =\begin{cases}
 \left (u_0 + \frac{b}{a} \right )   \; e^{a\, t} -\frac{b}{a},& \quad a \neq 0 \\ 
 u_0 + b\, t, &\quad a = 0 
\end{cases}
\end{equation}
$$


<p>
The right hand side defining the differential equation has been
implemented in function <code>f3</code> and the corresponding
analytical solution is computed by <code>u_nonlin_analytical</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f3</span>(z, t,a<span style="color: #666666">=2.0</span>,b<span style="color: #666666">=-1.0</span>):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> a<span style="color: #666666">*</span>z <span style="color: #666666">+</span> b

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u_nonlin_analytical</span>(u0, t, a<span style="color: #666666">=2.0</span>, b<span style="color: #666666">=-1.0</span>):
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> exp
        TOL <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
        <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">abs</span>(a)<span style="color: #666666">&gt;</span>TOL):
            <span style="color: #008000; font-weight: bold">return</span> (u0 <span style="color: #666666">+</span> b<span style="color: #666666">/</span>a)<span style="color: #666666">*</span>exp(a<span style="color: #666666">*</span>t)<span style="color: #666666">-</span>b<span style="color: #666666">/</span>a
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">return</span> u0 <span style="color: #666666">+</span> b<span style="color: #666666">*</span>t
</pre></div>
<p>
<hr>
The basic idea for the convergence test in  the function <code>test_convergence</code> is that we start out by
solving numerically an ODE with an analytical solution on a relatively
coarse grid, allowing for direct computations of the error. We then
reduce the timestep by a factor two (or double the grid size),
repeatedly, and compute the error for each grid and compare it with
the error of previous grid.

<p>
The Euler scheme <a href="._main010.html#mjx-eqn-41">(41)</a> is \( O(h) \), whereas the Heun scheme
<a href="._main014.html#mjx-eqn-56">(56)</a> is \( O(h^2) \), and Runge-Kutta <a href="._main017.html#mjx-eqn-62">(62)</a> is
\( O(h^4) \), where the \( h \) denote a generic step size which for the
current example is the timestep \( \Delta t \). The order of a particular
scheme is given exponent \( n \) in the error term \( O(h^n) \). Consequently, the Euler scheme is a first oder scheme, Heun is second order, whereas Runge-Kutta is fourth order. 

<p>
By letting \( \epsilon_{i+1} \) and \( \epsilon_i \) denote the errors on to consecutive grids with corresponding timesteps \( \displaystyle \Delta t_{i+1} = \frac{\Delta t_i}{2} \). The errors \( \epsilon_{i+1} \) and \( \epsilon_{i} \) for a scheme of order \( n \) are then related by:
$$
\begin{equation}
\tag{74}
\epsilon_{i+1} = \frac{1}{2^n} \epsilon_{i}
\end{equation}
$$

Consequently, whenever  \( \epsilon_{i+1} \) and \( \epsilon_{i} \) are known from consecutive simulations and estimate of the order of the scheme may be obtained by:
$$
\begin{equation}
\tag{75}
 n \approx \log_2 \frac{\epsilon_{i}}{\epsilon_{i+1}}
\end{equation}
$$


<p>
In the function <code>test_convergence</code> the schemes we will subject to a
convergence test in a list <code>scheme_list</code>. This allows for a convenient
loop over all schemes with the clause: <code>for scheme in
scheme_list:</code>. Subsequently, for each scheme we refine the initial
grid (<code>N=30</code>) <code>Ndts</code> times in the loop <code>for i in range(Ndts+1)</code> and
solve and compute the order estimate given by <a href="#mjx-eqn-75">(75)</a> with
the clause <code>order_approx.append(previous_max_log_err -
max_log_err)</code>. Note that we can not compute this for the first
iteration (<code>i=0</code>), and that we use a an initial empty list
<code>order_approx</code> to store the approximation of the order <code>n</code> for each
grid refinement. For each grid and for each grid we plot the
\( \log_2(\epsilon) \) as a function of time with: <code>plot(time[1:],
log_error, linestyles[i]+colors[iclr], markevery=N/5)</code> and for each
plot we construct the corresponding legend by appending a new element
to the legends-list <code>legends.append(scheme.func_name +': N = ' + str(N))</code>.   This construct produces a string with both the scheme name and the number of elements \( N \). The plot is not reproduced below, but you may see the result by downloading and running the module yourself. 

<p>
Having completed the given number of refinements <code>Ndts</code> for a specific scheme
we store the <code>order_approx</code> for the scheme in a dictionary using the
name of the scheme as a key by <code>all_scheme_orders[scheme.func_name] =
order_approx</code>. This allows for an illustrative plot of the order estimate for each scheme with the clause:
<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">for key in all_scheme_orders:
            plot(N_list, (np.asarray(all_scheme_orders[key])))
</pre></div>
<p>
and the resulting plot is shown in Figure <a href="#fig:convergence_rate">13</a>, and we see that our numerical approximations for the orders of our schemes approach the theoretical values as the number of timesteps increase (or as the timestep is reduced by a factor two consecutively).  

<p>
<center> <!-- figure -->
<center><p class="caption">Figure 13:  The convergence rate for the various ODE-solvers a function of the number of timesteps. <div id="fig:convergence_rate"></div> </p></center>
<p><img src="chapter1/programs_and_modules/ConvergenceODEschemes.png" align="bottom" width=700></p>
</center>

<p>
The complete function <code>test_convergence</code> is a part of the module <code>ODEschemes</code> and is isolated below:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_convergence</span>():
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Test convergence rate of the methods &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, size, <span style="color: #008000">abs</span>, log10, mean, log2
        figure()
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
        T <span style="color: #666666">=</span> <span style="color: #666666">8.0</span>   <span style="color: #408080; font-style: italic"># end of simulation</span>
        Ndts <span style="color: #666666">=</span> <span style="color: #666666">5</span> <span style="color: #408080; font-style: italic"># Number of times to refine timestep in convergence test</span>

        z0 <span style="color: #666666">=</span> <span style="color: #666666">2</span>

<span style="color: #408080; font-style: italic">#        scheme_list  = [euler, euler2, euler3, euler4, heun, heun2, rk4]</span>
        scheme_list <span style="color: #666666">=</span>[euler, heun, rk4]
        legends<span style="color: #666666">=</span>[]
        all_scheme_orders<span style="color: #666666">=</span>{}
        
        colors <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;r&#39;</span>, <span style="color: #BA2121">&#39;g&#39;</span>, <span style="color: #BA2121">&#39;b&#39;</span>, <span style="color: #BA2121">&#39;m&#39;</span>, <span style="color: #BA2121">&#39;k&#39;</span>, <span style="color: #BA2121">&#39;y&#39;</span>, <span style="color: #BA2121">&#39;c&#39;</span>]
        linestyles <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;-&#39;</span>, <span style="color: #BA2121">&#39;--&#39;</span>, <span style="color: #BA2121">&#39;-.&#39;</span>, <span style="color: #BA2121">&#39;:&#39;</span>, <span style="color: #BA2121">&#39;v--&#39;</span>, <span style="color: #BA2121">&#39;*-.&#39;</span>]
        iclr <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">for</span> scheme <span style="color: #AA22FF; font-weight: bold">in</span> scheme_list:
            N <span style="color: #666666">=</span> <span style="color: #666666">30</span>    <span style="color: #408080; font-style: italic"># no of time steps</span>
            time <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)

            order_approx <span style="color: #666666">=</span> []
            
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ndts<span style="color: #666666">+1</span>):
                z <span style="color: #666666">=</span> scheme(f3, z0, time)   
                abs_error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_nonlin_analytical(z0, time)<span style="color: #666666">-</span>z[:,<span style="color: #666666">0</span>])
                log_error <span style="color: #666666">=</span> log2(abs_error[<span style="color: #666666">1</span>:]) <span style="color: #408080; font-style: italic"># Drop 1st elt to avoid log2-problems (1st elt is zero)</span>
                max_log_err <span style="color: #666666">=</span> <span style="color: #008000">max</span>(log_error)
                plot(time[<span style="color: #666666">1</span>:], log_error, linestyles[i]<span style="color: #666666">+</span>colors[iclr], markevery<span style="color: #666666">=</span>N<span style="color: #666666">/5</span>)
                legends<span style="color: #666666">.</span>append(scheme<span style="color: #666666">.</span>func_name <span style="color: #666666">+</span><span style="color: #BA2121">&#39;: N = &#39;</span> <span style="color: #666666">+</span> <span style="color: #008000">str</span>(N))
                hold(<span style="color: #BA2121">&#39;on&#39;</span>)
                
                <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>: <span style="color: #408080; font-style: italic"># Compute the log2 error difference</span>
                    order_approx<span style="color: #666666">.</span>append(previous_max_log_err <span style="color: #666666">-</span> max_log_err) 
                previous_max_log_err <span style="color: #666666">=</span> max_log_err

                N <span style="color: #666666">*=2</span>
                time <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)
            
            all_scheme_orders[scheme<span style="color: #666666">.</span>func_name] <span style="color: #666666">=</span> order_approx
            iclr <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>)
        xlabel(<span style="color: #BA2121">&#39;Time&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;log(error)&#39;</span>)
        grid()
        
        N <span style="color: #666666">=</span> N<span style="color: #666666">/2**</span>Ndts
        N_list <span style="color: #666666">=</span> [N<span style="color: #666666">*2**</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Ndts<span style="color: #666666">+1</span>)]
        N_list <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(N_list)
        
        figure()
        <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> all_scheme_orders:
            plot(N_list, (np<span style="color: #666666">.</span>asarray(all_scheme_orders[key])))
        
        <span style="color: #408080; font-style: italic"># Plot theoretical n for 1st, 2nd and 4th order schemes</span>
        axhline(<span style="color: #666666">1.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        axhline(<span style="color: #666666">2.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        axhline(<span style="color: #666666">4.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        xticks(N_list)
        legends <span style="color: #666666">=</span> all_scheme_orders<span style="color: #666666">.</span>keys()
        legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;theoretical&#39;</span>) 
        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        xlabel(<span style="color: #BA2121">&#39;Number of unknowns&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;Scheme order approximation&#39;</span>)
        axis([<span style="color: #666666">0</span>, <span style="color: #008000">max</span>(N_list), <span style="color: #666666">0</span>, <span style="color: #666666">5</span>])
        savefig(<span style="color: #BA2121">&#39;ConvergenceODEschemes.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
</pre></div>
<p>
The complete module <code>ODEschemes</code> is listed below and may easily be downloaded in your Eclipse/LiClipse IDE:
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter1/programs_and_modules/ODEschemes.py</span>

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> plot, show, legend, hold,rcParams,rc, figure, axhline, close,\
    xticks, xlabel, ylabel, savefig, axis, grid

<span style="color: #408080; font-style: italic"># change some default values to make plots more readable </span>
LNWDT<span style="color: #666666">=3</span>; FNT<span style="color: #666666">=11</span>
rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}; rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)


<span style="color: #408080; font-style: italic"># define Euler solver</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">euler</span>(func, z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Euler scheme for solution of systems of ODEs.</span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions,</span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns</span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>

    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time), np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0

    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(time)<span style="color: #666666">-1</span>):
        dt <span style="color: #666666">=</span> time[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> time[i]
        z[i<span style="color: #666666">+1</span>,:]<span style="color: #666666">=</span>z[i,:] <span style="color: #666666">+</span> np<span style="color: #666666">.</span>asarray(func(z[i,:], time[i]))<span style="color: #666666">*</span>dt

    <span style="color: #008000; font-weight: bold">return</span> z

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">euler2</span>(func, z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Euler scheme for solution of systems of ODEs.</span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions,</span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns</span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f_np</span>(z,t):
        <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>asarray(func(z, t))

    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time), np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]):
        dt <span style="color: #666666">=</span> time[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> t
        z[i<span style="color: #666666">+1</span>,:]<span style="color: #666666">=</span>z[i,:] <span style="color: #666666">+</span> f_np(z[i,:],t)<span style="color: #666666">*</span>dt

    <span style="color: #008000; font-weight: bold">return</span> z

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">euler3</span>(func, z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Euler scheme for solution of systems of ODEs.</span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions,</span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns</span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>

    time_local <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(time)
    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time_local), np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> <span style="color: #008000">float</span>(z0)

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time_local[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]):
        dt <span style="color: #666666">=</span> time_local[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> t
        z[i<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> np<span style="color: #666666">.</span>asarray(func(z[i,:], t))<span style="color: #666666">*</span>dt

    <span style="color: #008000; font-weight: bold">return</span> z

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">euler4</span>(func, z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Euler scheme for solution of systems of ODEs.</span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions,</span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns</span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>

    time_local <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(time)
    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time_local), np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> <span style="color: #008000">float</span>(z0)

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time_local[<span style="color: #666666">1</span>:]):
        dt <span style="color: #666666">=</span> t <span style="color: #666666">-</span> time_local[i]
        z[i<span style="color: #666666">+1</span>,:]<span style="color: #666666">=</span>z[i,:] <span style="color: #666666">+</span> np<span style="color: #666666">.</span>asarray(func(z[i,:], time_local[i]))<span style="color: #666666">*</span>dt

    <span style="color: #008000; font-weight: bold">return</span> z

<span style="color: #408080; font-style: italic"># define Heun solver</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">heun</span>(func, z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Heun scheme for solution of systems of ODEs.</span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions,</span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns</span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f_np</span>(z,t):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;A local function to ensure that the return of func is an np array</span>
<span style="color: #BA2121; font-style: italic">        and to avoid lengthy code for implementation of the Heun algorithm&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>asarray(func(z,t))

    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time), np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0
    zp <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z0)

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]):
        dt <span style="color: #666666">=</span> time[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> time[i]
        zp <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> f_np(z[i,:],t)<span style="color: #666666">*</span>dt   <span style="color: #408080; font-style: italic"># Predictor step</span>
        z[i<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> (f_np(z[i,:],t) <span style="color: #666666">+</span> f_np(zp,t<span style="color: #666666">+</span>dt))<span style="color: #666666">*</span>dt<span style="color: #666666">/2.0</span> <span style="color: #408080; font-style: italic"># Corrector step</span>

    <span style="color: #008000; font-weight: bold">return</span> z

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">heun2</span>(func, z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Heun scheme for solution of systems of ODEs.</span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions,</span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns</span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>

    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time), np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0
    zp <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z0)

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]):
        dt <span style="color: #666666">=</span> time[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> time[i]
        zp <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> np<span style="color: #666666">.</span>asarray(func(z[i,:],t))<span style="color: #666666">*</span>dt   <span style="color: #408080; font-style: italic"># Predictor step</span>
        z[i<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> (np<span style="color: #666666">.</span>asarray(func(z[i,:],t)) <span style="color: #666666">+</span> np<span style="color: #666666">.</span>asarray(func(zp,t<span style="color: #666666">+</span>dt)))<span style="color: #666666">*</span>dt<span style="color: #666666">/2.0</span> <span style="color: #408080; font-style: italic"># Corrector step</span>

    <span style="color: #008000; font-weight: bold">return</span> z

<span style="color: #408080; font-style: italic"># define rk4 scheme</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">rk4</span>(func, z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Runge-Kutta 4 scheme for solution of systems of ODEs.</span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions,</span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns</span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>

    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time),np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0
    zp <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z0)

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]):
        dt <span style="color: #666666">=</span> time[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> time[i]
        dt2 <span style="color: #666666">=</span> dt<span style="color: #666666">/2.0</span>
        k1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(func(z[i,:], t))                <span style="color: #408080; font-style: italic"># predictor step 1</span>
        k2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(func(z[i,:] <span style="color: #666666">+</span> k1<span style="color: #666666">*</span>dt2, t <span style="color: #666666">+</span> dt2)) <span style="color: #408080; font-style: italic"># predictor step 2</span>
        k3 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(func(z[i,:] <span style="color: #666666">+</span> k2<span style="color: #666666">*</span>dt2, t <span style="color: #666666">+</span> dt2)) <span style="color: #408080; font-style: italic"># predictor step 3</span>
        k4 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(func(z[i,:] <span style="color: #666666">+</span> k3<span style="color: #666666">*</span>dt, t <span style="color: #666666">+</span> dt))   <span style="color: #408080; font-style: italic"># predictor step 4</span>
        z[i<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> dt<span style="color: #666666">/6.0*</span>(k1 <span style="color: #666666">+</span> <span style="color: #666666">2.0*</span>k2 <span style="color: #666666">+</span> <span style="color: #666666">2.0*</span>k3 <span style="color: #666666">+</span> k4) <span style="color: #408080; font-style: italic"># Corrector step</span>

    <span style="color: #008000; font-weight: bold">return</span> z


<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    a <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
    b <span style="color: #666666">=</span> <span style="color: #666666">3.0</span>
    u_exact <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: a<span style="color: #666666">*</span>t   <span style="color: #666666">+</span>  b

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f_local</span>(u,t):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;A function which returns an np.array but less easy to read</span>
<span style="color: #BA2121; font-style: italic">        than f(z,t) below. &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>asarray([a <span style="color: #666666">+</span> (u <span style="color: #666666">-</span> u_exact(t))<span style="color: #666666">**5</span>])

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Simple to read function implementation &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> [a <span style="color: #666666">+</span> (z <span style="color: #666666">-</span> u_exact(t))<span style="color: #666666">**5</span>]


    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_ODEschemes</span>():
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Use knowledge of an exact numerical solution for testing.&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, size

        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
        T <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>  <span style="color: #408080; font-style: italic"># end of simulation</span>
        N <span style="color: #666666">=</span> <span style="color: #666666">20</span>  <span style="color: #408080; font-style: italic"># no of time steps</span>
        time <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)


        z0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #666666">1</span>)
        z0[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u_exact(<span style="color: #666666">0.0</span>)

        scheme_list  <span style="color: #666666">=</span> [euler, euler2, euler3, euler4, heun, heun2, rk4]

        <span style="color: #008000; font-weight: bold">for</span> scheme <span style="color: #AA22FF; font-weight: bold">in</span> scheme_list:
            z <span style="color: #666666">=</span> scheme(f, z0, time)
            max_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>max(u_exact(time) <span style="color: #666666">-</span> z[:,<span style="color: #666666">0</span>])
            msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> failed with error = </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (scheme<span style="color: #666666">.</span>func_name, max_error)
            <span style="color: #008000; font-weight: bold">assert</span> max_error <span style="color: #666666">&lt;</span> tol, msg

    <span style="color: #408080; font-style: italic"># f3 defines an ODE with ananlytical solution in u_nonlin_analytical</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f3</span>(z, t,a<span style="color: #666666">=2.0</span>,b<span style="color: #666666">=-1.0</span>):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> a<span style="color: #666666">*</span>z <span style="color: #666666">+</span> b

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u_nonlin_analytical</span>(u0, t, a<span style="color: #666666">=2.0</span>, b<span style="color: #666666">=-1.0</span>):
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> exp
        TOL <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
        <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">abs</span>(a)<span style="color: #666666">&gt;</span>TOL):
            <span style="color: #008000; font-weight: bold">return</span> (u0 <span style="color: #666666">+</span> b<span style="color: #666666">/</span>a)<span style="color: #666666">*</span>exp(a<span style="color: #666666">*</span>t)<span style="color: #666666">-</span>b<span style="color: #666666">/</span>a
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">return</span> u0 <span style="color: #666666">+</span> b<span style="color: #666666">*</span>t
            
 
        
    <span style="color: #408080; font-style: italic"># Function for convergence test</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_convergence</span>():
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Test convergence rate of the methods &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, size, <span style="color: #008000">abs</span>, log10, mean, log2
        figure()
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
        T <span style="color: #666666">=</span> <span style="color: #666666">8.0</span>   <span style="color: #408080; font-style: italic"># end of simulation</span>
        Ndts <span style="color: #666666">=</span> <span style="color: #666666">5</span> <span style="color: #408080; font-style: italic"># Number of times to refine timestep in convergence test</span>

        z0 <span style="color: #666666">=</span> <span style="color: #666666">2</span>

<span style="color: #408080; font-style: italic">#        scheme_list  = [euler, euler2, euler3, euler4, heun, heun2, rk4]</span>
        scheme_list <span style="color: #666666">=</span>[euler, heun, rk4]
        legends<span style="color: #666666">=</span>[]
        all_scheme_orders<span style="color: #666666">=</span>{}
        
        colors <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;r&#39;</span>, <span style="color: #BA2121">&#39;g&#39;</span>, <span style="color: #BA2121">&#39;b&#39;</span>, <span style="color: #BA2121">&#39;m&#39;</span>, <span style="color: #BA2121">&#39;k&#39;</span>, <span style="color: #BA2121">&#39;y&#39;</span>, <span style="color: #BA2121">&#39;c&#39;</span>]
        linestyles <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;-&#39;</span>, <span style="color: #BA2121">&#39;--&#39;</span>, <span style="color: #BA2121">&#39;-.&#39;</span>, <span style="color: #BA2121">&#39;:&#39;</span>, <span style="color: #BA2121">&#39;v--&#39;</span>, <span style="color: #BA2121">&#39;*-.&#39;</span>]
        iclr <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">for</span> scheme <span style="color: #AA22FF; font-weight: bold">in</span> scheme_list:
            N <span style="color: #666666">=</span> <span style="color: #666666">30</span>    <span style="color: #408080; font-style: italic"># no of time steps</span>
            time <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)

            order_approx <span style="color: #666666">=</span> []
            
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ndts<span style="color: #666666">+1</span>):
                z <span style="color: #666666">=</span> scheme(f3, z0, time)   
                abs_error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_nonlin_analytical(z0, time)<span style="color: #666666">-</span>z[:,<span style="color: #666666">0</span>])
                log_error <span style="color: #666666">=</span> log2(abs_error[<span style="color: #666666">1</span>:]) <span style="color: #408080; font-style: italic"># Drop 1st elt to avoid log2-problems (1st elt is zero)</span>
                max_log_err <span style="color: #666666">=</span> <span style="color: #008000">max</span>(log_error)
                plot(time[<span style="color: #666666">1</span>:], log_error, linestyles[i]<span style="color: #666666">+</span>colors[iclr], markevery<span style="color: #666666">=</span>N<span style="color: #666666">/5</span>)
                legends<span style="color: #666666">.</span>append(scheme<span style="color: #666666">.</span>func_name <span style="color: #666666">+</span><span style="color: #BA2121">&#39;: N = &#39;</span> <span style="color: #666666">+</span> <span style="color: #008000">str</span>(N))
                hold(<span style="color: #BA2121">&#39;on&#39;</span>)
                
                <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>: <span style="color: #408080; font-style: italic"># Compute the log2 error difference</span>
                    order_approx<span style="color: #666666">.</span>append(previous_max_log_err <span style="color: #666666">-</span> max_log_err) 
                previous_max_log_err <span style="color: #666666">=</span> max_log_err

                N <span style="color: #666666">*=2</span>
                time <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)
            
            all_scheme_orders[scheme<span style="color: #666666">.</span>func_name] <span style="color: #666666">=</span> order_approx
            iclr <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>)
        xlabel(<span style="color: #BA2121">&#39;Time&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;log(error)&#39;</span>)
        grid()
        
        N <span style="color: #666666">=</span> N<span style="color: #666666">/2**</span>Ndts
        N_list <span style="color: #666666">=</span> [N<span style="color: #666666">*2**</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Ndts<span style="color: #666666">+1</span>)]
        N_list <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(N_list)
        
        figure()
        <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> all_scheme_orders:
            plot(N_list, (np<span style="color: #666666">.</span>asarray(all_scheme_orders[key])))
        
        <span style="color: #408080; font-style: italic"># Plot theoretical n for 1st, 2nd and 4th order schemes</span>
        axhline(<span style="color: #666666">1.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        axhline(<span style="color: #666666">2.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        axhline(<span style="color: #666666">4.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        xticks(N_list)
        legends <span style="color: #666666">=</span> all_scheme_orders<span style="color: #666666">.</span>keys()
        legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;theoretical&#39;</span>) 
        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        xlabel(<span style="color: #BA2121">&#39;Number of unknowns&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;Scheme order approximation&#39;</span>)
        axis([<span style="color: #666666">0</span>, <span style="color: #008000">max</span>(N_list), <span style="color: #666666">0</span>, <span style="color: #666666">5</span>])
        savefig(<span style="color: #BA2121">&#39;ConvergenceODEschemes.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
        
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot_ODEschemes_solutions</span>():
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Plot the solutions for the test schemes in scheme_list&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace
        figure()
        T <span style="color: #666666">=</span> <span style="color: #666666">1.5</span>  <span style="color: #408080; font-style: italic"># end of simulation</span>
        N <span style="color: #666666">=</span> <span style="color: #666666">50</span>  <span style="color: #408080; font-style: italic"># no of time steps</span>
        time <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)

        z0 <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>
        <span style="color: #408080; font-style: italic">#scheme_list  = [euler,euler2, euler3, euler4,heun, heun2, rk4]</span>
        scheme_list  <span style="color: #666666">=</span> [euler, heun, rk4]
        legends <span style="color: #666666">=</span> []


        <span style="color: #008000; font-weight: bold">for</span> scheme <span style="color: #AA22FF; font-weight: bold">in</span> scheme_list:
            z <span style="color: #666666">=</span> scheme(f3, z0, time)
            plot(time, z[:,<span style="color: #666666">-1</span>])
            legends<span style="color: #666666">.</span>append(scheme<span style="color: #666666">.</span>func_name)

        plot(time, u_nonlin_analytical(z0, time))
        legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;analytical&#39;</span>)
        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)


    test_ODEschemes()
    test_convergence()
    plot_ODEschemes_solutions()
    show()
</pre></div>
<p>
</div>
<!-- end box -->


<p>
<!-- begin bibliography -->

<ol>
 <li> <div id="hairer2008solving"></div> <b>E. Hairer, S. P. Norsett and G. Wanner</b>. 
    <em>Solving Ordinary Differential Equations I: Nonstiff Problems</em>,
    Springer Science &amp; Business,
    2008.</li>
 <li> <div id="white1999fluid"></div> <b>F. White</b>. 
    <em>Fluid Mechanics</em>,
    WCB/McGraw-Hill,
    1999,
    <a href="http://books.google.no/books/about/Fluid_mechanics.html?id=fa_pAAAAMAAJ&redir_esc=y" target="_blank"><tt>http://books.google.no/books/about/Fluid_mechanics.html?id=fa_pAAAAMAAJ&redir_esc=y</tt></a>.</li>
 <li> <div id="evett19892"></div> <b>J. Evett and C. Liu</b>. 
    <em>2,500 Solved Problems in Fluid Mechanics and Hydraulics</em>,
    McGraw-Hill Education,
    1989,
    <a href="http://books.google.no/books?id=NBDjWHLKwSQC" target="_blank"><tt>http://books.google.no/books?id=NBDjWHLKwSQC</tt></a>.</li>
 <li> <div id="langtangen14"></div> <b>H. P. Langtangen</b>. 
    <em>A Primer on Scientific Programming With Python</em>,
    Springer,
    2014.</li>
 <li> <div id="python14"></div> <b>S. F. Python</b>. 
    <em>The Python Tutorial</em>,
    Python Software Foundation,
    2014.</li>
 <li> <div id="cheney2012numerical"></div> <b>E. Cheney and D. Kincaid</b>. 
    <em>Numerical Mathematics and Computing</em>,
    Cengage Learning,
    2012.</li>
 <li> <div id="Bearman1976112"></div> <b>P. Bearman and J. Harvey</b>. 
    GOLF BALL AERODYNAMICS.,
    <em>Aeronaut Q</em>,
    27(pt 2),
    pp. 112-122,
    1976,
    <a href="http://www.scopus.com/inward/record.url?eid=2-s2.0-0016949854&partnerID=40&md5=a1d1cc6e8477e33fcd2d5ccf55fc29a8" target="_blank"><tt>http://www.scopus.com/inward/record.url?eid=2-s2.0-0016949854&partnerID=40&md5=a1d1cc6e8477e33fcd2d5ccf55fc29a8</tt></a>.</li>
</ol>

<!-- end bibliography -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
<li><a href="._main019.html">&laquo;</a></li>
  <li><a href="._main000.html">1</a></li>
  <li><a href="">...</a></li>
  <li><a href="._main012.html">13</a></li>
  <li><a href="._main013.html">14</a></li>
  <li><a href="._main014.html">15</a></li>
  <li><a href="._main015.html">16</a></li>
  <li><a href="._main016.html">17</a></li>
  <li><a href="._main017.html">18</a></li>
  <li><a href="._main018.html">19</a></li>
  <li><a href="._main019.html">20</a></li>
  <li class="active"><a href="._main020.html">21</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

