<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Electronic Compendium for TKT4140">

<title>Electronic Compendium for TKT4140</title>

<!-- Bootstrap style: bootstrap_bluegray -->
<link href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<link href="https://raw.github.com/hplgit/doconce/master/bundled/html_styles/style_bootstrap/css/bootstrap_bluegray.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(' Initial value problems for Ordinary Differential Equations ',
               0,
               None,
               '___sec0'),
              (' Introduction ',
               1,
               'section:introduction',
               'section:introduction'),
              (" Taylor's method ", 2, 'sec:taylor', 'sec:taylor'),
              (' Reduction of Higher order Equations ',
               2,
               'subsec:reduction',
               'subsec:reduction'),
              (' Example 1: Reduction of higher order system ',
               2,
               None,
               '___sec4'),
              (' Example 2: Sphere in free fall ',
               2,
               'example:sphere_freefall',
               'example:sphere_freefall'),
              (' Generating the plot in ref{example:sphere_freefall} ',
               3,
               None,
               '___sec6'),
              (' More efficient implementations ', 3, None, '___sec7'),
              (' Differences ', 2, None, '___sec8'),
              (' Treatment of the term $\\frac{d}{dx} \\left[ p(x) \\frac{d}{dx} u(x)\\right]$ ',
               3,
               None,
               '___sec9'),
              (" Euler's method ", 2, None, '___sec10'),
              (' Example 3: Falling sphere with constant and varying drag ',
               2,
               'ex:falling_sphere',
               'ex:falling_sphere'),
              (" Heun's method ", 2, None, '___sec12'),
              (" Example 4: Newton's equation ", 2, None, '___sec13'),
              (" Example 5: Falling sphere with Heun's method ",
               2,
               None,
               '___sec14'),
              (' Runge - Kutta of 4th order ', 2, None, '___sec15')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="main.html">Electronic Compendium for TKT4140</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#___sec0" style="font-size: 80%;"><b>Initial value problems for Ordinary Differential Equations</b></a></li>
     <!-- navigation toc: --> <li><a href="#section:introduction" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Introduction</a></li>
     <!-- navigation toc: --> <li><a href="#sec:taylor" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Taylor's method</a></li>
     <!-- navigation toc: --> <li><a href="#subsec:reduction" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reduction of Higher order Equations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example 1: Reduction of higher order system</a></li>
     <!-- navigation toc: --> <li><a href="#example:sphere_freefall" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example 2: Sphere in free fall</a></li>
     <!-- navigation toc: --> <li><a href="#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generating the plot in ref{example:sphere_freefall}</a></li>
     <!-- navigation toc: --> <li><a href="#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;More efficient implementations</a></li>
     <!-- navigation toc: --> <li><a href="#___sec8" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Differences</a></li>
     <!-- navigation toc: --> <li><a href="#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treatment of the term $\frac{d}{dx} \left[ p(x) \frac{d}{dx} u(x)\right]$</a></li>
     <!-- navigation toc: --> <li><a href="#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Euler's method</a></li>
     <!-- navigation toc: --> <li><a href="#ex:falling_sphere" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example 3: Falling sphere with constant and varying drag</a></li>
     <!-- navigation toc: --> <li><a href="#___sec12" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Heun's method</a></li>
     <!-- navigation toc: --> <li><a href="#___sec13" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example 4: Newton's equation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example 5: Falling sphere with Heun's method</a></li>
     <!-- navigation toc: --> <li><a href="#___sec15" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runge - Kutta of 4th order</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<!-- ------------------- main content ---------------------- -->



<div class="jumbotron">
<center><h1>Electronic Compendium for TKT4140</h1></center>  <!-- document title -->

<p>
<!-- author(s): Johan Kolst&#248; S&#248;nstab&#248;, and Leif Rune Hellevik -->

<center>
<b>Johan Kolst&#248; S&#248;nstab&#248;</b> [1]
</center>

<center>
<b>Leif Rune Hellevik</b> [2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b>Centre for Advanced Structural Analysis (CASA)</b></center>
<center>[2] <b>Department of Structural Engineering, NTNU</b></center>
<p>
<center><h4>Dec 5, 2014</h4></center> <!-- date -->
<!-- TOC: on -->

<p>
<!-- TKT4140 Numerical Methods with Computer Laboratory. -->
<!-- This is the main file -->

<p>


</div> <!-- end jumbotron -->

<h1 class="page-header" id="___sec0">Initial value problems for Ordinary Differential Equations <a name="___sec0"></a></h1>

<h1 id="section:introduction">Introduction<a name="section:introduction"></a></h1>

With an initial value problem for an ordinary differential equation (ODE) we mean a problem where all boundary conditions are given for one and the same value of the independent variable. For a first order ODE we get e.g.
$$
\begin{align}\label{eq:1101}
 y'(x)&=f(x,y) \\ 
y(x_0)&=a  \nonumber
\end{align}
$$

while for a second order ODE we get
$$
\begin{align}\label{eq:1102}
y''(x)&=f(x,y,y') \\ 
y(x_0)&=a,\ y'(x_0) = b \nonumber
\end{align}
$$

A first order ODE, as shown in Equation \eqref{eq:1101}, will always be an <em>initial value problem</em>. For Equation \eqref{eq:1102}, on the other hand, we can for instance specify the boundary conditions as follows,
$$
\begin{align}
y(x_0)=a,\ y(x_1) = b \nonumber
\end{align}
$$

With these boundary conditions Equation \eqref{eq:1102} presents a <em>boundary value problem</em>. In many applications boundary value problems are more common than initial value problems. But the solution technique for initial value problems may often be applied to solve boundary value problems. 

<p>
Both from an analytical and numerical viewpoint initial value problems are easier to solve than boundary value problems, and methods for solution of initial value problems are more developed than for boundary value problems. 

<p>
If we are to solve an initial value problem of the type in Equation \eqref{eq:1101}, we must first be sure that it has a solution. In addition we will demand that this solution is unique. A sufficient solution for this is that both \( f(x,y) \) and \( \frac{\partial f}{\partial y} \) are continuous in and around \( x_0 \). For \eqref{eq:1102} this conditions becomes that \( f(x,y) \), \( \frac{\partial f}{\partial y} \) and \( \frac{\partial f}{\partial y'} \)  are continuous in and around \( x_0 \). Similarly for higher order equations.

<p>
An example:
$$
\begin{equation} 
y' = y^{\frac{1}{3}},\ y(0)=0 \nonumber
\end{equation}
$$

Here \( f=y^\frac{1}{3} \) and \( \frac{\partial f}{\partial y}=\frac{1}{3y^\frac{2}{3}} \). \( f \) is continuous in \( x=0 \), but that's not the case for \( \frac{\partial f}{\partial y} \). It may be shown that this ODE has two solutions: \( y=0 \) and \( y=(\frac{2}{3}x)^\frac{2}{3} \). Hopefully this equation doesn't present a physical problem. A problem of more interest is shown below.

<p>
<center><p><img src="kap1/1.png" align="bottom" width=200></p></center>

<p>
The figure shows a mathematical pendulum where the motion is described by the following equation:
$$
\begin{align}
 \frac{\partial^2 \theta}{\partial \tau^2} + \frac{g}{l}\sin (\theta) = 0 \label{eq:1103a}\\ 
\theta (0) = \theta_0 ,\ \frac{d\theta}{d\tau}(0) = 0 \label{eq:1103b}
\end{align}
$$

We introduce a dimensionless time \( t \) given by \( t=\sqrt{\frac{g}{l}}\cdot\tau \) such that \eqref{eq:1103a} and \eqref{eq:1103b} may be written as 
$$
\begin{align}\label{eq:1104a}
\ddot{\theta}(t) + \sin (\theta (t)) = 0 \\
\theta (0) = \theta_0 ,\ \dot\theta (0) = 0\label{eq:1104b}
\end{align}
$$

The dot symbolyzes derivation with respect to the dimensionless time \( t \). For small displacements we can set \( \sin (\theta) \approx \theta \), such that \eqref{eq:1104a} and \eqref{eq:1104b} becomes 
$$
\begin{align}\label{eq:1105a}
\ddot\theta (t)& + \theta (t) = 0 \\
\theta (0)& = \theta_0 ,\ \dot\theta (0) = 0\label{eq:1105b}
\end{align}
$$


<p>
The difference between \eqref{eq:1104a} and \eqref{eq:1105a} is that the latter is linear, while the first is non-linear. The analytical solution of Equations \eqref{eq:1104a} and \eqref{eq:1104b} is given in Appendix G.2. in the 
<a href="./NumeriskeBeregninger.pdf" target="_blank">compendium</a>. An \( n \)'th order linear ODE may be written on the form
$$
\begin{equation}
\label{eq:1106}
a_n(x)y^{(n)}(x)+a_{n-1}(x)y^{(n-1)}(x)+\cdots+a_1(x)y'(x)+a_0(x)y(x)=b(x)
\end{equation}
$$

where \( y^{(k)}, k=0,1,\dots n \) is referring to the \( k \)'th derivative and \( y^{(0)}(x)=y(x) \).

<p>
If one or more of the coefficients \( a_k \) also are functions of at least one \( y^{(k)},\ k = 0,1,\dots n \), the ODE is non-linear. From \eqref{eq:1106} it follows that \eqref{eq:1104a} is non-linear and \eqref{eq:1105a} is linear. 

<p>
Analytical solutions of non-linear ODEs are rare, og except from some special types, there are no general ways of finding such solutions. Therefore non-linear equations must usually be solved numerically. In many cases this is also the case for linear equations. For instance it doesn't exist a method to solve the general second order linear ODE given by 
$$
\begin{equation}
a_2(x)\cdot y''(x)+a_1(x)\cdot y'(x) +a_0(x)\cdot y(x) =b(x)\nonumber 
\end{equation}
$$


<p>
From a numerical point of view the main difference between linear and non-linear equations is the multitude of solutions that may arise when solving non-linear equations. In a linear ODE it will be evident from the equation if there are special critical points where the solution change character, while this is often not the case for non-linear equations. 

<p>
For instance the equation \( y'(x)=y^2(x),\ y(0)=1 \) has the solution \( y(x)=\frac{1}{1-x} \) such that \( y(x) \to \infty  \) for \( x \to 1 \), which isn't evident from the equation itself.

<h2 id="sec:taylor">Taylor's method<a name="sec:taylor"></a></h2>
Taylor's formula for series expansion of a funciton \( f(x) \) around \( x_0 \) is given by 
$$
\begin{equation}
f(x)=f(x_0)+(x-x_0)\cdot f'(x_0)+\frac{(x-x_0)^2}{2}f''(x_0)+\dots +\frac{(x-x_0)^n}{n !}f^{(n)}(x_0)+ \text{remainder} \nonumber
\end{equation}
$$

Let's use this formula to find the first terms in the series expansion for \( \theta(t) \) around \( t=0 \) from the differential equation given in \eqref{eq:1105a}:
$$
\begin{align*}
&\ddot{\theta} (t) +\theta (t) = 0 \\
&\theta (0) = \theta_0,\  \dot{\theta}(0)=0
\end{align*}
$$

We set \( \theta(t) \approx \theta(0)+t\cdot\dot{\theta}(0)+\frac{t^2}{2}\ddot\theta(0)+\frac{t^3}{6}\dddot\theta(0)+\frac{t^4}{24}\theta^{(4)}(0) \). By use of the initial conditions \( \theta(0)=\theta_0,\ \dot\theta(0)=0 \) we get
$$
\begin{equation}
\theta(t)\approx\theta_0 +\frac{t^2}{2}\ddot\theta+\frac{t^3}{6}\dddot\theta(0)+\frac{t^4}{24}\theta^{(4)}(0)  \nonumber
\end{equation}
$$

From the differential equation we have \( \ddot\theta(t)=-\theta(t)\to \ddot\theta(0)=-\theta(0)=-\theta_0 \)

<p>
By differentiation we get \( \dddot\theta(t)=-\dot\theta(t)\to \ddot\theta(0)=-\theta(0)=-\theta_0 \) 

<p>
We now get
$$
\begin{equation}
\theta^{(4)}(t)=-\ddot\theta(t) \to \theta^{(4)}(0)=-\ddot\theta(0)=\theta_0 \nonumber
\end{equation}
$$

Setting this into the expression for \( \theta(t) \) gives \( \theta(t)\approx \theta_0\left(1-\frac{t^2}{2}+\frac{t^4}{24}\right)=\theta_0\left(1-\frac{t^2}{2!}+\frac{t^4}{4!}\right) \)

<p>
If we include \( n \) terms, we get
$$
\begin{equation}
\theta(t)\approx \theta_0\cdot \left(1-\frac{t^2}{2!}+\frac{t^4}{4!}-\frac{t^6}{6!}+\dots+(-1)^n \frac{t^{2n}}{(2n)!}\right) \nonumber
\end{equation}
$$


<p>
If we let \( n \to \infty \) we see that the parentheses give the series for \( \cos(t) \). In this case we have found the exact solution \( \theta(t)=\theta_0\cos(t) \) of the differential equation. Since this equation is linear we manage in this case to find a connection between the coefficients such that we recognize the series expansion of \( \cos(t) \). 

<p>
Let's try the same procedure on the non-linear version \eqref{eq:1104a}
$$
\begin{align} \nonumber
\ddot{\theta}(t)& + \sin \left(\theta (t)\right) = 0 \\
\theta (0) &= \theta_0 ,\ \dot\theta (0) = 0 \nonumber
\end{align}
$$

We start in the same manner: \( \theta(t) \approx \theta(0)+\frac{t^2}{2}\ddot\theta(0)+\frac{t^3}{6}\dddot\theta(0)+\frac{t^4}{24}\theta^{(4)}(0) \).
From the differential equation we have \( \ddot\theta=-\sin (\theta) \to \ddot\theta(0)=-\sin(\theta_0) \), which by consecutive differentiation gives
$$
\begin{align}
&\dddot\theta=-\cos(\theta)\cdot\dot\theta \to \dddot\theta(0)=0 \nonumber \\ 
&\theta^{(4)}=\sin(\theta)\cdot\dot\theta^2-\cos(\theta)\cdot\ddot\theta \to \theta^{(4)}(0)=-\ddot\theta(0)\cos(\theta(0))=\sin(\theta_0)\cos(\theta_0) \nonumber
\end{align}
$$

Inserted above: \( \theta(t) \approx \theta_0 -\frac{t^2}{2}\sin(\theta_0) + \frac{t^4}{24} \sin (\theta_0) \cos (\theta_0) \).

<p>
We may include more terms, but this complicates the differentiation and it is hard to find any connection between the coefficients. When we have found an approximation for for \( \theta(t) \) we can get an approximation for \( \dot\theta(t) \) by differentiation: \( \dot\theta(t) \approx -t\sin(\theta_0) + \frac{t^3}{8} \sin (\theta_0) \cos (\theta_0) \).

<p>
Series expansions are often useful around the starting point when we solve initial value problems. The technique may also be used on non-linear equations. 

<p>
Symbolic mathematical programs like <b>Maple</b> and <b>Mathematica</b> do this easily.

<p>
We will end with one of the earlies known differential equations, which Newton solved with series expansion in 1671. 
$$
\begin{equation*}
y'(x) =1-3x+y+x^2+xy,\ y(0)=0
\end{equation*}
$$

Series expansion around \( x=0 \) gives
$$
\begin{equation*}
y(x) \approx x\cdot y'(0)+ \frac{x^2}{2} y''(0)+\frac{x^3}{6}y'''(0)+\frac{x^4}{24}y^{(4)}(0)
\end{equation*}
$$

From the differential equation we get \( y'(0)=1 \). By consecutive differentiation we get 
$$
\begin{equation*}
  \begin{array}{lclclcr}
    y''(x) &=&-3+y'+2x+xy'+y &\to& y''(0)&=&-2\\
    y'''(x)&=& y''+2+xy''+2y'  &\to& y'''(0)&=& 2\\
    y^{(4)}(x)&=&y'''+xy'''+3y'' &\to &y^{(4)}(0)&=&-4
  \end{array}
\end{equation*}
$$

Inserting above gives \( y(x) \approx x-x^2+\frac{x^3}{3}-\frac{x^4}{6} \). 

<p>
Newton gave the following solution: \( y(x) \approx  x-x^2+\frac{x^3}{3}-\frac{x^4}{6}+ \frac{x^5}{30}-\frac{x^6}{45} \).

<p>
Now you can check if Newton calculated correctly. Today it is possible to give the solution on closed form with known functions as follows,
$$
\begin{align*}
y(x)=&3\sqrt{2\pi e}\cdot \exp\left[x\left(1+\frac{x}{2}\right)\right]\cdot \left[\text{erf}\left(\frac{\sqrt{2}}{2}(1+x)\right)-\text{erf}\left(\frac{\sqrt{2}}{2}\right)\right]\\ 
+& 4\cdot\left[1-\exp[x\left(1+\frac{x}{2}\right)\right]-x
\end{align*}
$$


<p>
Note the combination \( \sqrt{2\pi e} \). See Hairer et al. <a href="#hairer2008solving">[1]</a> section 1.2 for more details on classical differential equations.

<h2 id="subsec:reduction">Reduction of Higher order Equations<a name="subsec:reduction"></a></h2>

When we are solving initial value problems, we usually need to write these as sets of first order equations, because most of the program packages require this.

<p>
Example: \( y''(x)+y(x)=0,\ y(0)=a_0,\ y'(0)=b_0 \)

<p>
We may for instance write this equation in a system as follows,
$$
\begin{align*}
y'(x)=&g(x)\\
g'(x)=&-y(x)\\
y(0)=&a_0,\  g(0)=b_0
\end{align*}
$$


<p>
Another example:
$$
\begin{align*}
&y'''(x)+2y''(x)-(y'(x))^2+2y(x)=x^2\\
&y(0)=a_0,\ y'(0)=b_0,\ y''(0)=c_0
\end{align*}
$$

We set \( y'(x)=g(x) \) and \( y''(x)=g'(x)=f(x) \), and the system may be written as
$$
\begin{align*}
y'(x)=&g(x)\\
g'(x)=&f(x)\\
f'(x)=&-2f(x)+(g(x))^2-2y(x)+x^2
\end{align*}
$$

with initial values \( y(0)=a_0,\ g(0)=b_0,\ f(0)=c_0 \).

<p>
This is fair enough for hand calculations, men when we use program packages a more systematic procedure is needed. Let's use the equation above as an example. 

<p>
We start by renaming \( y \) to \( y_1 \). We then get the following procedure:
$$
\begin{align*}
y&'=y'_1=y_2\\
y&''=y''_1=y'_2=y_3
\end{align*}
$$

The system may then be written as
$$
\begin{align*}
y'_1(x)=&y_2(x)\\
y'_2(x)=&y_3(x)\\
y'_3(x)=&-2y_3(x)+(y_2(x))^2-2y_1(x)+x^2
\end{align*}
$$

with initial conditions \( y_1(0)=a_0,\ y_2(0)=b_0,\ y_3(0)=c_0 \).

<p>
The general procedure to reduce a higher order ODE to a system of first order ODEs becomes the following:

<p>
Given the equation
$$
\begin{align} \label{eq:1127}
\begin{split}
&y^{(m)}=f(x,y,y',y'',\dots,y^{(m-1)})\\
&y(x_0)=a_1,\ y'(x_0)=a_2,\ \dots,y^{(m-1)}(x_0)=a_m\\
&\text{derwhere } y^{(m)}\equiv \frac{d^my}{dx^m}
\end{split}
\end{align}
$$

with \( y=y_1 \), we set
$$
\begin{align}
&y'_1=y_2 \nonumber \\ \nonumber
&y'_2=y_3\\ \nonumber
&.\\ \label{eq:1128}
&.\\ \nonumber
&y'_{m-1}=y_m\\\nonumber\\\nonumber
&y_1(x_0)=a_1,y_2(x_0)=a_2,\dots,y_m(x_0)=a_m
\end{align}
$$


<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec4">Example 1: Reduction of higher order system <a name="___sec4"></a></h2>

Write the following ODE as a system of first order ODEs:
$$
\begin{align*}
y'''-y'y''-(y')^2+2y=x^3 \\
y(0)=a,\ y'(0)=b,\ y''(0)=c
\end{align*}
$$


<p>
<!-- !bsol -->
First we write \( y'''=y'y''+(y')^2-2y+x^3 \).

<p>
By use of \eqref{eq:1128} we get
$$
\begin{align*}
&y_1'=y_2\\
&y_2'=y_3\\
&y_3'=y_2y_3+(y_2)^2-2y_1+x^3\\
&y_1(0)=a,\ y_2(0)=b,\ y_3=c
\end{align*}
$$

<!-- !esol -->
<!-- !ec -->
</div>
<!-- end box -->


<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="example:sphere_freefall">Example 2: Sphere in free fall<a name="example:sphere_freefall"></a></h2>

<center><p><img src="kap1/eks1_2/2.png" align="bottom" width=200></p></center>

<p>
The figure shows a falling sphere with a diameter \( d \) and mass \( m \) that falls vertically in a fluid. Use of Newton's 2nd law in the \( z \)-direction gives
$$
\begin{equation}\label{eq:newton_2nd_sphere}
m\frac{dv}{dt} = mg-m_fg-\frac{1}{2}m_f\frac{dv}{dt}-\frac{1}{2}\rho_fv\left|v\right|A_kC_D,
\end{equation}
$$

where the different terms are interpreted as follows: \( m=\rho_k V \), where \( \rho_f \) is the density of the sphere and \( V \) is its volume, is the mass of the sphere. \( m_f=\rho_f V \), where \( \rho_f \) is the density of the fluid, is the mass of the displaced fluid. \( m_fg= \) is the buoyancy. \( C_D \) is the drag coefficient. \( A_k \) is the area projection of the sphere \( = \frac{\pi}{4}d^2 \). \( \frac{1}{2}m_f \) is the hydrodynamical mass (added mass). The expression for the hydrodynamical mass is derived in White <a href="#white1999fluid">[2]</a>, page 539-540. 

<p>
We introduce the following abbreviations:
$$
\begin{equation}
\rho=\frac{\rho_f}{\rho_k},\ A=1+\frac{\rho}{2}, \ B=(1-\rho)g,\ C=\frac{3\rho}{4d}.
\end{equation}
$$

Equation \eqref{eq:newton_2nd_sphere} may then be written as 
$$
\begin{equation} \label{eq:sphere_1st_order}
\frac{dv}{dt}=\frac{1}{A}(B-C\cdot v\left|v\right|C_d).
\end{equation}
$$

\( C_D \) is found experimentally as a function of the Reynolds number \( R_e = \frac{vd}{\nu} \), where \( \nu \) is the kinematical viscosity. 

<p>
Figure <a href="#fig:CDsphere">1</a> shows \( C_D \) as a function of \( Re \). The Python programme <b>CDsphere.py</b> produces the plot from a curve fit to the data of Evett and Liu <a href="#evett19892">[3]</a>. The programme uses a function <code>cd_sphere</code> which is shown at the end of this example. The values in the plot are not as accurate as the number of digits in the programme might indicate. For example is the location and the size of the "valley" in the diagram strongly dependent of the degree of turbulence in the free stream and the roughness of the sphere. 

<p>
In air we may often neglect the buoyancy term and the hydrodynamical mass. This should not be done for a liquid.

<p>
Introducing \( v=\frac{dz}{dt} \) in Equation \eqref{eq:sphere_1st_order}, we get a 2nd order ODE as follows
$$
\begin{equation}\label{eq:sphere_second_order}
\frac{d^2z}{dt^2}=\frac{1}{A}\left(B-C\cdot \frac{dz}{dt}\bigg|\frac{dz}{dt}\bigg|C_d\right)
\end{equation}
$$

For Equation \eqref{eq:sphere_second_order} two initial conditions must be specified, e.g. \( v=v_0 \) and \( z=z_0 \) for \( t=0 \). 

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Drag coefficient \( C_D \) as function of the Reynold's number \( R_e \). <a name="fig:CDsphere"></a> </p></center>
<p><img src="kap1/eks1_2/example_sphere.png" align="bottom" height=400 width=600></p>
</center>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere</span>(Re):
    <span style="color: #BA2121">&quot;This function computes the drag coefficient of a sphere as a function of the Reynolds number Re.&quot;</span>
    <span style="color: #408080; font-style: italic"># Curve fitted after fig. A-56 in Evett &amp; Liu: &quot;Fluid Mechanics &amp; Hydraulics&quot;,</span>
    <span style="color: #408080; font-style: italic"># Schaum&#39;s Solved Problems McGraw - Hill 1989.</span>
    
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log10, array, polyval
    
    <span style="color: #008000; font-weight: bold">if</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.0</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">8.0e6</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.0</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">24.0/</span>Re
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.5</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">100.0</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">4.22</span>, <span style="color: #666666">-14.05</span>, <span style="color: #666666">34.87</span>, <span style="color: #666666">0.658</span>])
        CD <span style="color: #666666">=</span> polyval(p, <span style="color: #666666">1.0/</span>Re) 
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">100.0</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">1.0e4</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-30.41</span>, <span style="color: #666666">43.72</span>, <span style="color: #666666">-17.08</span>, <span style="color: #666666">2.41</span>])
        CD <span style="color: #666666">=</span> polyval(p, <span style="color: #666666">1.0/</span>log10(Re))
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">1.0e4</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">3.35e5</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.1584</span>, <span style="color: #666666">2.031</span>, <span style="color: #666666">-8.472</span>, <span style="color: #666666">11.932</span>])
        CD <span style="color: #666666">=</span> polyval(p, log10(Re))
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">3.35e5</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">5.0e5</span>:
        x1 <span style="color: #666666">=</span> log10(Re<span style="color: #666666">/4.5e5</span>)
        CD <span style="color: #666666">=</span> <span style="color: #666666">91.08*</span>x1<span style="color: #666666">**4</span> <span style="color: #666666">+</span> <span style="color: #666666">0.0764</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.06338</span>, <span style="color: #666666">1.1905</span>, <span style="color: #666666">-7.332</span>, <span style="color: #666666">14.93</span>])
        CD <span style="color: #666666">=</span> polyval(p, log10(Re))
    <span style="color: #008000; font-weight: bold">return</span> CD

<span style="color: #408080; font-style: italic"># Calculate drag coefficient</span>
Npts <span style="color: #666666">=</span> <span style="color: #666666">500</span>
Re <span style="color: #666666">=</span> logspace(<span style="color: #666666">-1</span>, <span style="color: #666666">7</span>, Npts, <span style="color: #008000">True</span>, <span style="color: #666666">10</span>)
CD <span style="color: #666666">=</span> zeros(Npts)
i_list <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,Npts<span style="color: #666666">-1</span>)
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> i_list:
    CD[i] <span style="color: #666666">=</span> cd_sphere(Re[i])
</pre></div>
<p>
</div>
<!-- end box -->


<h3 id="___sec6">Generating the plot in <a href="#example:sphere_freefall">Example 2: Sphere in free fall</a> <a name="___sec6"></a></h3>

The complete programme <b>CDsphere.py</b> used to generate the plot in the example above will now be presented. The programme may be downloaded <a href="https://raw.githubusercontent.com/lrhgit/tkt4140/master/allfiles/Utviklingsprosjekt/kap1/eks1_2/CDsphere.py" target="_blank">here</a>. We will break up the programme and explain the different parts. The complete programme is as follows:
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># eks12/CDsphere.py</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> logspace, zeros

<span style="color: #408080; font-style: italic"># Define the function cd_sphere</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere</span>(Re):
    <span style="color: #BA2121">&quot;This function computes the drag coefficient of a sphere as a function of the Reynolds number Re.&quot;</span>
    <span style="color: #408080; font-style: italic"># Curve fitted after fig. A-56 in Evett &amp; Liu: &quot;Fluid Mechanics &amp; Hydraulics&quot;,</span>
    <span style="color: #408080; font-style: italic"># Schaum&#39;s Solved Problems McGraw - Hill 1989.</span>
    
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log10, array, polyval
    
    <span style="color: #008000; font-weight: bold">if</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.0</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">8.0e6</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.0</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">24.0/</span>Re
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.5</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">100.0</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">4.22</span>, <span style="color: #666666">-14.05</span>, <span style="color: #666666">34.87</span>, <span style="color: #666666">0.658</span>])
        CD <span style="color: #666666">=</span> polyval(p, <span style="color: #666666">1.0/</span>Re) 
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">100.0</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">1.0e4</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-30.41</span>, <span style="color: #666666">43.72</span>, <span style="color: #666666">-17.08</span>, <span style="color: #666666">2.41</span>])
        CD <span style="color: #666666">=</span> polyval(p, <span style="color: #666666">1.0/</span>log10(Re))
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">1.0e4</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">3.35e5</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.1584</span>, <span style="color: #666666">2.031</span>, <span style="color: #666666">-8.472</span>, <span style="color: #666666">11.932</span>])
        CD <span style="color: #666666">=</span> polyval(p, log10(Re))
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">3.35e5</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">5.0e5</span>:
        x1 <span style="color: #666666">=</span> log10(Re<span style="color: #666666">/4.5e5</span>)
        CD <span style="color: #666666">=</span> <span style="color: #666666">91.08*</span>x1<span style="color: #666666">**4</span> <span style="color: #666666">+</span> <span style="color: #666666">0.0764</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.06338</span>, <span style="color: #666666">1.1905</span>, <span style="color: #666666">-7.332</span>, <span style="color: #666666">14.93</span>])
        CD <span style="color: #666666">=</span> polyval(p, log10(Re))
    <span style="color: #008000; font-weight: bold">return</span> CD

<span style="color: #408080; font-style: italic"># Calculate drag coefficient</span>
Npts <span style="color: #666666">=</span> <span style="color: #666666">500</span>
Re <span style="color: #666666">=</span> logspace(<span style="color: #666666">-1</span>, <span style="color: #666666">7</span>, Npts, <span style="color: #008000">True</span>, <span style="color: #666666">10</span>)
CD <span style="color: #666666">=</span> zeros(Npts)
i_list <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,Npts<span style="color: #666666">-1</span>)
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> i_list:
    CD[i] <span style="color: #666666">=</span> cd_sphere(Re[i])

<span style="color: #408080; font-style: italic"># Make plot</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> pyplot
pyplot<span style="color: #666666">.</span>plot(Re, CD, <span style="color: #BA2121">&#39;-b&#39;</span>)
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}
pyplot<span style="color: #666666">.</span>rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)
pyplot<span style="color: #666666">.</span>yscale(<span style="color: #BA2121">&#39;log&#39;</span>)
pyplot<span style="color: #666666">.</span>xscale(<span style="color: #BA2121">&#39;log&#39;</span>)
pyplot<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;$Re$&#39;</span>)
pyplot<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;$C_D$&#39;</span>)
pyplot<span style="color: #666666">.</span>grid(<span style="color: #BA2121">&#39;on&#39;</span>, <span style="color: #BA2121">&#39;both&#39;</span>, <span style="color: #BA2121">&#39;both&#39;</span>)
pyplot<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;example_sphere.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
pyplot<span style="color: #666666">.</span>show()


<span style="color: #408080; font-style: italic"># End</span>
</pre></div>
<p>
In the first code line, 
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> logspace, zeros
</pre></div>
<p>
the functions <code>logspace</code> and <code>zeros</code> are imported from the package <code>numpy</code>. The <code>numpy</code> package (<em>NumPy</em> is an abbreviation for <em>Numerical Python</em>) enables the use of <em>array</em> objects. Using <code>numpy</code>  a wide range of mathematical operations can be done directly on complete arrays, thereby removing the need for loops over array elements. This is commonly called <em>vectorization</em> and may cause a dramatic increase in computational speed of Python programmes. The function <code>logspace</code> works on a logarithmic scale just as the function <code>linspace</code> works on a regular scale. The function <code>zeros</code> creates arrays of a certain size filled with zeros. Several comprehensive guides to the numpy package may be found at <a href="http://www.numpy.org" target="_blank"><tt>http://www.numpy.org</tt></a>. 

<p>
In <b>CDsphere.py</b> a function <code>cd_sphere</code> was defined as follows:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere</span>(Re):
    <span style="color: #BA2121">&quot;This function computes the drag coefficient of a sphere as a function of the Reynolds number Re.&quot;</span>
    <span style="color: #408080; font-style: italic"># Curve fitted after fig. A-56 in Evett &amp; Liu: &quot;Fluid Mechanics &amp; Hydraulics&quot;,</span>
    <span style="color: #408080; font-style: italic"># Schaum&#39;s Solved Problems McGraw - Hill 1989.</span>
    
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log10, array, polyval
    
    <span style="color: #008000; font-weight: bold">if</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.0</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">8.0e6</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.0</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">24.0/</span>Re
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.5</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">100.0</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">4.22</span>, <span style="color: #666666">-14.05</span>, <span style="color: #666666">34.87</span>, <span style="color: #666666">0.658</span>])
        CD <span style="color: #666666">=</span> polyval(p, <span style="color: #666666">1.0/</span>Re) 
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">100.0</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">1.0e4</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-30.41</span>, <span style="color: #666666">43.72</span>, <span style="color: #666666">-17.08</span>, <span style="color: #666666">2.41</span>])
        CD <span style="color: #666666">=</span> polyval(p, <span style="color: #666666">1.0/</span>log10(Re))
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">1.0e4</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">3.35e5</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.1584</span>, <span style="color: #666666">2.031</span>, <span style="color: #666666">-8.472</span>, <span style="color: #666666">11.932</span>])
        CD <span style="color: #666666">=</span> polyval(p, log10(Re))
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">3.35e5</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">5.0e5</span>:
        x1 <span style="color: #666666">=</span> log10(Re<span style="color: #666666">/4.5e5</span>)
        CD <span style="color: #666666">=</span> <span style="color: #666666">91.08*</span>x1<span style="color: #666666">**4</span> <span style="color: #666666">+</span> <span style="color: #666666">0.0764</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.06338</span>, <span style="color: #666666">1.1905</span>, <span style="color: #666666">-7.332</span>, <span style="color: #666666">14.93</span>])
        CD <span style="color: #666666">=</span> polyval(p, log10(Re))
    <span style="color: #008000; font-weight: bold">return</span> CD
</pre></div>
<p>
The function takes <code>Re</code> as an argument and returns the value <code>CD</code>. All Python functions begin with <code>def</code>, followed by the function name, and then inside parentheses a comma-separated list of function arguments, ended with a colon. Here we have only one argument <code>Re</code>. This argument acts as a standard variable inside the function. The statements to perform inside the function must be indented. At the end of a funciton it is common to use the <code>return</code> statement to return the value of the function. 

<p>
Variables defined inside a function, such as <code>p</code> and <code>x1</code> above, are <em>local</em> variables that cannot be accessed outside the function. Variables defined outside functions, in the "main programme", are <em>global</em> variables and may be accessed anywhere, also inside functions. 

<p>
Three more functions from the <code>numpy</code> package are imported in the function. They are not used oustide the function and are therefore chosen to be imported only if the function is called from the main programme. We refer to the <a href="http://www.numpy.org" target="_blank">documentation of NumPy</a> for details about the different functions. 

<p>
The function above contains an example of the use of the <code>if-elif-else</code> block. The block begins with <code>if</code> and a boolean expression. If the boolean expression evaluates to <code>true</code> the <em>indented</em> statements following the <code>if</code> statement are carried out. If not, the boolean expression following the <code>elif</code> is evaluated. If none of the conditions are evaluated to <code>true</code> the statements following the <code>else</code> are carried out. 

<p>
In the code block
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Npts <span style="color: #666666">=</span> <span style="color: #666666">500</span>
Re <span style="color: #666666">=</span> logspace(<span style="color: #666666">-1</span>, <span style="color: #666666">7</span>, Npts, <span style="color: #008000">True</span>, <span style="color: #666666">10</span>)
CD <span style="color: #666666">=</span> zeros(Npts)
i_list <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,Npts<span style="color: #666666">-1</span>)
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> i_list:
    CD[i] <span style="color: #666666">=</span> cd_sphere(Re[i])
</pre></div>
<p>
the function <code>cd_sphere</code> is called. First, the number of data points to be calculated are stored in the integer variable <code>Npts</code>. Using the <code>logspace</code> function imported earlier, <code>Re</code> is assigned an array objet which has float elements with values ranging from \( 10^{-1} \) to \( 10^7 \). The values are uniformly distributed along a 10logarithmic scale. <code>CD</code> is first defined as an array with <code>Npts</code> zero elements, using the <code>zero</code> function. Then, for each element in <code>Re</code>, the drag coefficient is calculated using our own defined function <code>cd_sphere</code>, in a <code>for</code> loop, which is explained in the following.

<p>
The function <code>range</code> is a built-in function that generates a list containing arithmetic progressions. The <code>for i in i_list</code> construct creates a loop over all elements in <code>i_list</code>. In each pass of the loop, the variable <code>i</code> refers to an element in the list, starting with <code>i_list[0]</code> (0 in this case) and ending with the last element <code>i_list[Npts-1]</code> (499 in this case). Note that element indices start at 0 in Python. After the colon comes a block of statements which does something useful with the current element; in this case, the return of the function call <code>cd_sphere(Re[i])</code> is assigned to <code>CD[i]</code>. Each statement in the block must be indented. 

<p>
Lastly, the drag coefficient is plotted and the figure generated:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> pyplot
pyplot<span style="color: #666666">.</span>plot(Re, CD, <span style="color: #BA2121">&#39;-b&#39;</span>)
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}
pyplot<span style="color: #666666">.</span>rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)
pyplot<span style="color: #666666">.</span>yscale(<span style="color: #BA2121">&#39;log&#39;</span>)
pyplot<span style="color: #666666">.</span>xscale(<span style="color: #BA2121">&#39;log&#39;</span>)
pyplot<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;$Re$&#39;</span>)
pyplot<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;$C_D$&#39;</span>)
pyplot<span style="color: #666666">.</span>grid(<span style="color: #BA2121">&#39;on&#39;</span>, <span style="color: #BA2121">&#39;both&#39;</span>, <span style="color: #BA2121">&#39;both&#39;</span>)
pyplot<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;example_sphere.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
pyplot<span style="color: #666666">.</span>show()
</pre></div>
<p>
To generate the plot, the package <code>matplotlib</code> is used. <code>matplotlib</code> is the standard package for curve plotting in Python. For simple plotting the <code>matplotlib.pyplot</code> interface provides a MATLAB-like interface, which has been used here. For documentation and explanation of this package, we refer to <a href="http://www.matplotlib.org" target="_blank"><tt>http://www.matplotlib.org</tt></a>. 

<p>
First, the curve is generated using the function <code>plot</code>, which takes the x-values and y-values as arguments (<code>Re</code> and <code>CD</code> in this case), as well as a string specifying the line style, like in MATLAB. Then changes are made to the figure in order to make it more readable, very similarily to how it is done in MATLAB. For instance, in this case it makes sense to use logarithmic scales. A png version of the figure is saved using the <code>savefig</code> function. Lastly, the figure is showed on the screen with the <code>show</code> function. 

<p>
To change the font size the function <code>rc</code> is used. This function takes in the object <code>font</code>, which is a <em>dictionary</em> object. Roughly speaking, a dictionary is a list where the index can be a text (in lists the index must be an integer). It is best to think of a dictionary as an unordered set of <code>key:value</code> pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: <code>{}</code>. Placing a comma-separated list of <code>key:value</code> pairs within the braces adds initial <code>key:value</code> pairs to the dictionary. In this case the dictionary <code>font</code> contains one <code>key:value</code> pair, namely <code>'size' : 16</code>.

<p>
Descriptions and explanations of all functions available in <code>pyplot</code> may be found <a href="http://matplotlib.org/api/pyplot_summary.html" target="_blank">here</a>.

<h3 id="___sec7">More efficient implementations <a name="___sec7"></a></h3>

When solving numerical problems variables are often not single numbers, but arrays containing many numbers. The function <code>CDsphere</code> above takes a single number in and gives a single number out. For computationally intensive algorithms where variables are stored in arrays this is inconvenient and time consuming, as each of the array elements must be sent to the function independently. It is therefore of interest to implement functions that can take in whole arrays and output whole arrays in an efficient manner. This may be done in a variaty of ways. Some possibilities are presented in the following, and, as we shall see, some are more time consuming than others. 

<p>
A simple extension of the single-valued function above is as follows:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere_py_vector</span>(ReNrs):
    CD <span style="color: #666666">=</span> zeros_like(ReNrs)
    counter <span style="color: #666666">=</span> <span style="color: #666666">0</span>

    <span style="color: #008000; font-weight: bold">for</span> Re <span style="color: #AA22FF; font-weight: bold">in</span> ReNrs:
        CD[counter] <span style="color: #666666">=</span> cd_sphere(Re)
        counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">return</span> CD
</pre></div>
<p>
The new function <code>cd_sphere_py_vector</code> takes in an array <code>ReNrs</code> and calculates the drag coefficient for each element using the previous function <code>cd_sphere</code>. This does the job, but is not very efficient. 

<p>
A second version is implemented in the function <code>cd_sphere_vector</code>. This function takes in the array <code>Re</code> and calculates the drag coefficient of all elements by multiple calls of the function <code>numpy.where</code>; one call for each condition, similarily as each <code>if</code> statement in the function <code>cd_sphere</code>. The function is shown here:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere_vector</span>(Re):
    <span style="color: #BA2121">&quot;Computes the drag coefficient of a sphere as a function of the Reynolds number Re.&quot;</span>
    <span style="color: #408080; font-style: italic"># Curve fitted after fig . A -56 in Evett &amp; Liu :% &quot; Fluid Mechanics &amp; Hydraulics &quot;,</span>
    <span style="color: #408080; font-style: italic"># Schaum &#39; s Solved Problems McGraw - Hill 1989.</span>

    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log10,array,polyval,where,zeros_like
    CD <span style="color: #666666">=</span> zeros_like(Re)
   
    CD <span style="color: #666666">=</span> where(Re<span style="color: #666666">&lt;0</span>,<span style="color: #666666">0.0</span>,CD)     <span style="color: #408080; font-style: italic"># condition 1</span>
    
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.0</span>) <span style="color: #666666">&amp;</span> (Re <span style="color: #666666">&lt;=0.5</span>),<span style="color: #666666">24/</span>Re,CD) <span style="color: #408080; font-style: italic"># condition 2</span>

    p <span style="color: #666666">=</span> array([<span style="color: #666666">4.22</span>,<span style="color: #666666">-14.05</span>,<span style="color: #666666">34.87</span>,<span style="color: #666666">0.658</span>])
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.5</span>) <span style="color: #666666">&amp;</span> (Re <span style="color: #666666">&lt;=100.0</span>),polyval(p,<span style="color: #666666">1.0/</span>Re),CD) <span style="color: #408080; font-style: italic">#condition 3</span>

    p <span style="color: #666666">=</span> array([<span style="color: #666666">-30.41</span>,<span style="color: #666666">43.72</span>,<span style="color: #666666">-17.08</span>,<span style="color: #666666">2.41</span>])
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;100.0</span>)  <span style="color: #666666">&amp;</span> (Re <span style="color: #666666">&lt;=1.0e4</span>) ,polyval(p,<span style="color: #666666">1.0/</span>log10(Re)),CD) <span style="color: #408080; font-style: italic">#condition 4</span>

    p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.1584</span>,<span style="color: #666666">2.031</span>,<span style="color: #666666">-8.472</span>,<span style="color: #666666">11.932</span>])
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">1.0e4</span>)  <span style="color: #666666">&amp;</span>  (Re <span style="color: #666666">&lt;=3.35e5</span>),polyval(p,log10(Re)),CD) <span style="color: #408080; font-style: italic">#condition 5</span>

    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">3.35e5</span>) <span style="color: #666666">&amp;</span> (Re <span style="color: #666666">&lt;=5.0e5</span>),<span style="color: #666666">91.08*</span>(log10(Re<span style="color: #666666">/4.5e5</span>))<span style="color: #666666">**4</span> <span style="color: #666666">+</span> <span style="color: #666666">0.0764</span>,CD) <span style="color: #408080; font-style: italic">#condition 6</span>

    p  <span style="color: #666666">=</span> array([<span style="color: #666666">-0.06338</span>,<span style="color: #666666">1.1905</span>,<span style="color: #666666">-7.332</span>,<span style="color: #666666">14.93</span>])
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">5.05e5</span>)  <span style="color: #666666">&amp;</span>  (Re <span style="color: #666666">&lt;=8.0e6</span>),polyval(p,log10(Re)),CD) <span style="color: #408080; font-style: italic">#condition 7</span>
    
    CD <span style="color: #666666">=</span> where(Re<span style="color: #666666">&gt;8.0e6</span>,<span style="color: #666666">0.2</span>,CD)  <span style="color: #408080; font-style: italic"># condition 8</span>
    <span style="color: #008000; font-weight: bold">return</span> CD
</pre></div>
<p>
A third approach we will try is using boolean type variables. The 8 variables <code>condition1</code> through <code>condition8</code> in the function <code>cd_sphere_vector_bool</code> are boolean variables of the same size and shape as <code>Re</code>. The elements of the boolean variables evaluate to either <code>True</code> or <code>False</code>, depending on if the corresponding element in <code>Re</code> satisfy the condition the variable is assigned. 

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere_vector_bool</span>(Re):
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log10,array,polyval,zeros_like
       
    condition1 <span style="color: #666666">=</span> Re <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>
    condition2 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">0</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span>)
    condition3 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">0.5</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">100.0</span>)
    condition4 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">100.0</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">1.0e4</span>)
    condition5 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">1.0e4</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">3.35e5</span>)
    condition6 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">3.35e5</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">5.0e5</span>)
    condition7 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">5.0e5</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">8.0e6</span>)
    condition8 <span style="color: #666666">=</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">8.0e6</span>
    
    CD <span style="color: #666666">=</span> zeros_like(Re)
    CD[condition1] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    
    CD[condition2] <span style="color: #666666">=</span> <span style="color: #666666">24/</span>Re[condition2]
    
    p <span style="color: #666666">=</span> array([<span style="color: #666666">4.22</span>,<span style="color: #666666">-14.05</span>,<span style="color: #666666">34.87</span>,<span style="color: #666666">0.658</span>])
    CD[condition3] <span style="color: #666666">=</span> polyval(p,<span style="color: #666666">1.0/</span>Re[condition3]) 
    
    p <span style="color: #666666">=</span> array([<span style="color: #666666">-30.41</span>,<span style="color: #666666">43.72</span>,<span style="color: #666666">-17.08</span>,<span style="color: #666666">2.41</span>])
    CD[condition4] <span style="color: #666666">=</span> polyval(p,<span style="color: #666666">1.0/</span>log10(Re[condition4]))
    
    p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.1584</span>,<span style="color: #666666">2.031</span>,<span style="color: #666666">-8.472</span>,<span style="color: #666666">11.932</span>])
    CD[condition5] <span style="color: #666666">=</span> polyval(p,log10(Re[condition5]))
    
    CD[condition6] <span style="color: #666666">=</span> <span style="color: #666666">91.08*</span>(log10(Re[condition6]<span style="color: #666666">/4.5e5</span>))<span style="color: #666666">**4</span> <span style="color: #666666">+</span> <span style="color: #666666">0.0764</span>
    
    p  <span style="color: #666666">=</span> array([<span style="color: #666666">-0.06338</span>,<span style="color: #666666">1.1905</span>,<span style="color: #666666">-7.332</span>,<span style="color: #666666">14.93</span>])
    CD[condition7] <span style="color: #666666">=</span> polyval(p,log10(Re[condition7]))
    
    CD[condition8] <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
    
    <span style="color: #008000; font-weight: bold">return</span> CD
</pre></div>
<p>
Lastly, the built-in function <code>vectorize</code> is used to automatically generate a vector-version of the function <code>cd_sphere</code>, as follows:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">cd_sphere_auto_vector<span style="color: #666666">=</span>vectorize(cd_sphere)
</pre></div>
<p>
Using the function <code>clock</code> in the module <code>time</code>, the cpu-time for each of the array-type functions described above has been measured for a test example. An array with 500 elements was sent to the functions. 
<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">cd_sphere_vector_bool   execution time = 0.000312
cd_sphere_vector        execution time = 0.000641
cd_sphere_auto_vector   execution time = 0.009497
cd_sphere_py_vector     execution time = 0.010144
</pre></div>
<p>
As seen, the function with the boolean variables was fastest. The simple vectorized version of the original function was much slower, and the built-in function <code>vectorize</code> was nearly as inefficient.

<p>
<!-- --- end exercise --- -->

<h2 id="___sec8">Differences <a name="___sec8"></a></h2>

We will study some simple methods to solve initial value problems. Later we shall see that these methods also may be used to solve boundary value problems for ODEs.

<p>
<center><p><img src="kap1/4_new.png" align="bottom" width=300></p></center>

$$
\begin{equation*}
x_j=x_0+jh
\end{equation*}
$$

where \( h=\Delta x \) is assumed constant unless otherwise stated. 

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Illustration of how to obtain difference equations. <a name="fig:1.5"></a> </p></center>
<p><img src="kap1/5_new.png" align="bottom" width=300></p>
</center>

<p>
Forward differences:
$$
\begin{equation*}
\Delta y_j=y_{j+1}-y_j
\end{equation*}
$$


<p>
Backward differences:
$$
\begin{equation} \label{eq:1201}
\nabla y_j=y_j-y_{j-1}
\end{equation}
$$


<p>
Central differences:
$$
\begin{equation*}
\delta y_{j+\frac{1}{2}}=y_{j+1}-y_j
\end{equation*}
$$


<p>
The linear difference operators \( \Delta \), \( \nabla \) and \( \delta \) are useful when we are deriving more complicated expressions. An example of usage is as follows,
$$
\begin{equation*}
\delta ^2y_j=\delta (\delta y_j)=\delta (y_{1+\frac{1}{2}}-y_{1-\frac{1}{2}}) 
=y_{j+1}-y_j-(y_j-y_{j-1})=y_{j+1}-2y_j+y_{j-1}
\end{equation*}
$$


<p>
We will mainly write out the formulas entirely instead of using operators. 

<p>
We shall find difference formulas and need again <b>Taylor's theorem</b>:
$$
\begin{align}\label{eq:1202}
y(x)=&y(x_0)+y'(x_0)\cdot (x-x_0)+\frac{1}{2}y''(x_0)\cdot (x-x_0)^2 + \\
&\dots + \frac{1}{n!}y^{(n)}(x_0)\cdot (x-x_0)^n +R_n \nonumber
\end{align}
$$


<p>
The remainder \( R_n \) is given by
$$
\begin{align}
R_n&=\frac{1}{(n+1)!}y^{(n+1)}(\xi)\cdot (x-x_0)^{n+1}\\
&\text{where } \xi \in (x_0,x) \nonumber
\end{align}
$$


<p>
By use of \eqref{eq:1202} we get
$$
\begin{align} \label{eq:1203a}
y(x_{j+1}) \equiv &y(x_j+h)=y(x_j)+hy'(x_j) +\frac{h^2}{2}y''(x_j)+\\
&\dots+\frac{h^ny^{(n)}(x_j)}{n!}+R_n \nonumber
\end{align}
$$

where the remainder \( R_n=O(h^{n+1}),\ h\to 0  \).

<p>
From \eqref{eq:1203a} we also get 
$$
\begin{equation}\label{eq:1203b}
y(x_{j-1}) \equiv y(x_j-h)=y(x_j)-hy'(x_j)+\frac{h^2}{2}y''(x_j)+\dots+\frac{h^k(-1)^ky^{(k)}(x_j)}{k!}+\dots
\end{equation}
$$


<p>
We will here and subsequently assume that \( h \) is positive. 

<p>
We solve \eqref{eq:1203a} with respect to \( y' \):
$$
\begin{equation} \label{eq:1204a}
y'(x_j)=\frac{y(x_{j+1})-y(x_j)}{h}+O(h)
\end{equation} 
$$


<p>
We solve \eqref{eq:1203b} with respect to \( y' \):
$$
\begin{equation} \label{eq:1204b}
y'(x_j)=\frac{y(x_{j})-y(x_{j-1})}{h}+O(h)
\end{equation}
$$


<p>
By addition of \eqref{eq:1203b} and \eqref{eq:1203a} we get
$$
\begin{equation} \label{eq:1204c}
y''(x_j)=\frac{y(x_{j+1})-2y(x_{j})+y(x_{j-1})}{h^2}+O(h^2)
\end{equation}
$$


<p>
By subtraction of \eqref{eq:1203b} from \eqref{eq:1203a} we get
$$
\begin{equation} \label{eq:1204d}
y'(x_j)=\frac{y(x_{j+1})-y(x_{j-1})}{2h}+O(h^2)
\end{equation}
$$


<p>
<b>Notation:</b> We let \( y(x_j) \) always denote the function \( y(x) \) with \( x=x_j \). We use \( y_j \) both for the numerical and analytical value. Which is which will be implied. 

<p>
Equations \eqref{eq:1204a}, \eqref{eq:1204b}, \eqref{eq:1204c} and \eqref{eq:1204d} then gives the following difference expressions:
$$
\begin{align} \label{eq:1205a}
&y'_j=\frac{y_{j+1}-y_j}{h}\ ;\  \text{truncation error}\ O(h)\\
\label{eq:1205b}
&y'_j=\frac{y_{j}-y_{j-1}}{h}\ ;\  \text{truncation error}\ O(h)\\
\label{eq:1205c}
&y''_j=\frac{y_{j+1}-2y_j+y_{j-1}}{h^2}\ ;\  \text{truncation error}\ O(h^2)\\
\label{eq:1205d}
&y'_j=\frac{y_{j+1}-y_{j-1}}{2h}\ ;\  \text{truncation error}\ O(h^2)
\end{align}
$$


<p>
\eqref{eq:1205a} is a forward difference, \eqref{eq:1205b} is a backward difference while \eqref{eq:1205c} and \eqref{eq:1205d} are central differences. 

<p>
<center><p><img src="kap1/6.png" align="bottom" width=300></p></center>

<p>
The expressions in \eqref{eq:1205a}, \eqref{eq:1205b}, \eqref{eq:1205c} and \eqref{eq:1205d} are easily established from the figure. 

<p>
\eqref{eq:1205a} follows directly. 

<p>
\eqref{eq:1205c}:
$$
\begin{equation*}
y''_j(x_j)=\left(\frac{y_{j+1}-y_j}{h}-\frac{y_{j}-y_{j-1}}{h}\right)\cdot \frac{1}{h} = \frac{y_{j+1}-2y_j+y_{j-1}}{h^2}
\end{equation*}
$$


<p>
\eqref{eq:1205d}:

$$
\begin{equation*}
y'_j=\left(\frac{y_{j+1}-y_j}{h}-\frac{y_{j}+y_{j-1}}{h}\right)\cdot \frac{1}{2}=\frac{y_{j+1}-y_{j-1}}{2h}
\end{equation*}
$$


<p>
To find the truncation error we must use the Taylor series expansion. 

<p>
The derivation above may be done more systematically. We set 
$$
\begin{equation} \label{eq:1206a}
y'(x_j)=a\cdot y(x_{j-1})+b\cdot y(x_j)+c\cdot y(x_{j+1})+O(h^m)
\end{equation}
$$

where we shall determine the constants \( a \), \( b \) and \( c \) together with the error term. For simplicity we use the notation \( y_j\equiv y(x_j),\ y'_j \equiv y'(x_j) \) and so on. From the Taylor series expansion in \eqref{eq:1203a} and \eqref{eq:1203b} we get
$$
\begin{align*}
&a\cdot y_{j-1}+b\cdot y_j +c\cdot y_{j+1} = \\
&a\cdot\left[y_j-hy'_j+\frac{h^2}{2}y''_j+\frac{h^3}{6}y'''_j(\xi)\right]+b\cdot y_j + \\
&c\cdot \left[y_j-hy'_j+\frac{h^2}{2}y''_j+\frac{h^3}{6}y'''_j(\xi)\right]
\end{align*}
$$

Collecting terms:
$$
\begin{align*}
a\cdot y_{j-1}+b\cdot y_j +c\cdot y_{j+1} = \\
(a+b+c)y_j+(c-a)hy'_j+ \\
(a+c)\frac{h^2}{2}y''_j+(c-a)\frac{h^3}{6}y'''(\xi)
\end{align*}
$$

We determine \( a \), \( b \) and \( c \) such that \( y'_j \) gets as high accuracy as possible:
$$
\begin{align} 
a+b+c=0 \nonumber \\
(c-a)\cdot h=1 \label{eq:1206b}\\ \nonumber
a+c=1
\end{align}
$$

The solution to \eqref{eq:1206b} is
$$
\begin{equation*}
a=-\frac{1}{2h},\ b=0 \text{ and } c=\frac{1}{2h}
\end{equation*}
$$

which when inserted in \eqref{eq:1206a} gives 
$$
\begin{equation}\label{eq:1207}
y'_j=\frac{y_{j+1}-y_{j-1}}{2h}-\frac{h^2}{6}y'''(\xi)
\end{equation} \\
$$

Comparing \eqref{eq:1207} with \eqref{eq:1206a} we see that the error term is \( O(h^m)=-\frac{h^2}{6}y'''(\xi) \), which means that \( m=2 \). As expected, \eqref{eq:1207} is identical to \eqref{eq:1204d}.

<p>
Let's use this method to find a forward difference expression for \( y'(x_j) \) with accuracy of \( O(h^2) \). Second order accuracy requires at least three unknown coefficients. Thus,
$$
\begin{equation}\label{eq:1208a}
y'(x_j)=a\cdot y_j + b\cdot y_{j+1} + c\cdot y_{j+2} + O(h^m)
\end{equation}	
$$

The procedure goes as in the previous example as follows,
$$
\begin{align*}
a&\cdot y_{j}+b\cdot y_{j+1} +c\cdot y_{j+2} =\\
a&\cdot y_j+b\cdot\left[y_j+hy'_j+\frac{h^2}{2}y''_j+\frac{h^3}{6}y'''(\xi)\right]+\\
c&\cdot \left[y_j+2hy'_j+2h^2y''_j+\frac{8h^3}{6}y'''_j(\xi)\right]\\
=&(a+b+c)\cdot y_j+(b+2c)\cdot hy'_j \\
+& h^2\left(\frac{b}{2}+2c\right)\cdot y''_j+\frac{h^3}{6}(b+8c)\cdot y'''(\xi)
\end{align*}
$$

We determine \( a \), \( b \) and \( c \) such that \( y'_j \) becomes as accurate as possible. Then we get,
$$
\begin{align}
a+b+c=0 \nonumber\\
(b+2c)\cdot h=1 \label{eq:1208b}\\
\frac{b}{2}+2c=0\nonumber
\end{align}
$$

The solution of \eqref{eq:1208b} is
$$
\begin{equation*}
a=-\frac{3}{2h},\ b=\frac{2}{h},\ c=-\frac{1}{2h}\
\end{equation*}
$$

which inserted in \eqref{eq:1208a} gives
$$
\begin{equation} \label{eq:1209}
y'_j=\frac{-3y_j+4y_{j+1}-y_{j+2}}{2h}+\frac{h^2}{3}y'''(\xi)
\end{equation}
$$

The error term \( O(h^m)=\frac{h^2}{3}y'''(\xi) \) shows that \( m=2 \).

<p>
Here follows some difference formulas derived with the procedure above:

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Forward differences:
$$
\begin{align*}
\dfrac{dy_i}{dx}&=\dfrac{y_{i}-y_{i-1}}{\Delta x}+\dfrac{1}{2}y''(\xi)\Delta x \\
\dfrac{dy_i}{dx}&=\dfrac{3y_i-4y_{i-1}+y_{i-2}}{2\Delta x}+\dfrac{1}{3}y'''(\xi)\cdot (\Delta x)^2 \\
\dfrac{dy_i}{dx}&=\dfrac{11y_i-18y_{i-1}+9y_{i-2}-y_{i-3}}{6\Delta x}+\dfrac{1}{4}y^{(4)}(\xi)\cdot (\Delta x)^3 \\
\dfrac{d^2y_i}{dx^2}&=\dfrac{y_i-2y_{i-1}+y_{i-2}}{(\Delta x)^2}+y'''(\xi)\cdot \Delta x \\
\dfrac{d^2y_i}{dx^2}&=\dfrac{2y_i-5y_{i-1}+4y_{i-2}-y_{i-3}}{(\Delta x)^2}+\dfrac{11}{12}y^{(4)}(\xi)\cdot (\Delta x)^2
\end{align*}
$$
</div>
<!-- end box -->


<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Backward differences:
$$
\begin{align*}
\dfrac{dy_i}{dx}&=\dfrac{y_{i}-y_{i-1}}{\Delta x}+\dfrac{1}{2}y''(\xi)\Delta x \\
\dfrac{dy_i}{dx}&=\dfrac{3y_i-4y_{i-1}+y_{i-2}}{2\Delta x}+\dfrac{1}{3}y'''(\xi)\cdot (\Delta x)^2 \\
\dfrac{dy_i}{dx}&=\dfrac{11y_i-18y_{i-1}+9y_{i-2}-y_{i-3}}{6\Delta x}+\dfrac{1}{4}y^{(4)}(\xi)\cdot (\Delta x)^3 \\
\dfrac{d^2y_i}{dx^2}&=\dfrac{y_i-2y_{i-1}+y_{i-2}}{(\Delta x)^2}+y'''(\xi)\cdot \Delta x \\
\dfrac{d^2y_i}{dx^2}&=\dfrac{2y_i-5y_{i-1}+4y_{i-2}-y_{i-3}}{(\Delta x)^2}+\dfrac{11}{12}y^{(4)}(\xi)\cdot (\Delta x)^2
\end{align*}
$$
</div>
<!-- end box -->


<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Central differences:
$$
\begin{align*}
\dfrac{dy_i}{dx}&=\dfrac{y_{i+1}-y_{i-1}}{2\Delta x}-\dfrac{1}{6}y'''(\xi)(\Delta x)^2 \\
\dfrac{dy_i}{dx}&=\dfrac{-y_{i+2}+8y_{i+1}-8y_{i-1}+y_{i-2}}{12\Delta x}+\dfrac{1}{30}y^{(5)}(\xi)\cdot (\Delta x)^4 \\
\dfrac{d^2y_i}{dx^2}&=\dfrac{y_{i+1}-2y_{i}+y_{i-1}}{(\Delta x)^2}-\dfrac{1}{12}y^{(4)}(\xi)\cdot (\Delta x)^2 \\
\dfrac{d^2y_i}{dx^2}&=\dfrac{-y_{i+2}+16y_{i+1}-30y_{i}+16y_{i-1}-y_{i-2}}{12(\Delta x)^2}+\dfrac{1}{90}y^{(6)}(\xi)\cdot (\Delta x)^4 \\
\dfrac{d^3y_i}{dx^3}&=\dfrac{y_{i+2}-2y_{i+1}+2y_{i-1}-y_{i-2}}{2(\Delta x)^3}+\dfrac{1}{4}y^{(5)}(\xi)\cdot (\Delta x)^2
\end{align*}
$$
</div>
<!-- end box -->


<h3 id="___sec9">Treatment of the term \( \frac{d}{dx} \left[ p(x) \frac{d}{dx} u(x)\right] \) <a name="___sec9"></a></h3>

This term often appears in difference equations, and it may be clever to treat the term as it is instead of first execute the differentiation. 

<p>
<b>Central differences.</b>
We use central differences (recall Figure <a href="#fig:1.5">2</a>) as follows,
$$
\begin{align*}
\frac{d}{dx}\left[p(x)\cdot \frac{d}{dx}u(x)\right]\bigg|_i \approx& \frac{[p(x)\cdot u'(x)]|_{i+\frac{1}{2}}-[p(x)\cdot u'(x)]|_{i-\frac{1}{2}}}{h}\\
=& \frac{p(x_{i+\frac{1}{2}})\cdot u'(x_{i+\frac{1}{2}})-p(x_{i-\frac{1}{2}})\cdot u'(x_{i-\frac{1}{2}})}{h}
\end{align*}
$$

Using central differences again, we get
$$
\begin{equation*}
u'(x_{i+\frac{1}{2}}) \approx \frac{u_{i+1}-u_i}{h},\ u'(x_{i-\frac{1}{2}}) \approx \frac{u_{i}-u_{i-1}}{h},\
\end{equation*}
$$

which inserted in the previous equation gives the final expression
$$
\begin{equation}\label{eq:12010a}
\frac{d}{dx}\left[p(x)\cdot \frac{d}{dx}u(x)\right]\bigg|_i \approx \frac{p_{i-\frac{1}{2}}\cdot {u_{i-1}-(p_{i+\frac{1}{2}}+p_{i-\frac{1}{2}})\cdot u_i+p_{i+\frac{1}{2}}\cdot u_{i+1}}}{h^2} + \text{error term}
\end{equation}
$$

where
$$
\begin{equation*}
\text{error term} =-\frac{h^2}{24}\cdot \frac{d}{dx} \bigg(p(x)\cdot u'''(x)+[p(x)\cdot u'(x)]''\bigg) + O(h^3)
\end{equation*}
$$

If \( p(x_{1+\frac{1}{2}}) \) and \( p(x_{1-\frac{1}{2}}) \) cannot be found directly, we use
$$
\begin{equation}\label{eq:12011}
p(x_{1+\frac{1}{2}})\approx \frac{1}{2}(p_{i+1}+p_i),\ p(x_{1-\frac{1}{2}}) \approx \frac{1}{2}(p_i+p_{i-1})
\end{equation}
$$

Note that for \( p(x)=1=\text{constant} \) we get the usual expression 
$$
\begin{equation*}
\frac{d^2u}{dx^2}\bigg|_i=\frac{u_{i+1}-2u_i+u_{i-1}}{h^2}+O(h^2)
\end{equation*}
$$

<b>Forward differences.</b>
We start with
$$
\begin{align*}
\frac{d}{dx}\left[p(x)\cdot \frac{du}{dx}\right]\bigg|_i &\approx \frac{p(x_{i+\frac{1}{2}})\cdot u'(x_{i+\frac{1}{2}})-p(x_i)\cdot u'(x_i)}{\frac{h}{2}}\\
 &\approx \frac{p(x_{i+\frac{1}{2}})\cdot\left( \frac{u_{i+1}-u_i}{h}\right) -p(x_i)\cdot u'(x_i)}{\frac{h}{2}}
\end{align*}
$$

which gives
$$
\begin{equation}\label{eq:12012a}
\frac{d}{dx}\left[p(x)\cdot \frac{du}{dx}\right]\bigg|_i = \frac{2\cdot [p(x_{i+\frac{1}{2}})\cdot {(u_{i+1}-u_i)-h\cdot p(x_i)\cdot u'(x_i)]}}{h^2} +\text{error term}
\end{equation}
$$

where
$$
\begin{equation}\label{eq:12012b}
\text{error term} =- \frac{h}{12}[3p''(x_i)\cdot u'(x_i)+6p'(x_i)\cdot u''(x_i)+4p(x_i)\cdot u'''(x_i)]+O(h^2)
\end{equation}
$$

We have kept the term \( u'(x_i) \) since \eqref{eq:12012a} usually is used at the boundary, and \( u'(x_i) \) may be prescribed there. 
For \( p(x)=1=\text{constant} \) we get the expression
$$
\begin{equation}\label{eq:12013}
u''_i = \frac{2\cdot [u_{i+1}-u_i-h\cdot u'(x_i)]}{h^2}-\frac{h}{3}u'''(x_i)+O(h^2)
\end{equation}
$$


<p>
<b>Backward Differences.</b>
We start with
$$
\begin{align*}
\frac{d}{dx}\left[p(x)\frac{du}{dx}\right]\bigg|_i \approx& \frac{p(x_i)\cdot u'(x_i)-p(x_i)\cdot u'(x_{i-\frac{1}{2}})\cdot u'(x_{i-\frac{1}{2}})}{\frac{h}{2}}\\ \approx& \frac{p(x_i)\cdot u'(x_i)-p(x_{i-\frac{1}{2}})\left(\frac{u_i-u_{i-1}}{h}\right)}{\frac{h}{2}}
\end{align*}
$$

which gives
$$
\begin{equation} \label{eq:12014a}
\frac{d}{dx}\left[p(x)\frac{du}{dx}\right]\bigg|_i = \frac{2\cdot [h\cdot p(x_i)u'(x_i)-p(x_{i-\frac{1}{2}})\cdot (u_i-u_{i-1})]}{h^2}+\text{error term}
\end{equation}
$$

where
$$
\begin{equation} \label{eq:12014b}
\text{error term}=\frac{h}{12}[3p''(x_i)\cdot u'(x_i)+6p'(x_i)\cdot u''(x_i)+4p(x_i)\cdot u'''(x_i)]+O(h^2)
\end{equation}
$$

This is the same error term as in \eqref{eq:12012b} except from the sign. Also here we have kept the term \( u'(x_i) \) since \eqref{eq:12014b} usually is used at the boundary where \( u'(x_i) \) may be prescribed. 
For \( p(x)=1=\text{constant} \) we get the expression
$$
\begin{equation}
u''_i = \frac{2\cdot [h\cdot u'(x_i)-(u_i-u_{i-1})]}{h^2}+\frac{h}{3}u'''(x_i)+O(h^2)
\end{equation}
$$

<h2 id="___sec10">Euler's method <a name="___sec10"></a></h2>

The ODE is given as
$$
\begin{align} \label{eq:1301}
\frac{dy}{dx} = y'(x)&=f(x,y)\\
y(x_0)=&y_0 
\end{align}
$$

Inserting \eqref{eq:1204a} we obtain
$$
\begin{equation*}
y(x_{n+1})=y(x_n)+h\cdot f(x_n,y(x_n))+O(h^2)
\end{equation*}
$$

or
$$
\begin{equation} \label{eq:1302}
y_{n+1}=y_n+h\cdot f(x_n,y_n)
\end{equation}
$$

\eqref{eq:1302} is a difference equation and the scheme is called <b>Euler's method</b> (1768). The scheme is illustrated graphically in Figure <a href="#fig:1.7">3</a>. Euler's method is a first order method, since the expression for \( y'(x) \) is first order of \( h \). The method has a global error of order \( h \), and a local of order \( h^2 \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Graphical illustration of Euler's method. <a name="fig:1.7"></a> </p></center>
<p><img src="kap1/7.png" align="bottom" width=400></p>
</center>

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">

<p>
<!-- --- begin exercise --- -->

<h2 id="ex:falling_sphere">Example 3: Falling sphere with constant and varying drag<a name="ex:falling_sphere"></a></h2>

We write \eqref{eq:sphere_1st_order} and \eqref{eq:sphere_second_order} as a sytem as follows,
$$
\begin{align}
& \frac{dz}{dt}=v\label{eq:1303a}\\
& \frac{dv}{dt}=g-\alpha v^2 \label{eq:1303b}
\end{align}
$$

where
$$
\begin{equation*}
\alpha =\frac{3\rho _f}{4\rho _k\cdot d}\cdot C_D
\end{equation*}
$$

The analytical solution with \( z(0)=0 \) and \( v(0)=0 \) is given by
$$
\begin{equation} \label{eq:1304a}
v(t)=\sqrt{\frac{g}{\alpha}}\cdot \tanh (\sqrt{\alpha g}\cdot t), \ z(t)=\frac{\ln(\cosh(\sqrt{\alpha g}\cdot t)}{\alpha}
\end{equation}
$$

The terminal velocity \( v_t \) is found by \( \frac{dv}{dt}=0 \) which gives \( v_t=\sqrt{\frac{g}{\alpha}} \). 

<p>
We use data from a golf ball: \( d= 41\text{ mm} \), \( \rho_k = 1275 \text{ kg/m}^3 \), \( \rho_k = 1.22 \text{ kg/m}^3 \), and choose \( C_D = 0.4 \) which gives \( \alpha = 7\cdot 10^{-3} \). The terminal velocity then becomes 
$$
\begin{equation*}
v_t = \sqrt{\frac{g}{\alpha}} = 37.44
\end{equation*}
$$


<p>
If we use Teylor's method from the section <a href="#sec:taylor">Taylor's method</a> we get the following expression by using four terms in the series expansion:
$$
\begin{align}\label{eq:1305}
z(t)=&\frac{1}{2}gt^2\cdot (1-\frac{1}{6}\alpha gt^2)\\
v(t)=&g t\cdot (1-\frac{1}{3}\alpha gt^2)
\end{align}
$$


<p>
The Euler scheme \eqref{eq:1302} used on \eqref{eq:1303b} gives
$$
\begin{equation} \label{eq:1306}
v_{n+1}=v_n+\Delta t\cdot (g-\alpha\cdot v^2_n),\ n=0,1,\dots
\end{equation}
$$

with \( v(0)=0 \).

<p>
One way of implementing the integration scheme is given in the following function <code>euler()</code>:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">euler</span>(func,z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Euler scheme for solution of systems of of ODEs. </span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions, </span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns </span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>
    
    dt <span style="color: #666666">=</span> time[<span style="color: #666666">1</span>]<span style="color: #666666">-</span>time[<span style="color: #666666">0</span>]
    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time),<span style="color: #666666">2</span>))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">1</span>:]):
        z[i<span style="color: #666666">+1</span>,:]<span style="color: #666666">=</span>z[i,:] <span style="color: #666666">+</span> func(z[i,:],t)<span style="color: #666666">*</span>dt

    <span style="color: #008000; font-weight: bold">return</span> z
</pre></div>
<p>
The programme <b>FallingSphereEuler.py</b> (may be downloaded <a href="https://raw.githubusercontent.com/lrhgit/tkt4140/master/allfiles/Utviklingsprosjekt/kap1/eks1_3/FallingSphereEuler.py" target="_blank">here</a>) computes the solution for the first 10 seconds, using a time step of \( \Delta t=0.5 \) s, and generates the plot in Figure <a href="#fig:faling_sphere_euler">4</a>. In addition to the case of constant drag coefficient, a solution for the case of varying \( C_D \) is included. To find \( C_D \) as function of velocity we use the function <em>cd_sphere()</em> that we implemented in <a href="#example:sphere_freefall">Example 2: Sphere in free fall</a>. The complete programme is as follows,

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># eks1_3/FallingSphereEuler.py</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>
sys<span style="color: #666666">.</span>path<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;../eks1_2&#39;</span>)
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">DragCoefficientGeneric</span> <span style="color: #008000; font-weight: bold">import</span> cd_sphere    
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

g <span style="color: #666666">=</span> <span style="color: #666666">9.81</span>      <span style="color: #408080; font-style: italic"># Gravity m/s^2</span>
d <span style="color: #666666">=</span> <span style="color: #666666">41.0e-3</span>   <span style="color: #408080; font-style: italic"># Diameter of the sphere</span>
rho_f <span style="color: #666666">=</span> <span style="color: #666666">1.22</span>  <span style="color: #408080; font-style: italic"># Density of fluid [kg/m^3]</span>
rho_s <span style="color: #666666">=</span> <span style="color: #666666">1275</span>  <span style="color: #408080; font-style: italic"># Density of sphere [kg/m^3]</span>
nu <span style="color: #666666">=</span> <span style="color: #666666">1.5e-5</span>   <span style="color: #408080; font-style: italic"># Kinematical viscosity [m^2/s]</span>
CD <span style="color: #666666">=</span> <span style="color: #666666">0.4</span>      <span style="color: #408080; font-style: italic"># Constant drag coefficient</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;2x2 system for sphere with constant drag.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    alpha <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)<span style="color: #666666">*</span>CD
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>], g <span style="color: #666666">-</span> alpha<span style="color: #666666">*</span>z[<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>]
    <span style="color: #008000; font-weight: bold">return</span> zout 

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f2</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;2x2 system for sphere with Re-dependent drag.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    v <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(z[<span style="color: #666666">1</span>]) 
    Re <span style="color: #666666">=</span> v<span style="color: #666666">*</span>d<span style="color: #666666">/</span>nu
    CD <span style="color: #666666">=</span> cd_sphere(Re)
    alpha <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)<span style="color: #666666">*</span>CD
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>], g <span style="color: #666666">-</span> alpha<span style="color: #666666">*</span>z[<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>]
    <span style="color: #008000; font-weight: bold">return</span> zout

<span style="color: #408080; font-style: italic"># define euler scheme</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">euler</span>(func,z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Euler scheme for solution of systems of of ODEs. </span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions, </span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns </span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>
    
    dt <span style="color: #666666">=</span> time[<span style="color: #666666">1</span>]<span style="color: #666666">-</span>time[<span style="color: #666666">0</span>]
    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time),<span style="color: #666666">2</span>))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">1</span>:]):
        z[i<span style="color: #666666">+1</span>,:]<span style="color: #666666">=</span>z[i,:] <span style="color: #666666">+</span> func(z[i,:],t)<span style="color: #666666">*</span>dt

    <span style="color: #008000; font-weight: bold">return</span> z

<span style="color: #408080; font-style: italic"># main program starts here</span>

T <span style="color: #666666">=</span> <span style="color: #666666">10</span>  <span style="color: #408080; font-style: italic"># end of simulation</span>
N <span style="color: #666666">=</span> <span style="color: #666666">20</span>  <span style="color: #408080; font-style: italic"># no of time steps</span>
time <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)

z0<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #666666">2</span>)
z0[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>

ze <span style="color: #666666">=</span> euler(f, z0, time)     <span style="color: #408080; font-style: italic"># compute response with constant CD using Euler&#39;s method</span>
ze2 <span style="color: #666666">=</span> euler(f2, z0, time)   <span style="color: #408080; font-style: italic"># compute response with varying CD using Euler&#39;s method</span>

k1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(g<span style="color: #666666">*4*</span>rho_s<span style="color: #666666">*</span>d<span style="color: #666666">/</span>(<span style="color: #666666">3*</span>rho_f<span style="color: #666666">*</span>CD))
k2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">3*</span>rho_f<span style="color: #666666">*</span>g<span style="color: #666666">*</span>CD<span style="color: #666666">/</span>(<span style="color: #666666">4*</span>rho_s<span style="color: #666666">*</span>d))
v_a <span style="color: #666666">=</span> k1<span style="color: #666666">*</span>np<span style="color: #666666">.</span>tanh(k2<span style="color: #666666">*</span>time)   <span style="color: #408080; font-style: italic"># compute response with constant CD using analytical solution</span>

<span style="color: #408080; font-style: italic"># plotting</span>

legends<span style="color: #666666">=</span>[]
line_type<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;-&#39;</span>,<span style="color: #BA2121">&#39;:&#39;</span>,<span style="color: #BA2121">&#39;.&#39;</span>,<span style="color: #BA2121">&#39;-.&#39;</span>,<span style="color: #BA2121">&#39;--&#39;</span>]

plot(time, v_a, line_type[<span style="color: #666666">0</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Analytical (constant CD)&#39;</span>)

plot(time, ze[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">1</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Euler (constant CD)&#39;</span>)

plot(time, ze2[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">3</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Euler (varying CD)&#39;</span>)

legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}
rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)
xlabel(<span style="color: #BA2121">&#39;Time [s]&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;Velocity [m/s]&#39;</span>)
savefig(<span style="color: #BA2121">&#39;example_sphere_falling_euler.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
show()
</pre></div>
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Euler's method with \( \Delta t=0.5 \) s. <a name="fig:faling_sphere_euler"></a> </p></center>
<p><img src="kap1/eks1_3/example_sphere_falling_euler.png" align="bottom" width=400></p>
</center>

<p>
</div>
<!-- end box -->


<p>
Euler's method may of course also be used for a system. Let's look at a simultaneous system of \( p \) equations
$$
\begin{align}
&y'_1=f_1(x,y_1,y_2,\dots y_p) \nonumber\\
&y'_2=f_2(x,y_1,y_2,\dots y_p) \nonumber\\
&. \label{eq:1307a}\\
&.\nonumber\\
&y'_p=f_p(x,y_1,y_2,\dots y_p)\nonumber
\end{align}
$$

with initial values
$$
\begin{equation}\label{eq:1307b}
y_1(x_0)=a_1,\ y_2(x_0)=a_2,\dots,\ y_p(x_0)=a_p 
\end{equation}
$$

Or, in vectorial format as follows,
$$
\begin{align}\label{eq:1308}
\mathbf{y'}&=\mathbf{f}(x,\mathbf{y})\\
\mathbf{y}&(x_0)=\mathbf{a} \nonumber
\end{align}
$$

where \( \mathbf{y'} \), \( \mathbf{f} \), \( \mathbf{y} \) and \( \mathbf{a} \) are column vectores with \( p \) components. 

<p>
The Euler scheme \eqref{eq:1302} used on \eqref{eq:1308} gives
$$
\begin{equation}\label{eq:1309}
\mathbf{y_{n+1}}=\mathbf{y_n}+h\cdot \mathbf{f}(x_n,\mathbf{y_n})
\end{equation}
$$

For a system of three equations we get
$$
\begin{align} 
y'_1=&y_2\nonumber\\
y'_2=&y_3\label{eq:13010}\\
y'_3=&-y_1y_3\nonumber
\end{align}
$$

In this case \eqref{eq:1309} gives
$$
\begin{align} 
&(y_1)_{n+1}=(y_1)_n+h\cdot (y_2)_n\nonumber\\
&(y_2)_{n+1}=(y_2)_n+h\cdot (y_3)_n\label{eq:13011}\\
&(y_3)_{n+1}=(y_3)_n-h\cdot (y_1)_n\cdot (y_3)_n\nonumber\\
\end{align}
$$

with \( y_1(x_0)=a_1,\ y_2(x_0)=a_2,\text{ and }y_3(x_0)=a_3 \)

<p>
In the section <a href="#subsec:reduction">Reduction of Higher order Equations</a> we have seen how we can reduce a higher order ODE to a set of first order ODEs. In \eqref{eq:1303a} and \eqref{eq:1303b} we have the equation \( \frac{d^2z}{dt^2}=g-\alpha\cdot \left(\frac{dz}{dt}\right)^2 \) which we have reduced to a system as
$$
\begin{align*}
\frac{dz}{dt}= v&\\
\frac{dv}{dt}= g&-\alpha\cdot v^2
\end{align*}
$$

which gives an Euler scheme as follows,
$$
\begin{align*}
&z_{n+1}=z_n+\Delta t\cdot v_n\\
&v_{n+1}=n_n+\Delta t\cdot [g-\alpha(v_n)^2]\\
&\text{med }z_0=0,\ v_0=0
\end{align*}
$$


<p>
<!-- --- end exercise --- -->

<h2 id="___sec12">Heun's method <a name="___sec12"></a></h2>

From \eqref{eq:1204a} or \eqref{eq:1205a} we have
$$
\begin{equation}\label{eq:1401}
y''(x_n,y_n)=f'\left(x_n,y(x_n,y_n)\right)\approx \frac{f(x_n+h)-f(x_n)}{h}
\end{equation}
$$

The Taylor series expansion \eqref{eq:1203a} gives
$$
\begin{equation*}
y(x_n+h)=y(x_n)+hy'[x_n,y(x_n)]+\frac{h^2}{2}y''[x_n,y(x_n)]+O(h^3)
\end{equation*}
$$

which, inserting \eqref{eq:1401}, gives
$$
\begin{equation}\label{eq:1402}
y_{n+1}=y_n+\frac{h}{2}\cdot [f(x_n,y_n)+f(x_{n+1},y(x_{n+1}))]
\end{equation}
$$


<p>
This formula is called the trapezoidal formula, since it reduces to computing an integral with the trapezoidal rule if \( f(x,y) \) is only a function of \( x \). Since \( y_{n+1} \) appears on both sides of the equation, this is an implicit formula which means that we need to solve a system of non-linear algebraic equations if the function \( f(x,y) \) is non-linear. One way of making the scheme explicit is to use the Euler scheme \eqref{eq:1302} to calculate \( y(x_{n+1}) \) on the right side of \eqref{eq:1402}. The resulting scheme is often denoted <b>Heun's method</b>.

<p>
The scheme for Heun's method becomes
$$
\begin{align}
&y^p_{n+1}=y_n+h\cdot f(x_n,y_n) \label{eq:1403a} \\
&y_{n +1}=y_n+\frac{h}{2}\cdot[f(x_n,y_n)+f(x_{n+1},y^p_{n+1})]\label{eq:1403b}
\end{align}
$$

Index \( p \) stands for "predicted". \eqref{eq:1403a} is then the predictor and \eqref{eq:1403b} is the corrector. This is a second order method. For more details, see <a href="#cheney2012numerical">[4]</a>. Figure <a href="#fig:illustration_heun">5</a> is a graphical illustration of the method.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Illustration of Heun's method. <a name="fig:illustration_heun"></a> </p></center>
<p><img src="kap1/9.png" align="bottom" width=400></p>
</center>

<p>
In principle we could make an iteration procedure where we after using the corrector use the corrected values to correct the corrected values to make a new predictor and so on. This will likely lead to a more accurate solution of the difference scheme, but not necessarily of the differential equation. We are therefore satisfied by using the corrector once. For a system, we get
$$
\begin{align}
& \mathbf{y^p_{n+1}}=\mathbf{y_n}+h\cdot \mathbf{f}(x_n,\mathbf{y_n})\label{eq:1404a}\\
& \mathbf{y_{n+1}}=\mathbf{y_n} +\frac{h}{2}\cdot [\mathbf{f}(x_n,\mathbf{y_n})+\mathbf{f}(x_{n+1},\mathbf{y^p_{n+1}})]\label{eq:1404b}
\end{align}
$$

Note that \( \mathbf{y}^p_{n+1} \) is a temporary variable that is not necessary to store. 

<p>
If we use \eqref{eq:1404a} and \eqref{eq:1404b} on the example in \eqref{eq:13010} we get

<p>
Predictor:
$$
\begin{align*}
(y_1)^p_{n+1}&=(y_1)_n+h\cdot (y_2)_n&\\
(y_2)^p_{n+1}&=(y_2)_n+h\cdot (y_3)_n&\\
(y_3)^p_{n+1}&=(y_3)_n-h\cdot (y_1)_n\cdot (y_3)_n
\end{align*}
$$

Corrector:
$$
\begin{align*}
(y_1)_{n+1}&=(y_1)_n+0.5h\cdot [(y_2)_n+(y_2)^p_{n+1}]&\\
(y_2)_{n+1}&=(y_2)_n+0.5h\cdot [(y_3)_n+(y_3)^p_{n+1}]&\\
(y_3)_{n+1}&=(y_3)_n-0.5h\cdot [(y_1)_n\cdot (y_3)_n+(y_1)^p_{n+1}\cdot (y_3)^p_{n+1}]
\end{align*}
$$


<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec13">Example 4: Newton's equation <a name="___sec13"></a></h2>

Let's use Heun's method to solve Newton's equation from the section <a href="#section:introduction">Introduction</a>,
$$
\begin{equation}\label{eq:1405a}
y'(x)=1-3x+y+x^2+xy,\ y(0)=0
\end{equation}
$$

with analytical solution
$$
\DeclareMathOperator\erf{erf}
\begin{align}
y(x)=&3\sqrt{2\pi e}\cdot \exp\left(x\left(1+\frac{x}{2}\right)\right)\cdot \left[\erf\left(\frac{\sqrt{2}}{2}(1+x)\right)-\erf\left(\frac{\sqrt{2}}{2}\right)\right]\nonumber \\
	+&4\cdot \left[1-\exp\left(x\left(1+\frac{x}{2}\right)\right)\right]-x \label{eq:1405b}
\end{align}
$$


<p>
Here we have \( f(x,y)=1-3x+y+x^2+xy = 1+x(x-3)+(1+x)y \)

<p>
The following programme <b>NewtonHeun.py</b> solves this problem using Heun's method, and the resulting figure is shown in Figure <a href="#fig:newton_heun">6</a>.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># eks1_3/NewtonHeun.py</span>
<span style="color: #408080; font-style: italic"># Program Newton</span>
<span style="color: #408080; font-style: italic"># Computes the solution of Newton&#39;s 1st order equation (1671):</span>
<span style="color: #408080; font-style: italic"># dy/dx = 1-3*x + y + x^2 +x*y , y(0) = 0</span>
<span style="color: #408080; font-style: italic"># using Heun&#39;s method.</span>

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

xend <span style="color: #666666">=</span> <span style="color: #666666">2</span>
dx <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>int(np<span style="color: #666666">.</span>round(xend<span style="color: #666666">/</span>dx, <span style="color: #666666">0</span>)) <span style="color: #666666">+</span> <span style="color: #666666">1</span> 
y, x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((steps,<span style="color: #666666">1</span>), <span style="color: #008000">float</span>), np<span style="color: #666666">.</span>zeros((steps,<span style="color: #666666">1</span>), <span style="color: #008000">float</span>)
y[<span style="color: #666666">0</span>], x[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>, <span style="color: #666666">0.0</span>

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,steps<span style="color: #666666">-1</span>):
    x[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> (n<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>dx
    xn <span style="color: #666666">=</span> x[n]
    fn <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> xn<span style="color: #666666">*</span>(xn<span style="color: #666666">-3</span>) <span style="color: #666666">+</span> y[n]<span style="color: #666666">*</span>(<span style="color: #666666">1+</span>xn)
    yp <span style="color: #666666">=</span> y[n] <span style="color: #666666">+</span> dx<span style="color: #666666">*</span>fn    
    xnp1 <span style="color: #666666">=</span> x[n<span style="color: #666666">+1</span>]
    fnp1 <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> xnp1<span style="color: #666666">*</span>(xnp1<span style="color: #666666">-3</span>) <span style="color: #666666">+</span> yp<span style="color: #666666">*</span>(<span style="color: #666666">1+</span>xnp1)
    y[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> y[n] <span style="color: #666666">+</span> <span style="color: #666666">0.5*</span>dx<span style="color: #666666">*</span>(fn<span style="color: #666666">+</span>fnp1)

<span style="color: #408080; font-style: italic"># Analytical solution</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scipy.special</span> <span style="color: #008000; font-weight: bold">import</span> erf
a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">2</span>)<span style="color: #666666">/2</span>
t1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>exp(x<span style="color: #666666">*</span>(<span style="color: #666666">1+</span> x<span style="color: #666666">/2</span>))
t2 <span style="color: #666666">=</span> erf((<span style="color: #666666">1+</span>x)<span style="color: #666666">*</span>a)<span style="color: #666666">-</span>erf(a)
ya <span style="color: #666666">=</span> <span style="color: #666666">3*</span>np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>np<span style="color: #666666">.</span>exp(<span style="color: #666666">1</span>))<span style="color: #666666">*</span>t1<span style="color: #666666">*</span>t2 <span style="color: #666666">+</span> <span style="color: #666666">4*</span>(<span style="color: #666666">1-</span>t1)<span style="color: #666666">-</span>x

<span style="color: #408080; font-style: italic"># plotting</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pylab</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">py</span>
py<span style="color: #666666">.</span>plot(x, y, <span style="color: #BA2121">&#39;-b.&#39;</span>, x, ya, <span style="color: #BA2121">&#39;-g.&#39;</span>)
py<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>)
py<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;y&#39;</span>)
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}
py<span style="color: #666666">.</span>rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)
py<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Solution to Newton</span><span style="color: #BB6622; font-weight: bold">\&#39;</span><span style="color: #BA2121">s equation&#39;</span>)
py<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;Heun&#39;</span>, <span style="color: #BA2121">&#39;Analytical&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
py<span style="color: #666666">.</span>grid()
py<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;newton_heun.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
py<span style="color: #666666">.</span>show()
</pre></div>
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Velocity of falling sphere using Euler's and Heun's methods. <a name="fig:newton_heun"></a> </p></center>
<p><img src="kap1/eks1_3/newton_heun.png" align="bottom" width=400></p>
</center>

<p>
</div>
<!-- end box -->


<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="___sec14">Example 5: Falling sphere with Heun's method <a name="___sec14"></a></h2>

Let's go back to <a href="#ex:falling_sphere">Example 3: Falling sphere with constant and varying drag</a>, and implement a new function <code>heun()</code> in the programme <a href="https://raw.githubusercontent.com/lrhgit/tkt4140/master/allfiles/Utviklingsprosjekt/kap1/eks1_3/FallingSphereEuler.py" target="_blank">FallingSphereEuler.py</a>. 

<p>
We recall the system of equations as
$$
\begin{align*}
&\frac{dz}{dt}=v\\
&\frac{dv}{dt}=g-\alpha v^2
\end{align*}
$$

which by use of Heun's method in \eqref{eq:1404a} and \eqref{eq:1404b} becomes

<p>
Predictor:
$$
\begin{align}
z^p_{n+1}&=z_n+\Delta t v_n \\
v^p_{n+1}&= v_n +\Delta t \cdot (g-\alpha v^2_n) \nonumber
\end{align}
$$

Corrector:
$$
\begin{align}
z_{n+1}&=z_n+0.5\Delta t \cdot (v_n+v^p_{n+1}) \\
v_{n+1}&=v_n+0.5\Delta t \cdot \left[2g-\alpha[v^2_n+(v^p_{n+1})^2\right] \nonumber
\end{align}
$$

with initial values \( z_0=z(0)=0,\ v_0=v(0)=0 \). Note that we don't use the predictor \( z^p_{n+1} \) since it doesn't appear on the right hand side of the equation system. 

<p>
One possible way of implementing this scheme is given in the following function named <code>heun()</code>:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">heun</span>(func,z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Heun scheme for solution of systems of of ODEs. </span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions, </span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns </span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>
    
    dt <span style="color: #666666">=</span> time[<span style="color: #666666">1</span>]<span style="color: #666666">-</span>time[<span style="color: #666666">0</span>]
    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time),<span style="color: #666666">2</span>))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0
    zp <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z0)
    
    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">1</span>:]):
        zp <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> func(z[i,:],t)<span style="color: #666666">*</span>dt   <span style="color: #408080; font-style: italic"># Predictor step</span>
        z[i<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> (func(z[i,:],t) <span style="color: #666666">+</span> func(zp,t<span style="color: #666666">+</span>dt))<span style="color: #666666">*</span>dt<span style="color: #666666">/2.0</span> <span style="color: #408080; font-style: italic"># Corrector step</span>

    <span style="color: #008000; font-weight: bold">return</span> z
</pre></div>
<p>
Using the same time steps as in <a href="#ex:falling_sphere">Example 3: Falling sphere with constant and varying drag</a>, we get the response plotted in Figure <a href="#fig:falling_sphere_euler_heun">7</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 7:  Velocity of falling sphere using Euler's and Heun's methods. <a name="fig:falling_sphere_euler_heun"></a> </p></center>
<p><img src="kap1/eks1_3/example_sphere_falling_euler_heun.png" align="bottom" width=400></p>
</center>

<p>
The complete programme <b>FallingSphereEulerHeun.py</b> (may be downloaded <a href="https://raw.githubusercontent.com/lrhgit/tkt4140/master/allfiles/Utviklingsprosjekt/kap1/eks1_3/FallingSphereEulerHeun.py." target="_blank">here</a>) is listed below.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># eks1_3/FallingSphereEulerHeun.py</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>
sys<span style="color: #666666">.</span>path<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;../eks1_2&#39;</span>)
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">DragCoefficientGeneric</span> <span style="color: #008000; font-weight: bold">import</span> cd_sphere    
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

g <span style="color: #666666">=</span> <span style="color: #666666">9.81</span>      <span style="color: #408080; font-style: italic"># Gravity m/s^2</span>
d <span style="color: #666666">=</span> <span style="color: #666666">41.0e-3</span>   <span style="color: #408080; font-style: italic"># Diameter of the sphere</span>
rho_f <span style="color: #666666">=</span> <span style="color: #666666">1.22</span>  <span style="color: #408080; font-style: italic"># Density of fluid [kg/m^3]</span>
rho_s <span style="color: #666666">=</span> <span style="color: #666666">1275</span>  <span style="color: #408080; font-style: italic"># Density of sphere [kg/m^3]</span>
nu <span style="color: #666666">=</span> <span style="color: #666666">1.5e-5</span>   <span style="color: #408080; font-style: italic"># Kinematical viscosity [m^2/s]</span>
CD <span style="color: #666666">=</span> <span style="color: #666666">0.4</span>      <span style="color: #408080; font-style: italic"># Constant drag coefficient</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;2x2 system for sphere with constant drag.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    alpha <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)<span style="color: #666666">*</span>CD
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>], g <span style="color: #666666">-</span> alpha<span style="color: #666666">*</span>z[<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>]
    <span style="color: #008000; font-weight: bold">return</span> zout 

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f2</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;2x2 system for sphere with Re-dependent drag.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    v <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(z[<span style="color: #666666">1</span>]) 
    Re <span style="color: #666666">=</span> v<span style="color: #666666">*</span>d<span style="color: #666666">/</span>nu
    CD <span style="color: #666666">=</span> cd_sphere(Re)
    alpha <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)<span style="color: #666666">*</span>CD
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>], g <span style="color: #666666">-</span> alpha<span style="color: #666666">*</span>z[<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>]
    <span style="color: #008000; font-weight: bold">return</span> zout

<span style="color: #408080; font-style: italic"># define euler scheme</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">euler</span>(func,z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Euler scheme for solution of systems of of ODEs. </span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions, </span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns </span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>
    
    dt <span style="color: #666666">=</span> time[<span style="color: #666666">1</span>]<span style="color: #666666">-</span>time[<span style="color: #666666">0</span>]
    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time),<span style="color: #666666">2</span>))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">1</span>:]):
        z[i<span style="color: #666666">+1</span>,:]<span style="color: #666666">=</span>z[i,:] <span style="color: #666666">+</span> func(z[i,:],t)<span style="color: #666666">*</span>dt

    <span style="color: #008000; font-weight: bold">return</span> z

<span style="color: #408080; font-style: italic"># define heun scheme</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">heun</span>(func,z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Heun scheme for solution of systems of of ODEs. </span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions, </span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns </span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>
    
    dt <span style="color: #666666">=</span> time[<span style="color: #666666">1</span>]<span style="color: #666666">-</span>time[<span style="color: #666666">0</span>]
    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time),<span style="color: #666666">2</span>))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0
    zp <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z0)
    
    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">1</span>:]):
        zp <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> func(z[i,:],t)<span style="color: #666666">*</span>dt   <span style="color: #408080; font-style: italic"># Predictor step</span>
        z[i<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> (func(z[i,:],t) <span style="color: #666666">+</span> func(zp,t<span style="color: #666666">+</span>dt))<span style="color: #666666">*</span>dt<span style="color: #666666">/2.0</span> <span style="color: #408080; font-style: italic"># Corrector step</span>

    <span style="color: #008000; font-weight: bold">return</span> z
        
<span style="color: #408080; font-style: italic"># main program starts here</span>

T <span style="color: #666666">=</span> <span style="color: #666666">10</span>  <span style="color: #408080; font-style: italic"># end of simulation</span>
N <span style="color: #666666">=</span> <span style="color: #666666">20</span>  <span style="color: #408080; font-style: italic"># no of time steps</span>
time <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)

z0<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #666666">2</span>)
z0[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>

ze <span style="color: #666666">=</span> euler(f, z0, time)     <span style="color: #408080; font-style: italic"># compute response with constant CD using Euler&#39;s method</span>
ze2 <span style="color: #666666">=</span> euler(f2, z0, time)   <span style="color: #408080; font-style: italic"># compute response with varying CD using Euler&#39;s method</span>

zh <span style="color: #666666">=</span> heun(f, z0, time)     <span style="color: #408080; font-style: italic"># compute response with constant CD using Heun&#39;s method</span>
zh2 <span style="color: #666666">=</span> heun(f2, z0, time)   <span style="color: #408080; font-style: italic"># compute response with varying CD using Heun&#39;s method</span>

k1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(g<span style="color: #666666">*4*</span>rho_s<span style="color: #666666">*</span>d<span style="color: #666666">/</span>(<span style="color: #666666">3*</span>rho_f<span style="color: #666666">*</span>CD))
k2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">3*</span>rho_f<span style="color: #666666">*</span>g<span style="color: #666666">*</span>CD<span style="color: #666666">/</span>(<span style="color: #666666">4*</span>rho_s<span style="color: #666666">*</span>d))
v_a <span style="color: #666666">=</span> k1<span style="color: #666666">*</span>np<span style="color: #666666">.</span>tanh(k2<span style="color: #666666">*</span>time)   <span style="color: #408080; font-style: italic"># compute response with constant CD using analytical solution</span>

<span style="color: #408080; font-style: italic"># plotting</span>

legends<span style="color: #666666">=</span>[]
line_type<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;-&#39;</span>,<span style="color: #BA2121">&#39;:&#39;</span>,<span style="color: #BA2121">&#39;.&#39;</span>,<span style="color: #BA2121">&#39;-.&#39;</span>,<span style="color: #BA2121">&#39;--&#39;</span>]

plot(time, v_a, line_type[<span style="color: #666666">0</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Analytical (constant CD)&#39;</span>)

plot(time, ze[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">1</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Euler (constant CD)&#39;</span>)

plot(time, zh[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">2</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Heun (constant CD)&#39;</span>)

plot(time, ze2[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">3</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Euler (varying CD)&#39;</span>)

plot(time, zh2[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">4</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Heun (varying CD)&#39;</span>)

legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}
rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)
xlabel(<span style="color: #BA2121">&#39;Time [s]&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;Velocity [m/s]&#39;</span>)
savefig(<span style="color: #BA2121">&#39;example_sphere_falling_euler_heun.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
show()
</pre></div>
<p>
</div>
<!-- end box -->


<p>
<!-- --- end exercise --- -->

<h2 id="___sec15">Runge - Kutta of 4th order <a name="___sec15"></a></h2>

<!-- begin bibliography -->

<ol>
 <li> <a name="hairer2008solving"></a> <b>E. Hairer, S. P. Norsett and G. Wanner</b>. 
    <em>Solving Ordinary Differential Equations I: Nonstiff Problems</em>,
    Springer,
    2008.</li>
 <li> <a name="white1999fluid"></a> <b>F. White</b>. 
    <em>Fluid Mechanics</em>,
    WCB/McGraw-Hill,
    1999,
    <a href="http://books.google.no/books/about/Fluid_mechanics.html?id=fa_pAAAAMAAJ&redir_esc=y" target="_blank"><tt>http://books.google.no/books/about/Fluid_mechanics.html?id=fa_pAAAAMAAJ&redir_esc=y</tt></a>.</li>
 <li> <a name="evett19892"></a> <b>J. Evett and C. Liu</b>. 
    <em>2,500 Solved Problems in Fluid Mechanics and Hydraulics</em>,
    McGraw-Hill Education,
    1989,
    <a href="http://books.google.no/books?id=NBDjWHLKwSQC" target="_blank"><tt>http://books.google.no/books?id=NBDjWHLKwSQC</tt></a>.</li>
 <li> <a name="cheney2012numerical"></a> <b>E. Cheney and D. Kincaid</b>. 
    <em>Numerical Mathematics and Computing</em>,
    Cengage Learning,
    2012.</li>
</ol>

<!-- end bibliography -->

<p>

<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

