
# Information about all exercises in the file main.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Write the following ODE as a system of first order ODEs:\n!bt\n\\begin{align*}\ny'''-y'y''-(y')^2+2y=x^3 \\\\\ny(0)=a,\\ y'(0)=b,\\ y''(0)=c\n\\end{align*}\n\n!et\n\n#!bsol\nFirst we write $y'''=y'y''+(y')^2-2y+x^3$.\n\nBy use of \\eqref{eq:1128} we get\n!bt\n\\begin{align*}\n&y_1'=y_2\\\\\n&y_2'=y_3\\\\\n&y_3'=y_2y_3+(y_2)^2-2y_1+x^3\\\\\n&y_1(0)=a,\\ y_2(0)=b,\\ y_3=c\n\\end{align*}\n\n!et\n#!esol\n#!ec\n!ebox\n\n!bbox",
  'title': 'Reduction of higher order system',
  'type': 'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'example:sphere_freefall',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'FIGURE:[kap1/eks/2.png, width=200]\n\nThe figure shows a falling sphere with a diameter $d$ and mass $m$ that falls vertically in a fluid. Use of Newton\'s 2nd law in the $z$-direction gives\n!bt\n\\begin{equation}\\label{eq:newton_2nd_sphere}\nm\\frac{dv}{dt} = mg-m_fg-\\frac{1}{2}m_f\\frac{dv}{dt}-\\frac{1}{2}\\rho_fv\\left|v\\right|A_kC_D,\n\\end{equation}\n\n!et\nwhere the different terms are interpreted as follows: $m=\\rho_k V$, where $\\rho_f$ is the density of the sphere and $V$ is its volume, is the mass of the sphere. $m_f=\\rho_f V$, where $\\rho_f$ is the density of the fluid, is the mass of the displaced fluid. $m_fg=$ is the buoyancy. $C_D$ is the drag coefficient. $A_k$ is the area projection of the sphere $= \\frac{\\pi}{4}d^2$. $\\frac{1}{2}m_f$ is the hydrodynamical mass (added mass). The expression for the hydrodynamical mass is derived in White cite{white1999fluid}, page 539-540. \n\nWe introduce the following abbreviations:\n!bt\n\\begin{equation}\n\\rho=\\frac{\\rho_f}{\\rho_k},\\ A=1+\\frac{\\rho}{2}, \\ B=(1-\\rho)g,\\ C=\\frac{3\\rho}{4d}.\n\\end{equation}\n\n!et\nEquation \\eqref{eq:newton_2nd_sphere} may then be written as \n!bt\n\\begin{equation} \\label{eq:sphere_1st_order}\n\\frac{dv}{dt}=\\frac{1}{A}(B-C\\cdot v\\left|v\\right|C_d).\n\\end{equation}\n\n!et\n$C_D$ is found experimentally as a function of the Reynolds number $R_e = \\frac{vd}{\\nu}$, where $\\nu$ is the kinematical viscosity. \n\nFigure ref{fig:CDsphere} shows $C_D$ as a function of $Re$. The Python programme _CDsphere.py_ produces the plot from a curve fit to the data of Evett and Liu cite{evett19892}. The programme uses a function `cd_sphere` which is shown at the end of this example. The values in the plot are not as accurate as the number of digits in the programme might indicate. For example is the location and the size of the "valley" in the diagram strongly dependent of the degree of turbulence in the free stream and the roughness of the sphere. \n\nIn air we may often neglect the buoyancy term and the hydrodynamical mass. This should not be done for a liquid.\n\nIntroducing $v=\\frac{dz}{dt}$ in Equation \\eqref{eq:sphere_1st_order}, we get a 2nd order ODE as follows\n!bt\n\\begin{equation}\\label{eq:sphere_second_order}\n\\frac{d^2z}{dt^2}=\\frac{1}{A}\\left(B-C\\cdot \\frac{dz}{dt}\\bigg|\\frac{dz}{dt}\\bigg|C_d\\right)\n\\end{equation}\n\n!et\nFor Equation \\eqref{eq:sphere_second_order} two initial conditions must be specified, e.g. $v=v_0$ and $z=z_0$ for $t=0$. \n\nFIGURE:[kap1/eks/example_sphere.png, height=400 width=600] Drag coefficient $C_D$ as function of the Reynold\'s number $R_e$. label{fig:CDsphere}\n\n!bc pycod\ndef cd_sphere(Re):\n    "This function computes the drag coefficient of a sphere as a function of the Reynolds number Re."\n    # Curve fitted after fig. A-56 in Evett & Liu: "Fluid Mechanics & Hydraulics",\n    # Schaum\'s Solved Problems McGraw - Hill 1989.\n    \n    from numpy import log10, array, polyval\n    \n    if Re <= 0.0:\n        CD = 0.0\n    elif Re > 8.0e6:\n        CD = 0.2\n    elif Re > 0.0 and Re <= 0.5:\n        CD = 24.0/Re\n    elif Re > 0.5 and Re <= 100.0:\n        p = array([4.22, -14.05, 34.87, 0.658])\n        CD = polyval(p, 1.0/Re) \n    elif Re > 100.0 and Re <= 1.0e4:\n        p = array([-30.41, 43.72, -17.08, 2.41])\n        CD = polyval(p, 1.0/log10(Re))\n    elif Re > 1.0e4 and Re <= 3.35e5:\n        p = array([-0.1584, 2.031, -8.472, 11.932])\n        CD = polyval(p, log10(Re))\n    elif Re > 3.35e5 and Re <= 5.0e5:\n        x1 = log10(Re/4.5e5)\n        CD = 91.08*x1**4 + 0.0764\n    else:\n        p = array([-0.06338, 1.1905, -7.332, 14.93])\n        CD = polyval(p, log10(Re))\n    return CD\n\n# Calculate drag coefficient\nNpts = 500\nRe = logspace(-1, 7, Npts, True, 10)\nCD = zeros(Npts)\ni_list = range(0,Npts-1)\nfor i in i_list:\n    CD[i] = cd_sphere(Re[i])\n\n!ec\n\n!ebox\n\n=== Generating the plot in ref{example:sphere_freefall} ===\n\nThe complete programme _CDsphere.py_ used to generate the plot in the example above will now be presented. The programme may be downloaded "here": "https://raw.githubusercontent.com/lrhgit/tkt4140/master/allfiles/Utviklingsprosjekt/kap1/eks/CDsphere.py". We will break up the programme and explain the different parts. The complete programme is as follows:\n!bc pypro\n# eks12/CDsphere.py\n\nfrom numpy import logspace, zeros\n\n# Define the function cd_sphere\ndef cd_sphere(Re):\n    "This function computes the drag coefficient of a sphere as a function of the Reynolds number Re."\n    # Curve fitted after fig. A-56 in Evett & Liu: "Fluid Mechanics & Hydraulics",\n    # Schaum\'s Solved Problems McGraw - Hill 1989.\n    \n    from numpy import log10, array, polyval\n    \n    if Re <= 0.0:\n        CD = 0.0\n    elif Re > 8.0e6:\n        CD = 0.2\n    elif Re > 0.0 and Re <= 0.5:\n        CD = 24.0/Re\n    elif Re > 0.5 and Re <= 100.0:\n        p = array([4.22, -14.05, 34.87, 0.658])\n        CD = polyval(p, 1.0/Re) \n    elif Re > 100.0 and Re <= 1.0e4:\n        p = array([-30.41, 43.72, -17.08, 2.41])\n        CD = polyval(p, 1.0/log10(Re))\n    elif Re > 1.0e4 and Re <= 3.35e5:\n        p = array([-0.1584, 2.031, -8.472, 11.932])\n        CD = polyval(p, log10(Re))\n    elif Re > 3.35e5 and Re <= 5.0e5:\n        x1 = log10(Re/4.5e5)\n        CD = 91.08*x1**4 + 0.0764\n    else:\n        p = array([-0.06338, 1.1905, -7.332, 14.93])\n        CD = polyval(p, log10(Re))\n    return CD\n\n# Calculate drag coefficient\nNpts = 500\nRe = logspace(-1, 7, Npts, True, 10)\nCD = zeros(Npts)\ni_list = range(0,Npts-1)\nfor i in i_list:\n    CD[i] = cd_sphere(Re[i])\n\n# Make plot\nfrom matplotlib import pyplot\npyplot.plot(Re, CD, \'-b\')\nfont = {\'size\' : 16}\npyplot.rc(\'font\', **font)\npyplot.yscale(\'log\')\npyplot.xscale(\'log\')\npyplot.xlabel(\'$Re$\')\npyplot.ylabel(\'$C_D$\')\npyplot.grid(\'on\', \'both\', \'both\')\npyplot.savefig(\'example_sphere.png\', transparent=True)\npyplot.show()\n\n\n# End\n\n!ec\n\nIn the first code line, \n!bc pycod\nfrom numpy import logspace, zeros\n\n!ec\nthe functions `logspace` and `zeros` are imported from the package `numpy`. The `numpy` package (*NumPy* is an abbreviation for *Numerical Python*) enables the use of *array* objects. Using `numpy`  a wide range of mathematical operations can be done directly on complete arrays, thereby removing the need for loops over array elements. This is commonly called *vectorization* and may cause a dramatic increase in computational speed of Python programmes. The function `logspace` works on a logarithmic scale just as the function `linspace` works on a regular scale. The function `zeros` creates arrays of a certain size filled with zeros. Several comprehensive guides to the numpy package may be found at URL: "http://www.numpy.org". \n\nIn _CDsphere.py_ a function `cd_sphere` was defined as follows:\n!bc pycod\ndef cd_sphere(Re):\n    "This function computes the drag coefficient of a sphere as a function of the Reynolds number Re."\n    # Curve fitted after fig. A-56 in Evett & Liu: "Fluid Mechanics & Hydraulics",\n    # Schaum\'s Solved Problems McGraw - Hill 1989.\n    \n    from numpy import log10, array, polyval\n    \n    if Re <= 0.0:\n        CD = 0.0\n    elif Re > 8.0e6:\n        CD = 0.2\n    elif Re > 0.0 and Re <= 0.5:\n        CD = 24.0/Re\n    elif Re > 0.5 and Re <= 100.0:\n        p = array([4.22, -14.05, 34.87, 0.658])\n        CD = polyval(p, 1.0/Re) \n    elif Re > 100.0 and Re <= 1.0e4:\n        p = array([-30.41, 43.72, -17.08, 2.41])\n        CD = polyval(p, 1.0/log10(Re))\n    elif Re > 1.0e4 and Re <= 3.35e5:\n        p = array([-0.1584, 2.031, -8.472, 11.932])\n        CD = polyval(p, log10(Re))\n    elif Re > 3.35e5 and Re <= 5.0e5:\n        x1 = log10(Re/4.5e5)\n        CD = 91.08*x1**4 + 0.0764\n    else:\n        p = array([-0.06338, 1.1905, -7.332, 14.93])\n        CD = polyval(p, log10(Re))\n    return CD\n\n!ec\nThe function takes `Re` as an argument and returns the value `CD`. All Python functions begin with `def`, followed by the function name, and then inside parentheses a comma-separated list of function arguments, ended with a colon. Here we have only one argument `Re`. This argument acts as a standard variable inside the function. The statements to perform inside the function must be indented. At the end of a funciton it is common to use the `return` statement to return the value of the function. \n\nVariables defined inside a function, such as `p` and `x1` above, are *local* variables that cannot be accessed outside the function. Variables defined outside functions, in the "main programme", are *global* variables and may be accessed anywhere, also inside functions. \n\nThree more functions from the `numpy` package are imported in the function. They are not used oustide the function and are therefore chosen to be imported only if the function is called from the main programme. We refer to the "documentation of NumPy": "http://www.numpy.org" for details about the different functions. \n\nThe function above contains an example of the use of the `if-elif-else` block. The block begins with `if` and a boolean expression. If the boolean expression evaluates to `true` the *indented* statements following the `if` statement are carried out. If not, the boolean expression following the `elif` is evaluated. If none of the conditions are evaluated to `true` the statements following the `else` are carried out. \n\nIn the code block\n!bc pycod\nNpts = 500\nRe = logspace(-1, 7, Npts, True, 10)\nCD = zeros(Npts)\ni_list = range(0,Npts-1)\nfor i in i_list:\n    CD[i] = cd_sphere(Re[i])\n\n!ec\nthe function `cd_sphere` is called. First, the number of data points to be calculated are stored in the integer variable `Npts`. Using the `logspace` function imported earlier, `Re` is assigned an array objet which has float elements with values ranging from $10^{-1}$ to $10^7$. The values are uniformly distributed along a 10logarithmic scale. `CD` is first defined as an array with `Npts` zero elements, using the `zero` function. Then, for each element in `Re`, the drag coefficient is calculated using our own defined function `cd_sphere`, in a `for` loop, which is explained in the following.\n\nThe function `range` is a built-in function that generates a list containing arithmetic progressions. The `for i in i_list` construct creates a loop over all elements in `i_list`. In each pass of the loop, the variable `i` refers to an element in the list, starting with `i_list[0]` (0 in this case) and ending with the last element `i_list[Npts-1]` (499 in this case). Note that element indices start at 0 in Python. After the colon comes a block of statements which does something useful with the current element; in this case, the return of the function call `cd_sphere(Re[i])` is assigned to `CD[i]`. Each statement in the block must be indented. \n\nLastly, the drag coefficient is plotted and the figure generated:\n!bc pycod\nfrom matplotlib import pyplot\npyplot.plot(Re, CD, \'-b\')\nfont = {\'size\' : 16}\npyplot.rc(\'font\', **font)\npyplot.yscale(\'log\')\npyplot.xscale(\'log\')\npyplot.xlabel(\'$Re$\')\npyplot.ylabel(\'$C_D$\')\npyplot.grid(\'on\', \'both\', \'both\')\npyplot.savefig(\'example_sphere.png\', transparent=True)\npyplot.show()\n\n!ec\n\nTo generate the plot, the package `matplotlib` is used. `matplotlib` is the standard package for curve plotting in Python. For simple plotting the `matplotlib.pyplot` interface provides a MATLAB-like interface, which has been used here. For documentation and explanation of this package, we refer to URL: "http://www.matplotlib.org". \n\nFirst, the curve is generated using the function `plot`, which takes the x-values and y-values as arguments (`Re` and `CD` in this case), as well as a string specifying the line style, like in MATLAB. Then changes are made to the figure in order to make it more readable, very similarily to how it is done in MATLAB. For instance, in this case it makes sense to use logarithmic scales. A png version of the figure is saved using the `savefig` function. Lastly, the figure is showed on the screen with the `show` function. \n\nTo change the font size the function `rc` is used. This function takes in the object `font`, which is a *dictionary* object. Roughly speaking, a dictionary is a list where the index can be a text (in lists the index must be an integer). It is best to think of a dictionary as an unordered set of `key:value` pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: `{}`. Placing a comma-separated list of `key:value` pairs within the braces adds initial `key:value` pairs to the dictionary. In this case the dictionary `font` contains one `key:value` pair, namely `\'size\' : 16`.\n\nDescriptions and explanations of all functions available in `pyplot` may be found "here": "http://matplotlib.org/api/pyplot_summary.html".\n\n=== More efficient implementations ===\n\nWhen solving numerical problems variables are often not single numbers, but arrays containing many numbers. The function `CDsphere` above takes a single number in and gives a single number out. For computationally intensive algorithms where variables are stored in arrays this is inconvenient and time consuming, as each of the array elements must be sent to the function independently. It is therefore of interest to implement functions that can take in whole arrays and output whole arrays in an efficient manner. This may be done in a variaty of ways. Some possibilities are presented in the following, and, as we shall see, some are more time consuming than others. \n\nA simple extension of the single-valued function above is as follows:\n!bc pycod\ndef cd_sphere_py_vector(ReNrs):\n    CD = zeros_like(ReNrs)\n    counter = 0\n\n    for Re in ReNrs:\n        CD[counter] = cd_sphere(Re)\n        counter += 1\n    return CD\n\n!ec\n\nThe new function `cd_sphere_py_vector` takes in an array `ReNrs` and calculates the drag coefficient for each element using the previous function `cd_sphere`. This does the job, but is not very efficient. \n\nA second version is implemented in the function `cd_sphere_vector`. This function takes in the array `Re` and calculates the drag coefficient of all elements by multiple calls of the function `numpy.where`; one call for each condition, similarily as each `if` statement in the function `cd_sphere`. The function is shown here:\n\n!bc pycod\ndef cd_sphere_vector(Re):\n    "Computes the drag coefficient of a sphere as a function of the Reynolds number Re."\n    # Curve fitted after fig . A -56 in Evett & Liu :% " Fluid Mechanics & Hydraulics ",\n    # Schaum \' s Solved Problems McGraw - Hill 1989.\n\n    from numpy import log10,array,polyval,where,zeros_like\n    CD = zeros_like(Re)\n   \n    CD = where(Re<0,0.0,CD)     # condition 1\n    \n    CD = where((Re > 0.0) & (Re <=0.5),24/Re,CD) # condition 2\n\n    p = array([4.22,-14.05,34.87,0.658])\n    CD = where((Re > 0.5) & (Re <=100.0),polyval(p,1.0/Re),CD) #condition 3\n\n    p = array([-30.41,43.72,-17.08,2.41])\n    CD = where((Re >100.0)  & (Re <=1.0e4) ,polyval(p,1.0/log10(Re)),CD) #condition 4\n\n    p = array([-0.1584,2.031,-8.472,11.932])\n    CD = where((Re > 1.0e4)  &  (Re <=3.35e5),polyval(p,log10(Re)),CD) #condition 5\n\n    CD = where((Re > 3.35e5) & (Re <=5.0e5),91.08*(log10(Re/4.5e5))**4 + 0.0764,CD) #condition 6\n\n    p  = array([-0.06338,1.1905,-7.332,14.93])\n    CD = where((Re > 5.05e5)  &  (Re <=8.0e6),polyval(p,log10(Re)),CD) #condition 7\n    \n    CD = where(Re>8.0e6,0.2,CD)  # condition 8\n    return CD\n\n!ec\n\nA third approach we will try is using boolean type variables. The 8 variables `condition1` through `condition8` in the function `cd_sphere_vector_bool` are boolean variables of the same size and shape as `Re`. The elements of the boolean variables evaluate to either `True` or `False`, depending on if the corresponding element in `Re` satisfy the condition the variable is assigned. \n\n!bc pycod\ndef cd_sphere_vector_bool(Re):\n    from numpy import log10,array,polyval,zeros_like\n       \n    condition1 = Re < 0\n    condition2 = logical_and(0 < Re, Re <= 0.5)\n    condition3 = logical_and(0.5 < Re, Re <= 100.0)\n    condition4 = logical_and(100.0 < Re, Re <= 1.0e4)\n    condition5 = logical_and(1.0e4 < Re, Re <= 3.35e5)\n    condition6 = logical_and(3.35e5 < Re, Re <= 5.0e5)\n    condition7 = logical_and(5.0e5 < Re, Re <= 8.0e6)\n    condition8 = Re > 8.0e6\n    \n    CD = zeros_like(Re)\n    CD[condition1] = 0.0\n    \n    CD[condition2] = 24/Re[condition2]\n    \n    p = array([4.22,-14.05,34.87,0.658])\n    CD[condition3] = polyval(p,1.0/Re[condition3]) \n    \n    p = array([-30.41,43.72,-17.08,2.41])\n    CD[condition4] = polyval(p,1.0/log10(Re[condition4]))\n    \n    p = array([-0.1584,2.031,-8.472,11.932])\n    CD[condition5] = polyval(p,log10(Re[condition5]))\n    \n    CD[condition6] = 91.08*(log10(Re[condition6]/4.5e5))**4 + 0.0764\n    \n    p  = array([-0.06338,1.1905,-7.332,14.93])\n    CD[condition7] = polyval(p,log10(Re[condition7]))\n    \n    CD[condition8] = 0.2\n    \n    return CD\n\n!ec\n\nLastly, the built-in function `vectorize` is used to automatically generate a vector-version of the function `cd_sphere`, as follows:\n!bc pycod\ncd_sphere_auto_vector=vectorize(cd_sphere)\n\n!ec\n\nUsing the function `clock` in the module `time`, the cpu-time for each of the array-type functions described above has been measured for a test example. An array with 500 elements was sent to the functions. \n!bc\ncd_sphere_vector_bool   execution time = 0.000312\ncd_sphere_vector        execution time = 0.000641\ncd_sphere_auto_vector   execution time = 0.009497\ncd_sphere_py_vector     execution time = 0.010144\n\n!ec \nAs seen, the function with the boolean variables was fastest. The simple vectorized version of the original function was much slower, and the built-in function `vectorize` was nearly as inefficient.',
  'title': 'Sphere in free fall',
  'type': 'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'ex:falling_sphere',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We write \\eqref{eq:sphere_1st_order} and \\eqref{eq:sphere_second_order} as a sytem as follows,\n!bt\n\\begin{align}\n& \\frac{dz}{dt}=v\\label{eq:1303a}\\\\\n& \\frac{dv}{dt}=g-\\alpha v^2 \\label{eq:1303b}\n\\end{align}\n\n!et\nwhere\n!bt\n\\begin{equation*}\n\\alpha =\\frac{3\\rho _f}{4\\rho _k\\cdot d}\\cdot C_D\n\\end{equation*}\n\n!et\nThe analytical solution with $z(0)=0$ and $v(0)=0$ is given by\n!bt\n\\begin{equation} label{eq:1304a}\nv(t)=\\sqrt{\\frac{g}{\\alpha}}\\cdot \\tanh (\\sqrt{\\alpha g}\\cdot t), \\ z(t)=\\frac{\\ln(\\cosh(\\sqrt{\\alpha g}\\cdot t)}{\\alpha}\n\\end{equation}\n\n!et\nThe terminal velocity $v_t$ is found by $\\frac{dv}{dt}=0$ which gives $v_t=\\sqrt{\\frac{g}{\\alpha}}$. \n\nWe use data from a golf ball: $d= 41\\text{ mm}$, $\\rho_k = 1275 \\text{ kg/m}^3$, $\\rho_k = 1.22 \\text{ kg/m}^3$, and choose $C_D = 0.4$ which gives $\\alpha = 7\\cdot 10^{-3}$. The terminal velocity then becomes \n!bt\n\\begin{equation*}\nv_t = \\sqrt{\\frac{g}{\\alpha}} = 37.44\n\\end{equation*}\n\n!et\n\nIf we use Teylor\'s method from section ref{sec:taylor} we get the following expression by using four terms in the series expansion:\n!bt\n\\begin{align}\\label{eq:1305}\nz(t)=&\\frac{1}{2}gt^2\\cdot (1-\\frac{1}{6}\\alpha gt^2)\\\\\nv(t)=&g t\\cdot (1-\\frac{1}{3}\\alpha gt^2)\n\\end{align}\n\n!et\n\nThe Euler scheme \\eqref{eq:1302} used on \\eqref{eq:1303b} gives\n!bt\n\\begin{equation} \\label{eq:1306}\nv_{n+1}=v_n+\\Delta t\\cdot (g-\\alpha\\cdot v^2_n),\\ n=0,1,\\dots\n\\end{equation}\n\n!et\nwith $v(0)=0$.\n\nOne way of implementing the integration scheme is given in the following function `euler()`:\n!bc pycod\ndef euler(func,z0, time):\n    """The Euler scheme for solution of systems of of ODEs. \n    z0 is a vector for the initial conditions, \n    the right hand side of the system is represented by func which returns \n    a vector with the same size as z0 ."""\n    \n    dt = time[1]-time[0]\n    z = np.zeros((np.size(time),2))\n    z[0,:] = z0\n\n    for i, t in enumerate(time[1:]):\n        z[i+1,:]=z[i,:] + func(z[i,:],t)*dt\n\n    return z\n\n!ec\n\nThe programme _FallingSphereEuler.py_ (may be downloaded "here": "https://raw.githubusercontent.com/lrhgit/tkt4140/master/allfiles/Utviklingsprosjekt/kap1/eks/FallingSphereEuler.py") computes the solution for the first 10 seconds, using a time step of $\\Delta t=0.5$ s, and generates the plot in Figure ref{fig:faling_sphere_euler}. In addition to the case of constant drag coefficient, a solution for the case of varying $C_D$ is included. To find $C_D$ as function of velocity we use the function *cd_sphere()* that we implemented in ref{example:sphere_freefall}. The complete programme is as follows,\n\n!bc pypro\n# eks1_3/FallingSphereEuler.py\nimport sys\nsys.path.append(\'../eks1_2\')\nfrom DragCoefficientGeneric import cd_sphere    \nfrom matplotlib.pyplot import *\nimport numpy as np\n\ng = 9.81      # Gravity m/s^2\nd = 41.0e-3   # Diameter of the sphere\nrho_f = 1.22  # Density of fluid [kg/m^3]\nrho_s = 1275  # Density of sphere [kg/m^3]\nnu = 1.5e-5   # Kinematical viscosity [m^2/s]\nCD = 0.4      # Constant drag coefficient\n\ndef f(z, t):\n    """2x2 system for sphere with constant drag."""\n    zout = np.zeros_like(z)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout \n\ndef f2(z, t):\n    """2x2 system for sphere with Re-dependent drag."""\n    zout = np.zeros_like(z)\n    v = abs(z[1]) \n    Re = v*d/nu\n    CD = cd_sphere(Re)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout\n\n# define euler scheme\ndef euler(func,z0, time):\n    """The Euler scheme for solution of systems of of ODEs. \n    z0 is a vector for the initial conditions, \n    the right hand side of the system is represented by func which returns \n    a vector with the same size as z0 ."""\n    \n    dt = time[1]-time[0]\n    z = np.zeros((np.size(time),2))\n    z[0,:] = z0\n\n    for i, t in enumerate(time[1:]):\n        z[i+1,:]=z[i,:] + func(z[i,:],t)*dt\n\n    return z\n\n# main program starts here\n\nT = 10  # end of simulation\nN = 20  # no of time steps\ntime = np.linspace(0, T, N+1)\n\nz0=np.zeros(2)\nz0[0] = 2.0\n\nze = euler(f, z0, time)     # compute response with constant CD using Euler\'s method\nze2 = euler(f2, z0, time)   # compute response with varying CD using Euler\'s method\n\nk1 = np.sqrt(g*4*rho_s*d/(3*rho_f*CD))\nk2 = np.sqrt(3*rho_f*g*CD/(4*rho_s*d))\nv_a = k1*np.tanh(k2*time)   # compute response with constant CD using analytical solution\n\n# plotting\n\nlegends=[]\nline_type=[\'-\',\':\',\'.\',\'-.\',\'--\']\n\nplot(time, v_a, line_type[0])\nlegends.append(\'Analytical (constant CD)\')\n\nplot(time, ze[:,1], line_type[1])\nlegends.append(\'Euler (constant CD)\')\n\nplot(time, ze2[:,1], line_type[3])\nlegends.append(\'Euler (varying CD)\')\n\nlegend(legends, loc=\'best\', frameon=False)\nfont = {\'size\' : 16}\nrc(\'font\', **font)\nxlabel(\'Time [s]\')\nylabel(\'Velocity [m/s]\')\nsavefig(\'example_sphere_falling_euler.png\', transparent=True)\nshow()\n\n!ec\n\nFIGURE:[kap1/eks/example_sphere_falling_euler.png, width=400] Euler\'s method with $\\Delta t=0.5$ s. label{fig:faling_sphere_euler}\n\n!ebox\n\nEuler\'s method may of course also be used for a system. Let\'s look at a simultaneous system of $p$ equations\n!bt\n\\begin{align}\n&y\'_1=f_1(x,y_1,y_2,\\dots y_p) \\nonumber\\\\\n&y\'_2=f_2(x,y_1,y_2,\\dots y_p) \\nonumber\\\\\n&. \\label{eq:1307a}\\\\\n&.\\nonumber\\\\\n&y\'_p=f_p(x,y_1,y_2,\\dots y_p)\\nonumber\n\\end{align}\n\n!et\nwith initial values\n!bt\n\\begin{equation}\\label{eq:1307b}\ny_1(x_0)=a_1,\\ y_2(x_0)=a_2,\\dots,\\ y_p(x_0)=a_p \n\\end{equation}\n\n!et\nOr, in vectorial format as follows,\n!bt\n\\begin{align}\\label{eq:1308}\n\\mathbf{y\'}&=\\mathbf{f}(x,\\mathbf{y})\\\\\n\\mathbf{y}&(x_0)=\\mathbf{a} \\nonumber\n\\end{align}\n\n!et\nwhere $\\mathbf{y\'}$, $\\mathbf{f}$, $\\mathbf{y}$ and $\\mathbf{a}$ are column vectores with $p$ components. \n\nThe Euler scheme \\eqref{eq:1302} used on \\eqref{eq:1308} gives\n!bt\n\\begin{equation}\\label{eq:1309}\n\\mathbf{y_{n+1}}=\\mathbf{y_n}+h\\cdot \\mathbf{f}(x_n,\\mathbf{y_n})\n\\end{equation}\n\n!et\nFor a system of three equations we get\n!bt\n\\begin{align} \ny\'_1=&y_2\\nonumber\\\\\ny\'_2=&y_3\\label{eq:13010}\\\\\ny\'_3=&-y_1y_3\\nonumber\n\\end{align}\n\n!et\nIn this case \\eqref{eq:1309} gives\n!bt\n\\begin{align} \n&(y_1)_{n+1}=(y_1)_n+h\\cdot (y_2)_n\\nonumber\\\\\n&(y_2)_{n+1}=(y_2)_n+h\\cdot (y_3)_n\\label{eq:13011}\\\\\n&(y_3)_{n+1}=(y_3)_n-h\\cdot (y_1)_n\\cdot (y_3)_n\\nonumber\\\\\n\\end{align}\n\n!et\nwith $y_1(x_0)=a_1,\\ y_2(x_0)=a_2,\\text{ and }y_3(x_0)=a_3$\n\nIn section ref{subsec:reduction} we have seen how we can reduce a higher order ODE to a set of first order ODEs. In \\eqref{eq:1303a} and \\eqref{eq:1303b} we have the equation $\\frac{d^2z}{dt^2}=g-\\alpha\\cdot \\left(\\frac{dz}{dt}\\right)^2$ which we have reduced to a system as\n!bt\n\\begin{align*}\n\\frac{dz}{dt}= v&\\\\\n\\frac{dv}{dt}= g&-\\alpha\\cdot v^2\n\\end{align*}\n\n!et\nwhich gives an Euler scheme as follows,\n!bt\n\\begin{align*}\n&z_{n+1}=z_n+\\Delta t\\cdot v_n\\\\\n&v_{n+1}=n_n+\\Delta t\\cdot [g-\\alpha(v_n)^2]\\\\\n&\\text{med }z_0=0,\\ v_0=0\n\\end{align*}\n\n!et',
  'title': 'Falling sphere with constant and varying drag',
  'type': 'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Let's use Heun's method to solve Newton's equation from section ref{section:introduction},\n!bt\n\\begin{equation}\\label{eq:1405a}\ny'(x)=1-3x+y+x^2+xy,\\ y(0)=0\n\\end{equation}\n\n!et\nwith analytical solution\n!bt\n\\DeclareMathOperator\\erf{erf}\n\\begin{align}\ny(x)=&3\\sqrt{2\\pi e}\\cdot \\exp\\left(x\\left(1+\\frac{x}{2}\\right)\\right)\\cdot \\left[\\erf\\left(\\frac{\\sqrt{2}}{2}(1+x)\\right)-\\erf\\left(\\frac{\\sqrt{2}}{2}\\right)\\right]\\nonumber \\\\\n\t+&4\\cdot \\left[1-\\exp\\left(x\\left(1+\\frac{x}{2}\\right)\\right)\\right]-x \\label{eq:1405b}\n\\end{align}\n\n!et\n\nHere we have $f(x,y)=1-3x+y+x^2+xy = 1+x(x-3)+(1+x)y$\n\nThe following programme _NewtonHeun.py_ solves this problem using Heun's method, and the resulting figure is shown in Figure ref{fig:newton_heun}.\n\n!bc pypro\n# eks1_3/NewtonHeun.py\n# Program Newton\n# Computes the solution of Newton's 1st order equation (1671):\n# dy/dx = 1-3*x + y + x^2 +x*y , y(0) = 0\n# using Heun's method.\n\nimport numpy as np\n\nxend = 2\ndx = 0.1\nsteps = np.int(np.round(xend/dx, 0)) + 1 \ny, x = np.zeros((steps,1), float), np.zeros((steps,1), float)\ny[0], x[0] = 0.0, 0.0\n\nfor n in range(0,steps-1):\n    x[n+1] = (n+1)*dx\n    xn = x[n]\n    fn = 1 + xn*(xn-3) + y[n]*(1+xn)\n    yp = y[n] + dx*fn    \n    xnp1 = x[n+1]\n    fnp1 = 1 + xnp1*(xnp1-3) + yp*(1+xnp1)\n    y[n+1] = y[n] + 0.5*dx*(fn+fnp1)\n\n# Analytical solution\nfrom scipy.special import erf\na = np.sqrt(2)/2\nt1 = np.exp(x*(1+ x/2))\nt2 = erf((1+x)*a)-erf(a)\nya = 3*np.sqrt(2*np.pi*np.exp(1))*t1*t2 + 4*(1-t1)-x\n\n# plotting\nimport matplotlib.pylab as py\npy.plot(x, y, '-b.', x, ya, '-g.')\npy.xlabel('x')\npy.ylabel('y')\nfont = {'size' : 16}\npy.rc('font', **font)\npy.title('Solution to Newton\\'s equation')\npy.legend(['Heun', 'Analytical'], loc='best', frameon=False)\npy.grid()\npy.savefig('newton_heun.png', transparent=True)\npy.show()\n\n!ec\n\nFIGURE:[kap1/eks/newton_heun.png, width=400] Velocity of falling sphere using Euler's and Heun's methods. label{fig:newton_heun}\n\n!ebox\n\n!bbox",
  'title': "Newton's equation",
  'type': 'Example',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Let\'s go back to ref{ex:falling_sphere}, and implement a new function `heun()` in the programme "FallingSphereEuler.py": "https://raw.githubusercontent.com/lrhgit/tkt4140/master/allfiles/Utviklingsprosjekt/kap1/eks/FallingSphereEuler.py". \n\nWe recall the system of equations as\n!bt\n\\begin{align*}\n&\\frac{dz}{dt}=v\\\\\n&\\frac{dv}{dt}=g-\\alpha v^2\n\\end{align*}\n\n!et\nwhich by use of Heun\'s method in \\eqref{eq:1404a} and \\eqref{eq:1404b} becomes\n\nPredictor:\n!bt\n\\begin{align}\nz^p_{n+1}&=z_n+\\Delta t v_n \\\\\nv^p_{n+1}&= v_n +\\Delta t \\cdot (g-\\alpha v^2_n) \\nonumber\n\\end{align}\n\n!et\nCorrector:\n!bt\n\\begin{align}\nz_{n+1}&=z_n+0.5\\Delta t \\cdot (v_n+v^p_{n+1}) \\\\\nv_{n+1}&=v_n+0.5\\Delta t \\cdot \\left[2g-\\alpha[v^2_n+(v^p_{n+1})^2\\right] \\nonumber\n\\end{align}\n\n!et\nwith initial values $z_0=z(0)=0,\\ v_0=v(0)=0$. Note that we don\'t use the predictor $z^p_{n+1}$ since it doesn\'t appear on the right hand side of the equation system. \n\nOne possible way of implementing this scheme is given in the following function named `heun()`:\n!bc pycod\ndef heun(func,z0, time):\n    """The Heun scheme for solution of systems of of ODEs. \n    z0 is a vector for the initial conditions, \n    the right hand side of the system is represented by func which returns \n    a vector with the same size as z0 ."""\n    \n    dt = time[1]-time[0]\n    z = np.zeros((np.size(time),2))\n    z[0,:] = z0\n    zp = np.zeros_like(z0)\n    \n    for i, t in enumerate(time[1:]):\n        zp = z[i,:] + func(z[i,:],t)*dt   # Predictor step\n        z[i+1,:] = z[i,:] + (func(z[i,:],t) + func(zp,t+dt))*dt/2.0 # Corrector step\n\n    return z\n\n!ec\n\nUsing the same time steps as in ref{ex:falling_sphere}, we get the response plotted in Figure ref{fig:falling_sphere_euler_heun}.\n\nFIGURE:[kap1/eks/example_sphere_falling_euler_heun.png, width=400] Velocity of falling sphere using Euler\'s and Heun\'s methods. label{fig:falling_sphere_euler_heun}\n\nThe complete programme _FallingSphereEulerHeun.py_ (may be downloaded "here": "https://raw.githubusercontent.com/lrhgit/tkt4140/master/allfiles/Utviklingsprosjekt/kap1/eks/FallingSphereEulerHeun.py.") is listed below.\n\n!bc pypro\n# eks1_3/FallingSphereEulerHeun.py\nimport sys\nsys.path.append(\'../eks1_2\')\nfrom DragCoefficientGeneric import cd_sphere    \nfrom matplotlib.pyplot import *\nimport numpy as np\n\ng = 9.81      # Gravity m/s^2\nd = 41.0e-3   # Diameter of the sphere\nrho_f = 1.22  # Density of fluid [kg/m^3]\nrho_s = 1275  # Density of sphere [kg/m^3]\nnu = 1.5e-5   # Kinematical viscosity [m^2/s]\nCD = 0.4      # Constant drag coefficient\n\ndef f(z, t):\n    """2x2 system for sphere with constant drag."""\n    zout = np.zeros_like(z)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout \n\ndef f2(z, t):\n    """2x2 system for sphere with Re-dependent drag."""\n    zout = np.zeros_like(z)\n    v = abs(z[1]) \n    Re = v*d/nu\n    CD = cd_sphere(Re)\n    alpha = 3.0*rho_f/(4.0*rho_s*d)*CD\n    zout[:] = [z[1], g - alpha*z[1]**2]\n    return zout\n\n# define euler scheme\ndef euler(func,z0, time):\n    """The Euler scheme for solution of systems of of ODEs. \n    z0 is a vector for the initial conditions, \n    the right hand side of the system is represented by func which returns \n    a vector with the same size as z0 ."""\n    \n    dt = time[1]-time[0]\n    z = np.zeros((np.size(time),2))\n    z[0,:] = z0\n\n    for i, t in enumerate(time[1:]):\n        z[i+1,:]=z[i,:] + func(z[i,:],t)*dt\n\n    return z\n\n# define heun scheme\ndef heun(func,z0, time):\n    """The Heun scheme for solution of systems of of ODEs. \n    z0 is a vector for the initial conditions, \n    the right hand side of the system is represented by func which returns \n    a vector with the same size as z0 ."""\n    \n    dt = time[1]-time[0]\n    z = np.zeros((np.size(time),2))\n    z[0,:] = z0\n    zp = np.zeros_like(z0)\n    \n    for i, t in enumerate(time[1:]):\n        zp = z[i,:] + func(z[i,:],t)*dt   # Predictor step\n        z[i+1,:] = z[i,:] + (func(z[i,:],t) + func(zp,t+dt))*dt/2.0 # Corrector step\n\n    return z\n        \n# main program starts here\n\nT = 10  # end of simulation\nN = 20  # no of time steps\ntime = np.linspace(0, T, N+1)\n\nz0=np.zeros(2)\nz0[0] = 2.0\n\nze = euler(f, z0, time)     # compute response with constant CD using Euler\'s method\nze2 = euler(f2, z0, time)   # compute response with varying CD using Euler\'s method\n\nzh = heun(f, z0, time)     # compute response with constant CD using Heun\'s method\nzh2 = heun(f2, z0, time)   # compute response with varying CD using Heun\'s method\n\nk1 = np.sqrt(g*4*rho_s*d/(3*rho_f*CD))\nk2 = np.sqrt(3*rho_f*g*CD/(4*rho_s*d))\nv_a = k1*np.tanh(k2*time)   # compute response with constant CD using analytical solution\n\n# plotting\n\nlegends=[]\nline_type=[\'-\',\':\',\'.\',\'-.\',\'--\']\n\nplot(time, v_a, line_type[0])\nlegends.append(\'Analytical (constant CD)\')\n\nplot(time, ze[:,1], line_type[1])\nlegends.append(\'Euler (constant CD)\')\n\nplot(time, zh[:,1], line_type[2])\nlegends.append(\'Heun (constant CD)\')\n\nplot(time, ze2[:,1], line_type[3])\nlegends.append(\'Euler (varying CD)\')\n\nplot(time, zh2[:,1], line_type[4])\nlegends.append(\'Heun (varying CD)\')\n\nlegend(legends, loc=\'best\', frameon=False)\nfont = {\'size\' : 16}\nrc(\'font\', **font)\nxlabel(\'Time [s]\')\nylabel(\'Velocity [m/s]\')\nsavefig(\'example_sphere_falling_euler_heun.png\', transparent=True)\nshow()\n\n!ec\n\n\n\n!ebox',
  'title': "Falling sphere with Heun's method",
  'type': 'Example',
  'type_visible': True}]