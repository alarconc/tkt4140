<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Numerical Methods for Engineers">
<meta name="keywords" content="Trapesmetoden,steady-state,Partiel differential equations,Elliptic partrial differential equations,Boundary value problem,Elliptic equation,Stationary solutions,Stasjonære,Parabolske ligninger,Varmeledningsligningen,Jacobis metode,Gauss-Seidels metode,Relaksasjonsfaktor  $\omega$,Ikke-lineær ligning,Konvergens,Jacobis metode,Gauss-Seidels metode,Gauss-Seidels metode,Jacobis metode,PK-kriteriet,Courant-tallet">

<title>Numerical Methods for Engineers</title>

<!-- Bootstrap style: bootstrap_bluegray -->
<link href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_bootstrap/css/bootstrap_bluegray.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Introduction', 0, None, '___sec0'),
              (u'Scientific computing with Python', 1, None, '___sec1'),
              (u'Initial value problems for Ordinary Differential Equations',
               0,
               u'ch:1',
               u'ch:1'),
              (u'Introduction',
               1,
               u'section:introduction',
               u'section:introduction'),
              (u"Taylor's method", 1, u'sec:taylor', u'sec:taylor'),
              (u'Reduction of Higher order Equations',
               1,
               u'subsec:reduction',
               u'subsec:reduction'),
              (u'Example: Reduction of higher order systems',
               2,
               None,
               '___sec6'),
              (u'Example: Sphere in free fall',
               2,
               u'example:sphere_freefall',
               u'example:sphere_freefall'),
              (u'Python implementation of the drag coefficient function and how to plot it',
               3,
               None,
               '___sec8'),
              (u'Python functions with vector arguments and modules',
               1,
               None,
               '___sec9'),
              (u'How to make a Python-module and some useful programming features',
               1,
               u'section:Python_module',
               u'section:Python_module'),
              (u'Differences',
               1,
               u'ch1:sec:differences',
               u'ch1:sec:differences'),
              (u'Treatment of the term $\\frac{d}{dx} \\left[ p(x) \\frac{d}{dx} u(x)\\right]$',
               3,
               None,
               '___sec12'),
              (u"Euler's method", 1, u'ex:euler_method', u'ex:euler_method'),
              (u'Example: Falling sphere with constant and varying drag',
               2,
               u'ex:falling_sphere',
               u'ex:falling_sphere'),
              (u'Example: Numerical error as a function of $\\Delta t$',
               2,
               u'ex:num_error',
               u'ex:num_error'),
              (u"Euler's method for a system", 3, None, '___sec16'),
              (u"Heun's method", 1, None, '___sec17'),
              (u"Example: Newton's equation", 2, None, '___sec18'),
              (u"Example: Falling sphere with Heun's method",
               2,
               None,
               '___sec19'),
              (u'Runge-Kutta of 4th order', 1, None, '___sec20'),
              (u'Example: Falling sphere using RK4',
               2,
               u'example:falling_sphere_RK4',
               u'example:falling_sphere_RK4'),
              (u'Example: Particle motion in two dimensions',
               2,
               None,
               '___sec22'),
              (u'Example: Numerical error as  a function of $\\Delta t$ for ODE-schemes',
               2,
               None,
               '___sec23'),
              (u'Shooting Methods for Boundary Value Problems',
               0,
               u'ch:2',
               u'ch:2'),
              (u'Linear equations', 1, u'section:linear', u'section:linear'),
              (u'Example: Couette - Poiseuille str\xf8mning',
               2,
               u'ex:21',
               u'ex:21'),
              (u'Example: Bjelkes\xf8yle med konstant tverrsnitt',
               2,
               u'ex:22',
               u'ex:22'),
              (u'Example: Bjelkes\xf8yler med variabelt tverrsnitt',
               2,
               u'ex:23',
               u'ex:23'),
              (u'Ikke-line\xe6re ligninger', 1, u'ch2:sec2', u'ch2:sec2'),
              (u'Example: Stor nedb\xf8yning av kragbjelke',
               2,
               u'ex:24',
               u'ex:24'),
              (u'Litt om likedannhetsl\xf8sninger',
               1,
               u'ch2:sec3',
               u'ch2:sec3'),
              (u'Example: Frysing i vannledning', 2, u'ex:25', u'ex:25'),
              (u'Example: Stokes 1. problem', 2, u'ex:26', u'ex:26'),
              (u'Example: Blasius-ligningen', 2, u'ex:27', u'ex:27'),
              (u'Example:Falkner-Skan ligningen', 2, u'ex:28', u'ex:28'),
              (u'Skyting med to startbetingelser',
               1,
               u'ch2:sec4',
               u'ch2:sec4'),
              (u'Line\xe6re ligninger', 2, u'kap:241', u'kap:241'),
              (u'Example: Sylindrisk tank med v\xe6ske',
               2,
               u'ex:29',
               u'ex:29'),
              (u'Eksempel p\xe5 ikke-line\xe6re ligninger',
               2,
               u'kap:242',
               u'kap:242'),
              (u'Differansemetoder for ordin\xe6re differensialligninger',
               0,
               u'ch:3',
               u'ch:3'),
              (u'Tridiagonale algebraiske ligningsystem',
               1,
               u'ch3:sec1',
               u'ch3:sec1'),
              (u'Varmeledning', 1, u'ch3:sec2', u'ch3:sec2'),
              (u'Kj\xf8leribbe med konstant tverrsnitt',
               2,
               u'ch3:sec21',
               u'ch3:sec21'),
              (u'Ribbe med variabelt tverrsnitt',
               2,
               u'ch3:sec22',
               u'ch3:sec22'),
              (u'Example: Talleksempel for trapesprofilet',
               2,
               u'ex:31',
               u'ex:31'),
              (u'To-punktsmetode. Varmeveksler.',
               1,
               u'ch3:sec3',
               u'ch3:sec3'),
              (u'Example', 2, u'ex:32', u'ex:32'),
              (u'Example: Varmeveksler', 2, None, '___sec48'),
              (u'Example: Talleksempel', 2, None, '___sec49'),
              (u'Linearinsering av ikke-lin\xe6re algebraiske ligninger',
               1,
               u'ch3:sec4',
               u'ch3:sec4'),
              (u'Metoden med etterslep', 2, None, '___sec51'),
              (u'Newton-linearisering', 2, u'ch3:sec42', u'ch3:sec42'),
              (u'Example:', 2, u'ex:35', u'ex:35'),
              (u'Example:', 2, u'ex:36', u'ex:36'),
              (u'Example:', 2, u'ex:37', u'ex:37'),
              (u'Eksempler p\xe5 stoppkriterier',
               2,
               u'ch3:sec43',
               u'ch3:sec43'),
              (u'Ligninger p\xe5 delta-form', 2, u'ch3:sec44', u'ch3:sec44'),
              (u'Kvasilinearisering', 2, u'ch3:sec45', u'ch3:sec45'),
              (u'Example:', 2, None, '___sec59'),
              (u'L\xf8sning av Blasius ligning ved bruk av differansemetode',
               1,
               u'ch3:sec5',
               u'ch3:sec5'),
              (u'Deriverte randbetingelser', 1, u'ch3:sec6', u'ch3:sec6'),
              (u'Iterasjonsmetoder ved l\xf8sning av ODL',
               1,
               u'ch3:sec7',
               u'ch3:sec7'),
              (u'Elliptic partial differential equations',
               0,
               u'ch:7',
               u'ch:7'),
              (u'Introduction', 1, u'kap:71', u'kap:71'),
              (u'Direct numerical solution', 1, u'kap:72', u'kap:72'),
              (u'von Neumann boundary conditions', 2, u'kap:722', u'kap:722'),
              (u'Iteration methods for linear algebraic equation systems',
               1,
               u'kap:73',
               u'kap:73'),
              (u'EKSEMPLER', 2, u'kap:731', u'kap:731'),
              (u'Stoppkriterier', 3, None, '___sec69'),
              (u'Optimal relaksasjonsparameter', 3, None, '___sec70'),
              (u'Eksempel p\xe5 bruk av SOR', 3, None, '___sec71'),
              (u'Startverdier og randbetingelser', 3, None, '___sec72'),
              (u'Eksempel p\xe5 en ikke-line\xe6r ligning',
               3,
               None,
               '___sec73'),
              (u'KONVERGENSKRITERIER', 2, None, '___sec74'),
              (u'Eksempel ved bruk av Gauss-Seidels metode',
               3,
               None,
               '___sec75'),
              (u'UTNYTTELSE AV SYMMETRI', 2, u'kap:721', u'kap:721'),
              (u'Poisson-ligning', 3, None, '___sec77'),
              (u'Exercise 1: Symmetric solution',
               2,
               u'exercise:symmetry',
               u'exercise:symmetry'),
              (u'Diffusjonsproblemer', 0, u'ch:5', u'ch:5'),
              (u'Differanser. Notasjon', 1, u'ch5:sec1', u'ch5:sec1'),
              (u'Example:', 2, None, '___sec81'),
              (u'Diffusjonsligningen', 1, u'ch5:sec2', u'ch5:sec2'),
              (u'Introduction', 2, u'ch5:sec21', u'ch5:sec21'),
              (u'Ikke-stasjon\xe6r couette str\xf8mning',
               2,
               u'ch5:sec22',
               u'ch5:sec22'),
              (u'PK-kriteriet: Kriteriet om positive koeffisienter',
               2,
               u'ch5:sec23',
               u'ch5:sec23'),
              (u'Stabilitetsanalyse med von Neumanns medtode',
               1,
               u'ch5:sec3',
               u'ch5:sec3'),
              (u'Bruk av von Neumann kriteriet',
               2,
               u'ch5:sec31',
               u'ch5:sec31'),
              (u'Flere skjema for parabolske ligninger',
               1,
               u'ch5:sec4',
               u'ch5:sec4'),
              (u'Richardson-skjemaet (1910)', 2, u'ch5:sec41', u'ch5:sec41'),
              (u'Dufort-Frankel skjemaet (1953)',
               2,
               u'ch5:sec42',
               u'ch5:sec42'),
              (u'Crank-Nicolson skjemaet. $\\theta$-skjemaet',
               2,
               u'ch5:sec43',
               u'ch5:sec43'),
              (u'Von Neumanns generelle stabilitetsbetingelse',
               2,
               u'ch5:sec44',
               u'ch5:sec44'),
              (u'Trunkeringsfeil, konsistens og konvergens',
               1,
               u'ch5:sec5',
               u'ch5:sec5'),
              (u'Example', 2, None, '___sec94'),
              (u'Eksempler med radiell symmetri',
               1,
               u'ch5:sec6',
               u'ch5:sec6'),
              (u'Example: Oppstart av r\xf8rstr\xf8mning',
               2,
               u'ex:51',
               u'ex:51'),
              (u'Example: Avkj\xf8ling av kule', 2, u'ex:52', u'ex:52'),
              (u'Convection problems and hyperbolic PDEs',
               0,
               u'ch:6',
               u'ch:6'),
              (u'The advection equation',
               1,
               u'section:advection',
               u'section:advection'),
              (u'Forward in time central in space discretization',
               2,
               u'ch6:sec2',
               u'ch6:sec2'),
              (u'ftbs/upwind', 2, None, '___sec101'),
              (u'The Lax-Friedrich Scheme', 2, None, '___sec102'),
              (u'Lax Wendroff Schemes', 2, None, '___sec103'),
              (u'Lax-Wendroff for non-linear systems of hyperbolic PDEs',
               2,
               u'ch:6_Lax-Wendroff_nonlin',
               u'ch:6_Lax-Wendroff_nonlin'),
              (u'Code example for various schemes for the advection equation',
               2,
               None,
               '___sec105'),
              (u'Order analysis on various schemes for the advection equation',
               2,
               None,
               '___sec106'),
              (u'Separating spatial and temporal discretization error',
               3,
               None,
               '___sec107'),
              (u'Flux limiters', 2, None, '___sec108'),
              (u'Lax Wendroff limiters', 3, None, '___sec109'),
              (u'Example of Flux limiter schemes on a solution with continuos and discontinuous sections',
               3,
               None,
               '___sec110'),
              (u'Example: Burgers equation',
               1,
               u'examp:Burger',
               u'examp:Burger'),
              (u'upwind', 2, None, '___sec112'),
              (u'lax-Friedrich', 2, None, '___sec113'),
              (u'Lax-Wendroff', 2, None, '___sec114'),
              (u'MacCormack', 2, None, '___sec115'),
              (u'Method of Manufactured solution', 2, None, '___sec116'),
              (u'Sympolic computation with SymPy', 0, None, '___sec117'),
              (u'Introduction', 1, None, '___sec118'),
              (u'Basic features', 1, None, '___sec119'),
              (u'Symbols', 3, None, '___sec120'),
              (u'Matrices', 3, None, '___sec121'),
              (u'References', 0, None, '___sec122')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="main.html">Numerical Methods for Engineers</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#___sec0" style="font-size: 80%;">Introduction</a></li>
     <!-- navigation toc: --> <li><a href="#ch:1" style="font-size: 80%;">Initial value problems for Ordinary Differential Equations</a></li>
     <!-- navigation toc: --> <li><a href="#ch:2" style="font-size: 80%;">Shooting Methods for Boundary Value Problems</a></li>
     <!-- navigation toc: --> <li><a href="#ch:3" style="font-size: 80%;">Differansemetoder for ordinære differensialligninger</a></li>
     <!-- navigation toc: --> <li><a href="#ch:7" style="font-size: 80%;">Elliptic partial differential equations</a></li>
     <!-- navigation toc: --> <li><a href="#ch:5" style="font-size: 80%;">Diffusjonsproblemer</a></li>
     <!-- navigation toc: --> <li><a href="#ch:6" style="font-size: 80%;">Convection problems and hyperbolic PDEs</a></li>
     <!-- navigation toc: --> <li><a href="#___sec117" style="font-size: 80%;">Sympolic computation with SymPy</a></li>
     <!-- navigation toc: --> <li><a href="#___sec122" style="font-size: 80%;">References</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<!-- ------------------- main content ---------------------- -->

<p>


<div class="jumbotron">
<center><h1>Numerical Methods for Engineers</h1></center>  <!-- document title -->



<center><h1>A digital compendium</h1></center>  <!-- document title -->

<!-- AUTHOR: Johan Kolstø Sønstabø at Department of Structural Engineering, NTNU -->

<p>
<!-- author(s): Leif Rune Hellevik -->

<center>
<b>Leif Rune Hellevik</b> 
</center>

<p>
<!-- institution -->

<center><b>Department of Structural Engineering, NTNU</b></center>
<br>
<p>
<center><h4>Jan 4, 2016</h4></center> <!-- date -->
<br>

<h2>Table of contents</h2>

<p>
<a href="#___sec0"> Introduction </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> Scientific computing with Python </a><br>
<a href="#ch:1"> Initial value problems for Ordinary Differential Equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#section:introduction"> Introduction </a><br>
&nbsp; &nbsp; &nbsp; <a href="#sec:taylor"> Taylor's method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#subsec:reduction"> Reduction of Higher order Equations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec6"> Example: Reduction of higher order systems </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#example:sphere_freefall"> Example: Sphere in free fall </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec9"> Python functions with vector arguments and modules </a><br>
&nbsp; &nbsp; &nbsp; <a href="#section:Python_module"> How to make a Python-module and some useful programming features </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch1:sec:differences"> Differences </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ex:euler_method"> Euler's method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:falling_sphere"> Example: Falling sphere with constant and varying drag </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:num_error"> Example: Numerical error as a function of \( \Delta t \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec17"> Heun's method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec18"> Example: Newton's equation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec19"> Example: Falling sphere with Heun's method </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec20"> Runge-Kutta of 4th order </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#example:falling_sphere_RK4"> Example: Falling sphere using RK4 </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec22"> Example: Particle motion in two dimensions </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec23"> Example: Numerical error as  a function of \( \Delta t \) for ODE-schemes </a><br>
<a href="#ch:2"> Shooting Methods for Boundary Value Problems </a><br>
&nbsp; &nbsp; &nbsp; <a href="#section:linear"> Linear equations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:21"> Example: Couette - Poiseuille strømning </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:22"> Example: Bjelkesøyle med konstant tverrsnitt </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:23"> Example: Bjelkesøyler med variabelt tverrsnitt </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch2:sec2"> Ikke-lineære ligninger </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:24"> Example: Stor nedbøyning av kragbjelke </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch2:sec3"> Litt om likedannhetsløsninger </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:25"> Example: Frysing i vannledning </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:26"> Example: Stokes 1. problem </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:27"> Example: Blasius-ligningen </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:28"> Example:Falkner-Skan ligningen </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch2:sec4"> Skyting med to startbetingelser </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#kap:241"> Lineære ligninger </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:29"> Example: Sylindrisk tank med væske </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#kap:242"> Eksempel på ikke-lineære ligninger </a><br>
<a href="#ch:3"> Differansemetoder for ordinære differensialligninger  </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch3:sec1"> Tridiagonale algebraiske ligningsystem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch3:sec2"> Varmeledning </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch3:sec21"> Kjøleribbe med konstant tverrsnitt </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch3:sec22"> Ribbe med variabelt tverrsnitt </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:31"> Example: Talleksempel for trapesprofilet </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch3:sec3"> To-punktsmetode. Varmeveksler. </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:32"> Example </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec48"> Example: Varmeveksler </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec49"> Example: Talleksempel </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch3:sec4"> Linearinsering av ikke-linære algebraiske ligninger </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec51"> Metoden med etterslep </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch3:sec42"> Newton-linearisering </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:35"> Example: </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:36"> Example: </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:37"> Example: </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch3:sec43"> Eksempler på stoppkriterier </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch3:sec44"> Ligninger på delta-form </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch3:sec45"> Kvasilinearisering </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec59"> Example: </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch3:sec5"> Løsning av Blasius ligning ved bruk av differansemetode </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch3:sec6"> Deriverte randbetingelser </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch3:sec7"> Iterasjonsmetoder ved løsning av ODL </a><br>
<a href="#ch:7"> Elliptic partial differential equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#kap:71"> Introduction </a><br>
&nbsp; &nbsp; &nbsp; <a href="#kap:72"> Direct numerical solution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#kap:722"> von Neumann boundary conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#kap:73"> Iteration methods for linear algebraic equation systems </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#kap:731"> EKSEMPLER </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec74"> KONVERGENSKRITERIER </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#kap:721"> UTNYTTELSE AV SYMMETRI </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#exercise:symmetry"> Exercise 1: Symmetric solution </a><br>
<a href="#ch:5"> Diffusjonsproblemer </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch5:sec1"> Differanser. Notasjon </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec81"> Example: </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch5:sec2"> Diffusjonsligningen </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch5:sec21"> Introduction </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch5:sec22"> Ikke-stasjonær couette strømning </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch5:sec23"> PK-kriteriet: Kriteriet om positive koeffisienter </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch5:sec3"> Stabilitetsanalyse med von Neumanns medtode </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch5:sec31"> Bruk av von Neumann kriteriet </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch5:sec4"> Flere skjema for parabolske ligninger </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch5:sec41"> Richardson-skjemaet (1910) </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch5:sec42"> Dufort-Frankel skjemaet (1953) </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch5:sec43"> Crank-Nicolson skjemaet. \( \theta \)-skjemaet </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch5:sec44"> Von Neumanns generelle stabilitetsbetingelse </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch5:sec5"> Trunkeringsfeil, konsistens og konvergens </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec94"> Example </a><br>
&nbsp; &nbsp; &nbsp; <a href="#ch5:sec6"> Eksempler med radiell symmetri </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:51"> Example: Oppstart av rørstrømning </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ex:52"> Example: Avkjøling av kule </a><br>
<a href="#ch:6"> Convection problems and hyperbolic PDEs </a><br>
&nbsp; &nbsp; &nbsp; <a href="#section:advection"> The advection equation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch6:sec2"> Forward in time central in space discretization </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec101"> ftbs/upwind </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec102"> The Lax-Friedrich Scheme </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec103"> Lax Wendroff Schemes </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#ch:6_Lax-Wendroff_nonlin"> Lax-Wendroff for non-linear systems of hyperbolic PDEs </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec105"> Code example for various schemes for the advection equation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec106"> Order analysis on various schemes for the advection equation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec108"> Flux limiters </a><br>
&nbsp; &nbsp; &nbsp; <a href="#examp:Burger"> Example: Burgers equation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec112"> upwind </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec113"> lax-Friedrich </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec114"> Lax-Wendroff </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec115"> MacCormack </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec116"> Method of Manufactured solution </a><br>
<a href="#___sec117"> Sympolic computation with SymPy </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec118"> Introduction </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec119"> Basic features </a><br>
<a href="#___sec122"> References </a><br>
</p>
<p>
<!-- TKT4140 Numerical Methods with Computer Laboratory. -->

<p>
<!-- potential-jumbotron-button -->
</div> <!-- end jumbotron -->

<!-- !split -->

<p>

<center><h1 id="___sec0">Introduction </h1></center> <!-- chapter heading -->

<p>
This digital compendium is based on the first chapter of the
compendium <em>Numeriske Beregninger</em> by J.B. Aarseth. It's intended to
be used in the course TKT4140 Numerical Methods with Computer Laboratory at NTNU.

<p>
The development of the technical solutions for this digital compendium
results from collaborations with professor <a href="http://folk.uio.no/hpl/" target="_self">Hans Petter
Langtangen</a> at UiO (hpl@simula.no), who has
developed <a href="https://github.com/hplgit/doconce" target="_self">Doconce</a> for flexible
typesetting, and associate professor <a href="http://www.ntnu.edu/employees/hal" target="_self">Hallvard
Trætteberg</a> at IDI, NTNU
(hal@idi.ntnu.no), who has developed the webpage-parser which
identifies Python-code for integration in Eclipse IDEs (such as
LiClipse). The latter part of the development has been funded by the
project
<a href="https://www.ntnu.no/wiki/pages/viewpage.action?pageId=72646826" target="_self">IKTiSU.</a>

<h1 id="___sec1">Scientific computing with Python </h1>

<p>
In this course we will use the programming language <b>Python</b> to solve numerical problems. Students not familiar with Python are strongly recommended to work through the example <a href="http://lrhgit.github.io/tkt4140/allfiles/digital_compendium/python_intro/doc/src/bumpy.html" target="_self">Intro to scientific computing with Python</a> before proceeding. If you are familiar with <b>Matlab</b> the transfer to Python should not be a problem.

<p>
<!-- !split -->

<center><h1 id="ch:1">Initial value problems for Ordinary Differential Equations</h1></center> <!-- chapter heading -->

<h1 id="section:introduction">Introduction</h1>

<p>
With an initial value problem for an ordinary differential equation (ODE) we mean a problem where all boundary conditions are given for one and the same value of the independent variable. For a first order ODE we get e.g.
$$
\begin{align}
\label{eq:1101}
 y'(x)&=f(x,y) \\ 
y(x_0)&=a  \nonumber
\end{align}
$$

while for a second order ODE we get

$$
\begin{align}
\label{eq:1102}
y''(x)&=f(x,y,y') \\ 
y(x_0)&=a,\ y'(x_0) = b \nonumber
\end{align}
$$

A first order ODE, as shown in Equation \eqref{eq:1101}, will always be an <em>initial value problem</em>. For Equation \eqref{eq:1102}, on the other hand, we can for instance specify the boundary conditions as follows,
$$
\begin{align}
y(x_0)=a,\ y(x_1) = b \nonumber
\end{align}
$$

With these boundary conditions Equation \eqref{eq:1102} presents a <em>boundary value problem</em>. In many applications boundary value problems are more common than initial value problems. But the solution technique for initial value problems may often be applied to solve boundary value problems.

<p>
Both from an analytical and numerical viewpoint initial value problems are easier to solve than boundary value problems, and methods for solution of initial value problems are more developed than for boundary value problems.

<p>
If we are to solve an initial value problem of the type in Equation
\eqref{eq:1101}, we must first be sure that it has a solution. In
addition we will demand that this solution is unique, together the two criteria above lead to the following criteria:
<div class="alert alert-block alert-success alert-text-normal"><b></b>
<b>The criteria for existence and uniqueness</b>

<p>
A sufficient criteria for existence and uniqueness of a solution of the problem in Equation \eqref{eq:1101} is that both \( f(x,y) \) and \( \frac{\partial
f}{\partial y} \) are continuous in and around \( x_0 \).
</div>

For \eqref{eq:1102} this conditions becomes that \( f(x,y) \),
\( \frac{\partial f}{\partial y} \) and \( \frac{\partial f}{\partial y'} \)
are continuous in and around \( x_0 \). Similarly for higher order
equations.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b></b>
<b>Violation of the criteria for existence and uniqueness</b>
$$
\begin{equation}
y' = y^{\frac{1}{3}},\ y(0)=0 \nonumber
\label{_auto1}
\end{equation}
$$

Here \( f=y^\frac{1}{3} \) and \( \frac{\partial f}{\partial y}=\frac{1}{3y^\frac{2}{3}} \). \( f \) is continuous in \( x=0 \), but that's not the case for \( \frac{\partial f}{\partial y} \). It may be shown that this ODE has two solutions: \( y=0 \) and \( y=(\frac{2}{3}x)^\frac{2}{3} \). Hopefully this equation doesn't present a physical problem.
</div>

<b>A mathematical pendulum</b>
A problem of more interest is shown below.

<p>
<center><p><img src="fig-ch1/1.png" align="bottom" width=200></p></center>

<p>
The figure shows a mathematical pendulum where the motion is described by the following equation:
$$
\begin{align}
 \frac{\partial^2 \theta}{\partial \tau^2} + \frac{g}{l}\sin (\theta) = 0
\label{eq:1103a}\\ 
\theta (0) = \theta_0 ,\ \frac{d\theta}{d\tau}(0) = 0
\label{eq:1103b}
\end{align}
$$

We introduce a dimensionless time \( t \) given by \( t=\sqrt{\frac{g}{l}}\cdot\tau \) such that \eqref{eq:1103a} and \eqref{eq:1103b} may be written as
$$
\begin{align}
\label{eq:1104a}
\ddot{\theta}(t) + \sin (\theta (t)) = 0 \\ 
\theta (0) = \theta_0 ,\ \dot\theta (0) = 0
\label{eq:1104b}
\end{align}
$$

The dot denotes derivation with respect to the dimensionless time \( t \). For small displacements we can set \( \sin (\theta) \approx \theta \), such that \eqref{eq:1104a} and \eqref{eq:1104b} becomes
$$
\begin{align}
\label{eq:1105a}
\ddot\theta (t)& + \theta (t) = 0 \\ 
\theta (0)& = \theta_0 ,\ \dot\theta (0) = 0
\label{eq:1105b}
\end{align}
$$

<p>
The difference between \eqref{eq:1104a} and \eqref{eq:1105a} is that the latter is linear, while the first is non-linear. The analytical solution of Equations \eqref{eq:1104a} and \eqref{eq:1104b} is given in Appendix G.2. in the
<a href="./NumeriskeBeregninger.pdf" target="_self">compendium</a>. An \( n \)'th order linear ODE may be written on the form
$$
\begin{equation}
\label{eq:1106}
a_n(x)y^{(n)}(x)+a_{n-1}(x)y^{(n-1)}(x)+\cdots+a_1(x)y'(x)+a_0(x)y(x)=b(x)
\end{equation}
$$

where \( y^{(k)}, k=0,1,\dots n \) is referring to the \( k \)'th derivative and \( y^{(0)}(x)=y(x) \).

<p>
If one or more of the coefficients \( a_k \) also are functions of at least one \( y^{(k)},\ k = 0,1,\dots n \), the ODE is non-linear. From \eqref{eq:1106} it follows that \eqref{eq:1104a} is non-linear and \eqref{eq:1105a} is linear.

<p>
Analytical solutions of non-linear ODEs are rare, and except from some special types, there are no general ways of finding such solutions. Therefore non-linear equations must usually be solved numerically. In many cases this is also the case for linear equations. For instance it doesn't exist a method to solve the general second order linear ODE given by
$$
\begin{equation}
a_2(x)\cdot y''(x)+a_1(x)\cdot y'(x) +a_0(x)\cdot y(x) =b(x)\nonumber
\label{_auto2}
\end{equation}
$$

<p>
From a numerical point of view the main difference between linear and non-linear equations is the multitude of solutions that may arise when solving non-linear equations. In a linear ODE it will be evident from the equation if there are special critical points where the solution change character, while this is often not the case for non-linear equations.

<p>
For instance the equation \( y'(x)=y^2(x),\ y(0)=1 \) has the solution \( y(x)=\frac{1}{1-x} \) such that \( y(x) \to \infty  \) for \( x \to 1 \), which isn't evident from the equation itself.

<p>
<!-- !split -->

<h1 id="sec:taylor">Taylor's method</h1>
Taylor's formula for series expansion of a function \( f(x) \) around \( x_0 \) is given by
$$
\begin{equation}
f(x)=f(x_0)+(x-x_0)\cdot f'(x_0)+\frac{(x-x_0)^2}{2}f''(x_0)+\dots +\frac{(x-x_0)^n}{n !}f^{(n)}(x_0)+ \text{remainder} \nonumber
\label{_auto3}
\end{equation}
$$

Let's use this formula to find the first terms in the series expansion for \( \theta(t) \) around \( t=0 \) from the differential equation given in \eqref{eq:1105a}:
$$
\begin{align*}
&\ddot{\theta} (t) +\theta (t) = 0 \\ 
&\theta (0) = \theta_0,\  \dot{\theta}(0)=0
\end{align*}
$$

We set \( \theta(t) \approx \theta(0)+t\cdot\dot{\theta}(0)+\frac{t^2}{2}\ddot\theta(0)+\frac{t^3}{6}\dddot\theta(0)+\frac{t^4}{24}\theta^{(4)}(0) \). By use of the initial conditions \( \theta(0)=\theta_0,\ \dot\theta(0)=0 \) we get
$$
\begin{equation}
\theta(t)\approx\theta_0 +\frac{t^2}{2}\ddot\theta+\frac{t^3}{6}\dddot\theta(0)+\frac{t^4}{24}\theta^{(4)}(0)  \nonumber
\label{_auto4}
\end{equation}
$$

From the differential equation we have \( \ddot\theta(t)=-\theta(t)\to \ddot\theta(0)=-\theta(0)=-\theta_0 \)

<p>
By differentiation we get \( \dddot\theta(t)=-\dot\theta(t)\to \ddot\theta(0)=-\theta(0)=-\theta_0 \)

<p>
We now get
$$
\begin{equation}
\theta^{(4)}(t)=-\ddot\theta(t) \to \theta^{(4)}(0)=-\ddot\theta(0)=\theta_0 \nonumber
\label{_auto5}
\end{equation}
$$

Setting this into the expression for \( \theta(t) \) gives \( \theta(t)\approx \theta_0\left(1-\frac{t^2}{2}+\frac{t^4}{24}\right)=\theta_0\left(1-\frac{t^2}{2!}+\frac{t^4}{4!}\right) \)

<p>
If we include \( n \) terms, we get
$$
\begin{equation}
\theta(t)\approx \theta_0\cdot \left(1-\frac{t^2}{2!}+\frac{t^4}{4!}-\frac{t^6}{6!}+\dots+(-1)^n \frac{t^{2n}}{(2n)!}\right) \nonumber
\label{_auto6}
\end{equation}
$$

<p>
If we let \( n \to \infty \) we see that the parentheses give the series for \( \cos(t) \). In this case we have found the exact solution \( \theta(t)=\theta_0\cos(t) \) of the differential equation. Since this equation is linear we manage in this case to find a connection between the coefficients such that we recognize the series expansion of \( \cos(t) \).

<p>
Let's try the same procedure on the non-linear version \eqref{eq:1104a}
$$
\begin{align} \nonumber
\ddot{\theta}(t)& + \sin \left(\theta (t)\right) = 0 \\ 
\theta (0) &= \theta_0 ,\ \dot\theta (0) = 0 \nonumber
\end{align}
$$

We start in the same manner: \( \theta(t) \approx \theta(0)+\frac{t^2}{2}\ddot\theta(0)+\frac{t^3}{6}\dddot\theta(0)+\frac{t^4}{24}\theta^{(4)}(0) \).
From the differential equation we have \( \ddot\theta=-\sin (\theta) \to \ddot\theta(0)=-\sin(\theta_0) \), which by consecutive differentiation gives
$$
\begin{align}
&\dddot\theta=-\cos(\theta)\cdot\dot\theta \to \dddot\theta(0)=0 \nonumber \\ 
&\theta^{(4)}=\sin(\theta)\cdot\dot\theta^2-\cos(\theta)\cdot\ddot\theta \to \theta^{(4)}(0)=-\ddot\theta(0)\cos(\theta(0))=\sin(\theta_0)\cos(\theta_0) \nonumber
\end{align}
$$

Inserted above: \( \theta(t) \approx \theta_0 -\frac{t^2}{2}\sin(\theta_0) + \frac{t^4}{24} \sin (\theta_0) \cos (\theta_0) \).

<p>
We may include more terms, but this complicates the differentiation and it is hard to find any connection between the coefficients. When we have found an approximation for \( \theta(t) \) we can get an approximation for \( \dot\theta(t) \) by differentiation: \( \dot\theta(t) \approx -t\sin(\theta_0) + \frac{t^3}{8} \sin (\theta_0) \cos (\theta_0) \).

<p>
Series expansions are often useful around the starting point when we solve initial value problems. The technique may also be used on non-linear equations.

<p>
Symbolic mathematical programs like <b>Maple</b> and <b>Mathematica</b> do this easily.

<p>
We will end with one of the earliest known differential equations, which Newton solved with series expansion in 1671.
$$
\begin{equation*}
y'(x) =1-3x+y+x^2+xy,\ y(0)=0
\end{equation*}
$$

Series expansion around \( x=0 \) gives
$$
\begin{equation*}
y(x) \approx x\cdot y'(0)+ \frac{x^2}{2} y''(0)+\frac{x^3}{6}y'''(0)+\frac{x^4}{24}y^{(4)}(0)
\end{equation*}
$$

From the differential equation we get \( y'(0)=1 \). By consecutive differentiation we get
$$
\begin{equation*}
  \begin{array}{lclclcr}
    y''(x) &=&-3+y'+2x+xy'+y &\to& y''(0)&=&-2\\ 
    y'''(x)&=& y''+2+xy''+2y'  &\to& y'''(0)&=& 2\\ 
    y^{(4)}(x)&=&y'''+xy'''+3y'' &\to &y^{(4)}(0)&=&-4
  \end{array}
\end{equation*}
$$

Inserting above gives \( y(x) \approx x-x^2+\frac{x^3}{3}-\frac{x^4}{6} \).

<p>
Newton gave the following solution: \( y(x) \approx  x-x^2+\frac{x^3}{3}-\frac{x^4}{6}+ \frac{x^5}{30}-\frac{x^6}{45} \).

<p>
Now you can check if Newton calculated correctly. Today it is possible to give the solution on closed form with known functions as follows,
$$
\begin{align*}
y(x)=&3\sqrt{2\pi e}\cdot \exp\left[x\left(1+\frac{x}{2}\right)\right]\cdot \left[\text{erf}\left(\frac{\sqrt{2}}{2}(1+x)\right)-\text{erf}\left(\frac{\sqrt{2}}{2}\right)\right]\\ 
+& 4\cdot\left[1-\exp[x\left(1+\frac{x}{2}\right)\right]-x
\end{align*}
$$

<p>
Note the combination \( \sqrt{2\pi e} \). See Hairer et al. <a href="#hairer2008solving">[1]</a> section 1.2 for more details on classical differential equations.

<p>
<!-- !split -->

<h1 id="subsec:reduction">Reduction of Higher order Equations</h1>

<p>
When we are solving initial value problems, we usually need to write these as sets of first order equations, because most of the program packages require this.

<p>
Example: \( y''(x)+y(x)=0,\ y(0)=a_0,\ y'(0)=b_0 \)

<p>
We may for instance write this equation in a system as follows,
$$
\begin{align*}
y'(x)=&g(x)\\ 
g'(x)=&-y(x)\\ 
y(0)=&a_0,\  g(0)=b_0
\end{align*}
$$

<p>
Another example:
$$
\begin{align*}
&y'''(x)+2y''(x)-(y'(x))^2+2y(x)=x^2\\ 
&y(0)=a_0,\ y'(0)=b_0,\ y''(0)=c_0
\end{align*}
$$

We set \( y'(x)=g(x) \) and \( y''(x)=g'(x)=f(x) \), and the system may be written as
$$
\begin{align*}
y'(x)=&g(x)\\ 
g'(x)=&f(x)\\ 
f'(x)=&-2f(x)+(g(x))^2-2y(x)+x^2
\end{align*}
$$

with initial values \( y(0)=a_0,\ g(0)=b_0,\ f(0)=c_0 \).

<p>
This is fair enough for hand calculations, men when we use program packages a more systematic procedure is needed. Let's use the equation above as an example.

<p>
We start by renaming \( y \) to \( y_1 \). We then get the following procedure:
$$
\begin{align*}
y&'=y'_1=y_2\\ 
y&''=y''_1=y'_2=y_3
\end{align*}
$$

The system may then be written as
$$
\begin{align*}
y'_1(x)=&y_2(x)\\ 
y'_2(x)=&y_3(x)\\ 
y'_3(x)=&-2y_3(x)+(y_2(x))^2-2y_1(x)+x^2
\end{align*}
$$

with initial conditions \( y_1(0)=a_0,\ y_2(0)=b_0,\ y_3(0)=c_0 \).

<p>
The general procedure to reduce a higher order ODE to a system of first order ODEs becomes the following:

<p>
Given the equation
$$
\begin{align}
\label{eq:1127}
&y^{(m)}=f(x,y,y',y'',\dots,y^{(m-1)})\\ 
&y(x_0)=a_1,\ y'(x_0)=a_2,\ \dots,y^{(m-1)}(x_0)=a_m \nonumber\\ 
\label{_auto7}
\end{align}
$$

where
$$
\begin{align*}
y^{(m)}\equiv \frac{d^my}{dx^m}
\end{align*}
$$

with \( y=y_1 \), we set
$$
\begin{align}
&y'_1=y_2 \nonumber \\ \nonumber
&y'_2=y_3\\ \nonumber
&.\\ \label{eq:1128}
&.\\ \nonumber
&y'_{m-1}=y_m\\\nonumber\\\nonumber
&y_1(x_0)=a_1,y_2(x_0)=a_2,\dots,y_m(x_0)=a_m
\end{align}
$$

<h2 id="___sec6">Example: Reduction of higher order systems </h2>
Write the following ODE as a system of first order ODEs:
$$
\begin{align*}
y'''-y'y''-(y')^2+2y=x^3 \\ 
y(0)=a,\ y'(0)=b,\ y''(0)=c
\end{align*}
$$

<p>
<!-- !bsol -->
First we write \( y'''=y'y''+(y')^2-2y+x^3 \).

<p>
By use of \eqref{eq:1128} we get
$$
\begin{align*}
&y_1'=y_2\\ 
&y_2'=y_3\\ 
&y_3'=y_2y_3+(y_2)^2-2y_1+x^3\\ 
&y_1(0)=a,\ y_2(0)=b,\ y_3=c
\end{align*}
$$

<!-- !esol -->
<!-- !ec -->

<p>
<!-- !split -->

<h2 id="example:sphere_freefall">Example: Sphere in free fall</h2>

<p>
<center><p><img src="fig-ch1/2.png" align="bottom" width=200></p></center>

<p>
The figure shows a falling sphere with a diameter \( d \) and mass \( m \)
that falls vertically in a fluid. Use of Newton's 2nd law in the
\( z \)-direction gives
$$
\begin{equation}
\label{eq:newton_2nd_sphere}
m\frac{dv}{dt} = mg-m_fg-\frac{1}{2}m_f\frac{dv}{dt}-\frac{1}{2}\rho_fv\left|v\right|A_kC_D,
\end{equation}
$$

where the different terms are interpreted as follows: \( m=\rho_k V \),
where \( \rho_k \) is the density of the sphere and \( V \) is the sphere
volume.  The mass of the displaced fluid is given by \( m_f=\rho_f V \),
where \( \rho_f \) is the density of the fluid, whereas buoyancy and the
drag coefficient are expressed by \( m_f \, g \) and \( C_D \), respectively.
The projected area of the sphere is given by \( A_k = \frac{\pi}{4}d^2 \)
and \( \frac{1}{2}m_f \) is the hydro-dynamical mass (added mass). The
expression for the hydro-dynamical mass is derived in White
<a href="#white1999fluid">[2]</a>, page 539-540. To write Equation
\eqref{eq:newton_2nd_sphere} on a more convenient form we introduce the
following abbreviations:
$$
\begin{equation}
\rho=\frac{\rho_f}{\rho_k},\ A=1+\frac{\rho}{2}, \ B=(1-\rho)g,\ C=\frac{3\rho}{4d}.
\label{_auto8}
\end{equation}
$$

in addition to the drag coefficient \( C_D \) which is a function of the Reynolds number \( \displaystyle R_e = \frac{vd}{\nu} \), where \( \nu \) is the kinematical viscosity. Equation \eqref{eq:newton_2nd_sphere} may then be written as
$$
\begin{equation}
\label{eq:sphere_1st_order}
\frac{dv}{dt}=\frac{1}{A}(B-C\cdot v\left|v\right|C_d).
\end{equation}
$$

In air we may often neglect the buoyancy term and the hydro-dynamical
mass, whereas this is not the case for a liquid. Introducing
\( v=\frac{dz}{dt} \) in Equation \eqref{eq:sphere_1st_order}, we get a 2nd
order ODE as follows
$$
\begin{equation}
\label{eq:sphere_second_order}
\frac{d^2z}{dt^2}=\frac{1}{A}\left(B-C\cdot \frac{dz}{dt}\bigg|\frac{dz}{dt}\bigg|C_d\right)
\end{equation}
$$

For Equation \eqref{eq:sphere_second_order} two initial conditions must
be specified, e.g. \( v=v_0 \) and \( z=z_0 \) for \( t=0 \).

<p>
Figure <a href="#fig:CDsphere">1</a> illustrates \( C_D \) as a function of \( Re \). The values in the plot are not as accurate as the number of digits in the
program might indicate. For example is the location and the size of
the "valley" in the diagram strongly dependent of the degree of
turbulence in the free stream and the roughness of the sphere. As
the drag coefficient \( C_D \) is a function of the Reynolds number, it is
also a function of the solution \( v \) (i.e. the velocity) of the ODE in
Equation \eqref{eq:sphere_1st_order}. We will use the function
\( C_D(Re) \) as an example of how functions may be implemented in Python.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Drag coefficient \( C_D \) as function of the Reynold's number \( R_e \). <div id="fig:CDsphere"></div> </p></center>
<p><img src="fig-ch1/example_sphere.png" align="bottom" height=400 width=600></p>
</center>

<p>
<!-- @@@CODE ././src-ch1/CDsphere.py from-to: # Define the function cd_sphere@^# Make plot -->

<p>
<!-- !split  -->

<h3 id="___sec8">Python implementation of the drag coefficient function and how to plot it </h3>

<p>
The complete Python program <b>CDsphere.py</b> used to plot the drag
coefficient in the example above is listed below.  The program uses a
function <code>cd_sphere</code> which results from a curve fit to the data of
Evett and Liu <a href="#evett19892">[3]</a>. In our setting we will use this
function for two purposes, namely to demonstrate how functions and modules are
implemented in Python and finally use these functions in the solution of the ODE in Equations \eqref{eq:sphere_1st_order} and  \eqref{eq:sphere_second_order}.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter1/src-ch1/CDsphere.py</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> logspace, zeros

<span style="color: #408080; font-style: italic"># Define the function cd_sphere</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere</span>(Re):
    <span style="color: #BA2121">&quot;This function computes the drag coefficient of a sphere as a function of the Reynolds number Re.&quot;</span>
    <span style="color: #408080; font-style: italic"># Curve fitted after fig . A -56 in Evett and Liu: &quot;Fluid Mechanics and Hydraulics&quot;</span>
    
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log10, array, polyval
    
    <span style="color: #008000; font-weight: bold">if</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.0</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">8.0e6</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.0</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">24.0/</span>Re
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.5</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">100.0</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">4.22</span>, <span style="color: #666666">-14.05</span>, <span style="color: #666666">34.87</span>, <span style="color: #666666">0.658</span>])
        CD <span style="color: #666666">=</span> polyval(p, <span style="color: #666666">1.0/</span>Re) 
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">100.0</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">1.0e4</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-30.41</span>, <span style="color: #666666">43.72</span>, <span style="color: #666666">-17.08</span>, <span style="color: #666666">2.41</span>])
        CD <span style="color: #666666">=</span> polyval(p, <span style="color: #666666">1.0/</span>log10(Re))
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">1.0e4</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">3.35e5</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.1584</span>, <span style="color: #666666">2.031</span>, <span style="color: #666666">-8.472</span>, <span style="color: #666666">11.932</span>])
        CD <span style="color: #666666">=</span> polyval(p, log10(Re))
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">3.35e5</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">5.0e5</span>:
        x1 <span style="color: #666666">=</span> log10(Re<span style="color: #666666">/4.5e5</span>)
        CD <span style="color: #666666">=</span> <span style="color: #666666">91.08*</span>x1<span style="color: #666666">**4</span> <span style="color: #666666">+</span> <span style="color: #666666">0.0764</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.06338</span>, <span style="color: #666666">1.1905</span>, <span style="color: #666666">-7.332</span>, <span style="color: #666666">14.93</span>])
        CD <span style="color: #666666">=</span> polyval(p, log10(Re))
    <span style="color: #008000; font-weight: bold">return</span> CD

<span style="color: #408080; font-style: italic"># Calculate drag coefficient</span>
Npts <span style="color: #666666">=</span> <span style="color: #666666">500</span>
Re <span style="color: #666666">=</span> logspace(<span style="color: #666666">-1</span>, <span style="color: #666666">7</span>, Npts, <span style="color: #008000">True</span>, <span style="color: #666666">10</span>)
CD <span style="color: #666666">=</span> zeros(Npts)
i_list <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Npts<span style="color: #666666">-1</span>)
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> i_list:
    CD[i] <span style="color: #666666">=</span> cd_sphere(Re[i])

<span style="color: #408080; font-style: italic"># Make plot</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> pyplot
pyplot<span style="color: #666666">.</span>plot(Re, CD, <span style="color: #BA2121">&#39;-b&#39;</span>)
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}
pyplot<span style="color: #666666">.</span>rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)
pyplot<span style="color: #666666">.</span>yscale(<span style="color: #BA2121">&#39;log&#39;</span>)
pyplot<span style="color: #666666">.</span>xscale(<span style="color: #BA2121">&#39;log&#39;</span>)
pyplot<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;$Re$&#39;</span>)
pyplot<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;$C_D$&#39;</span>)
pyplot<span style="color: #666666">.</span>grid(<span style="color: #BA2121">&#39;on&#39;</span>, <span style="color: #BA2121">&#39;both&#39;</span>, <span style="color: #BA2121">&#39;both&#39;</span>)
pyplot<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;example_sphere.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
pyplot<span style="color: #666666">.</span>show()
</pre></div>
<p>
In the following, we will break up the program and explain the different parts. In the first code line,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> logspace, zeros
</pre></div>
<p>
the functions <code>logspace</code> and <code>zeros</code> are imported from the package <code>numpy</code>. The <code>numpy</code> package (<em>NumPy</em> is an abbreviation for <em>Numerical Python</em>) enables the use of <em>array</em> objects. Using <code>numpy</code>  a wide range of mathematical operations can be done directly on complete arrays, thereby removing the need for loops over array elements. This is commonly called <em>vectorization</em> and may cause a dramatic increase in computational speed of Python programs. The function <code>logspace</code> works on a logarithmic scale just as the function <code>linspace</code> works on a regular scale. The function <code>zeros</code> creates arrays of a certain size filled with zeros. Several comprehensive guides to the numpy package may be found at <a href="http://www.numpy.org" target="_self"><tt>http://www.numpy.org</tt></a>.

<p>
In <b>CDsphere.py</b> a function <code>cd_sphere</code> was defined as follows:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere</span>(Re):
    <span style="color: #BA2121">&quot;This function computes the drag coefficient of a sphere as a function of the Reynolds number Re.&quot;</span>
    <span style="color: #408080; font-style: italic"># Curve fitted after fig . A -56 in Evett and Liu: &quot;Fluid Mechanics and Hydraulics&quot;</span>
    
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log10, array, polyval
    
    <span style="color: #008000; font-weight: bold">if</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.0</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">8.0e6</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.0</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">24.0/</span>Re
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.5</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">100.0</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">4.22</span>, <span style="color: #666666">-14.05</span>, <span style="color: #666666">34.87</span>, <span style="color: #666666">0.658</span>])
        CD <span style="color: #666666">=</span> polyval(p, <span style="color: #666666">1.0/</span>Re) 
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">100.0</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">1.0e4</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-30.41</span>, <span style="color: #666666">43.72</span>, <span style="color: #666666">-17.08</span>, <span style="color: #666666">2.41</span>])
        CD <span style="color: #666666">=</span> polyval(p, <span style="color: #666666">1.0/</span>log10(Re))
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">1.0e4</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">3.35e5</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.1584</span>, <span style="color: #666666">2.031</span>, <span style="color: #666666">-8.472</span>, <span style="color: #666666">11.932</span>])
        CD <span style="color: #666666">=</span> polyval(p, log10(Re))
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">3.35e5</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">5.0e5</span>:
        x1 <span style="color: #666666">=</span> log10(Re<span style="color: #666666">/4.5e5</span>)
        CD <span style="color: #666666">=</span> <span style="color: #666666">91.08*</span>x1<span style="color: #666666">**4</span> <span style="color: #666666">+</span> <span style="color: #666666">0.0764</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.06338</span>, <span style="color: #666666">1.1905</span>, <span style="color: #666666">-7.332</span>, <span style="color: #666666">14.93</span>])
        CD <span style="color: #666666">=</span> polyval(p, log10(Re))
    <span style="color: #008000; font-weight: bold">return</span> CD
</pre></div>
<p>
The function takes <code>Re</code> as an argument and returns the value <code>CD</code>. All Python functions begin with <code>def</code>, followed by the function name, and then inside parentheses a comma-separated list of function arguments, ended with a colon. Here we have only one argument, <code>Re</code>. This argument acts as a standard variable inside the function. The statements to perform inside the function must be indented. At the end of a function it is common to use the <code>return</code> statement to return the value of the function.

<p>
Variables defined inside a function, such as <code>p</code> and <code>x1</code> above, are <em>local</em> variables that cannot be accessed outside the function. Variables defined outside functions, in the "main program", are <em>global</em> variables and may be accessed anywhere, also inside functions.

<p>
Three more functions from the <code>numpy</code> package are imported in the function. They are not used outside the function and are therefore chosen to be imported only if the function is called from the main program. We refer to the <a href="http://www.numpy.org" target="_self">documentation of NumPy</a> for details about the different functions.

<p>
The function above contains an example of the use of the <code>if-elif-else</code> block. The block begins with <code>if</code> and a boolean expression. If the boolean expression evaluates to <code>true</code> the <em>indented</em> statements following the <code>if</code> statement are carried out. If not, the boolean expression following the <code>elif</code> is evaluated. If none of the conditions are evaluated to <code>true</code> the statements following the <code>else</code> are carried out.

<p>
In the code block
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Npts <span style="color: #666666">=</span> <span style="color: #666666">500</span>
Re <span style="color: #666666">=</span> logspace(<span style="color: #666666">-1</span>, <span style="color: #666666">7</span>, Npts, <span style="color: #008000">True</span>, <span style="color: #666666">10</span>)
CD <span style="color: #666666">=</span> zeros(Npts)
i_list <span style="color: #666666">=</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Npts<span style="color: #666666">-1</span>)
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> i_list:
    CD[i] <span style="color: #666666">=</span> cd_sphere(Re[i])
</pre></div>
<p>
the function <code>cd_sphere</code> is called. First, the number of data points to be calculated are stored in the integer variable <code>Npts</code>. Using the <code>logspace</code> function imported earlier, <code>Re</code> is assigned an array object which has float elements with values ranging from \( 10^{-1} \) to \( 10^7 \). The values are uniformly distributed along a 10-logarithmic scale. <code>CD</code> is first defined as an array with <code>Npts</code> zero elements, using the <code>zero</code> function. Then, for each element in <code>Re</code>, the drag coefficient is calculated using our own defined function <code>cd_sphere</code>, in a <code>for</code> loop, which is explained in the following.

<p>
The function <code>range</code> is a built-in function that generates a list containing arithmetic progressions. The <code>for i in i_list</code> construct creates a loop over all elements in <code>i_list</code>. In each pass of the loop, the variable <code>i</code> refers to an element in the list, starting with <code>i_list[0]</code> (0 in this case) and ending with the last element <code>i_list[Npts-1]</code> (499 in this case). Note that element indices start at 0 in Python. After the colon comes a block of statements which does something useful with the current element; in this case, the return of the function call <code>cd_sphere(Re[i])</code> is assigned to <code>CD[i]</code>. Each statement in the block must be indented.

<p>
Lastly, the drag coefficient is plotted and the figure generated:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> pyplot
pyplot<span style="color: #666666">.</span>plot(Re, CD, <span style="color: #BA2121">&#39;-b&#39;</span>)
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}
pyplot<span style="color: #666666">.</span>rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)
pyplot<span style="color: #666666">.</span>yscale(<span style="color: #BA2121">&#39;log&#39;</span>)
pyplot<span style="color: #666666">.</span>xscale(<span style="color: #BA2121">&#39;log&#39;</span>)
pyplot<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;$Re$&#39;</span>)
pyplot<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;$C_D$&#39;</span>)
pyplot<span style="color: #666666">.</span>grid(<span style="color: #BA2121">&#39;on&#39;</span>, <span style="color: #BA2121">&#39;both&#39;</span>, <span style="color: #BA2121">&#39;both&#39;</span>)
pyplot<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;example_sphere.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
pyplot<span style="color: #666666">.</span>show()
</pre></div>
<p>
To generate the plot, the package <code>matplotlib</code> is used. <code>matplotlib</code> is the standard package for curve plotting in Python. For simple plotting the <code>matplotlib.pyplot</code> interface provides a Matlab-like interface, which has been used here. For documentation and explanation of this package, we refer to <a href="http://www.matplotlib.org" target="_self"><tt>http://www.matplotlib.org</tt></a>.

<p>
First, the curve is generated using the function <code>plot</code>, which takes the x-values and y-values as arguments (<code>Re</code> and <code>CD</code> in this case), as well as a string specifying the line style, like in Matlab. Then changes are made to the figure in order to make it more readable, very similarly to how it is done in Matlab. For instance, in this case it makes sense to use logarithmic scales. A png version of the figure is saved using the <code>savefig</code> function. Lastly, the figure is showed on the screen with the <code>show</code> function.

<p>
To change the font size the function <code>rc</code> is used. This function takes in the object <code>font</code>, which is a <em>dictionary</em> object. Roughly speaking, a dictionary is a list where the index can be a text (in lists the index must be an integer). It is best to think of a dictionary as an unordered set of <code>key:value</code> pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: <code>{}</code>. Placing a comma-separated list of <code>key:value</code> pairs within the braces adds initial <code>key:value</code> pairs to the dictionary. In this case the dictionary <code>font</code> contains one <code>key:value</code> pair, namely <code>'size' : 16</code>.

<p>
Descriptions and explanations of all functions available in <code>pyplot</code> may be found <a href="http://matplotlib.org/api/pyplot_summary.html" target="_self">here</a>.

<p>
<!-- !split -->

<h1 id="___sec9">Python functions with vector arguments and modules </h1>

<p>
For many numerical problems variables are most conveniently expressed
by arrays containing many numbers (i.e. vectors) rather than single
numbers (i.e. scalars). The function <code>cd_sphere</code> above takes a scalar
as an argument and returns a scalar value too. For computationally
intensive algorithms where variables are stored in arrays this is
inconvenient and time consuming, as each of the array elements must be
sent to the function independently. In the following, we will
therefore show how to implement functions with vector arguments that
also return vectors. This may be done in various ways. Some
possibilities are presented in the following, and, as we shall see,
some are more time consuming than others. We will also demonstrate how
the time consumption (or efficiency) may be tested.

<p>
A simple extension of the single-valued function <code>cd_sphere</code> is as follows:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere_py_vector</span>(ReNrs):
    CD <span style="color: #666666">=</span> zeros_like(ReNrs)
    counter <span style="color: #666666">=</span> <span style="color: #666666">0</span>

    <span style="color: #008000; font-weight: bold">for</span> Re <span style="color: #AA22FF; font-weight: bold">in</span> ReNrs:
        CD[counter] <span style="color: #666666">=</span> cd_sphere(Re)
        counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">return</span> CD
</pre></div>
<p>
The new function <code>cd_sphere_py_vector</code> takes in an array <code>ReNrs</code> and
calculates the drag coefficient for each element using the previous
function <code>cd_sphere</code>. This does the job, but is not very efficient.

<p>
A second version is implemented in the function
<code>cd_sphere_vector</code>. This function takes in the array <code>Re</code> and
calculates the drag coefficient of all elements by multiple calls of
the function <code>numpy.where</code>; one call for each condition, similarly as
each <code>if</code> statement in the function <code>cd_sphere</code>. The function is shown
here:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere_vector</span>(Re):
    <span style="color: #BA2121">&quot;Computes the drag coefficient of a sphere as a function of the Reynolds number Re.&quot;</span>
    <span style="color: #408080; font-style: italic"># Curve fitted after fig . A -56 in Evett and Liu: &quot;Fluid Mechanics and Hydraulics&quot;</span>

    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log10, array, polyval, where, zeros_like
    CD <span style="color: #666666">=</span> zeros_like(Re)
   
    CD <span style="color: #666666">=</span> where(Re <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>, <span style="color: #666666">0.0</span>, CD)     <span style="color: #408080; font-style: italic"># condition 1</span>
    
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.0</span>) <span style="color: #666666">&amp;</span> (Re <span style="color: #666666">&lt;=0.5</span>), <span style="color: #666666">24/</span>Re, CD) <span style="color: #408080; font-style: italic"># condition 2</span>

    p <span style="color: #666666">=</span> array([<span style="color: #666666">4.22</span>, <span style="color: #666666">-14.05</span>, <span style="color: #666666">34.87</span>, <span style="color: #666666">0.658</span>])
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.5</span>) <span style="color: #666666">&amp;</span> (Re <span style="color: #666666">&lt;=100.0</span>), polyval(p, <span style="color: #666666">1.0/</span>Re), CD) <span style="color: #408080; font-style: italic">#condition 3</span>

    p <span style="color: #666666">=</span> array([<span style="color: #666666">-30.41</span>, <span style="color: #666666">43.72</span>, <span style="color: #666666">-17.08</span>, <span style="color: #666666">2.41</span>])
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">100.0</span>)  <span style="color: #666666">&amp;</span> (Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">1.0e4</span>), polyval(p, <span style="color: #666666">1.0/</span>log10(Re)), CD) <span style="color: #408080; font-style: italic">#condition 4</span>

    p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.1584</span>, <span style="color: #666666">2.031</span>, <span style="color: #666666">-8.472</span>, <span style="color: #666666">11.932</span>])
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">1.0e4</span>)  <span style="color: #666666">&amp;</span>  (Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">3.35e5</span>), polyval(p, log10(Re)), CD) <span style="color: #408080; font-style: italic">#condition 5</span>

    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">3.35e5</span>) <span style="color: #666666">&amp;</span> (Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">5.0e5</span>), <span style="color: #666666">91.08*</span>(log10(Re<span style="color: #666666">/4.5e5</span>))<span style="color: #666666">**4</span> <span style="color: #666666">+</span> <span style="color: #666666">0.0764</span>, CD) <span style="color: #408080; font-style: italic">#condition 6</span>

    p  <span style="color: #666666">=</span> array([<span style="color: #666666">-0.06338</span>, <span style="color: #666666">1.1905</span>, <span style="color: #666666">-7.332</span>, <span style="color: #666666">14.93</span>])
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">5.05e5</span>)  <span style="color: #666666">&amp;</span>  (Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">8.0e6</span>), polyval(p, log10(Re)), CD) <span style="color: #408080; font-style: italic">#condition 7</span>
    
    CD <span style="color: #666666">=</span> where(Re <span style="color: #666666">&gt;</span> <span style="color: #666666">8.0e6</span>, <span style="color: #666666">0.2</span>, CD)  <span style="color: #408080; font-style: italic"># condition 8</span>
    <span style="color: #008000; font-weight: bold">return</span> CD
</pre></div>
<p>
A third approach we will try is using boolean type variables. The 8
variables <code>condition1</code> through <code>condition8</code> in the function
<code>cd_sphere_vector_bool</code> are boolean variables of the same size and
shape as <code>Re</code>. The elements of the boolean variables evaluate to
either <code>True</code> or <code>False</code>, depending on if the corresponding element in
<code>Re</code> satisfy the condition the variable is assigned.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere_vector_bool</span>(Re):
    <span style="color: #BA2121">&quot;Computes the drag coefficient of a sphere as a function of the Reynolds number Re.&quot;</span>
    <span style="color: #408080; font-style: italic"># Curve fitted after fig . A -56 in Evett and Liu: &quot;Fluid Mechanics and Hydraulics&quot;</span>
    
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log10, array, polyval, zeros_like
       
    condition1 <span style="color: #666666">=</span> Re <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>
    condition2 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">0</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span>)
    condition3 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">0.5</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">100.0</span>)
    condition4 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">100.0</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">1.0e4</span>)
    condition5 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">1.0e4</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">3.35e5</span>)
    condition6 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">3.35e5</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">5.0e5</span>)
    condition7 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">5.0e5</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">8.0e6</span>)
    condition8 <span style="color: #666666">=</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">8.0e6</span>
    
    CD <span style="color: #666666">=</span> zeros_like(Re)
    CD[condition1] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    
    CD[condition2] <span style="color: #666666">=</span> <span style="color: #666666">24/</span>Re[condition2]
    
    p <span style="color: #666666">=</span> array([<span style="color: #666666">4.22</span>,<span style="color: #666666">-14.05</span>,<span style="color: #666666">34.87</span>,<span style="color: #666666">0.658</span>])
    CD[condition3] <span style="color: #666666">=</span> polyval(p,<span style="color: #666666">1.0/</span>Re[condition3]) 
    
    p <span style="color: #666666">=</span> array([<span style="color: #666666">-30.41</span>,<span style="color: #666666">43.72</span>,<span style="color: #666666">-17.08</span>,<span style="color: #666666">2.41</span>])
    CD[condition4] <span style="color: #666666">=</span> polyval(p,<span style="color: #666666">1.0/</span>log10(Re[condition4]))
    
    p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.1584</span>,<span style="color: #666666">2.031</span>,<span style="color: #666666">-8.472</span>,<span style="color: #666666">11.932</span>])
    CD[condition5] <span style="color: #666666">=</span> polyval(p,log10(Re[condition5]))
    
    CD[condition6] <span style="color: #666666">=</span> <span style="color: #666666">91.08*</span>(log10(Re[condition6]<span style="color: #666666">/4.5e5</span>))<span style="color: #666666">**4</span> <span style="color: #666666">+</span> <span style="color: #666666">0.0764</span>
    
    p  <span style="color: #666666">=</span> array([<span style="color: #666666">-0.06338</span>,<span style="color: #666666">1.1905</span>,<span style="color: #666666">-7.332</span>,<span style="color: #666666">14.93</span>])
    CD[condition7] <span style="color: #666666">=</span> polyval(p,log10(Re[condition7]))
    
    CD[condition8] <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
    
    <span style="color: #008000; font-weight: bold">return</span> CD
</pre></div>
<p>
Lastly, the built-in function <code>vectorize</code> is used to automatically
generate a vector-version of the function <code>cd_sphere</code>, as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">cd_sphere_auto_vector <span style="color: #666666">=</span> vectorize(cd_sphere)
</pre></div>
<p>
To provide a convenient and practical means to compare the various
implementations of the drag function, we have collected them all in a
file <b>DragCoefficientGeneric.py</b>. This file constitutes a Python module which is a concept we will discuss in the section <a href="#section:Python_module">How to make a Python-module and some useful programming features</a>.

<h1 id="section:Python_module">How to make a Python-module and some useful programming features</h1>

<p>
<b>Python modules</b> A module is a file containing Python definitions and
statements and represents a convenient way of collecting useful and
related functions, classes or Python code in a single file. A
motivation to implement the drag coefficient function was that we
should be able to import it in other programs to solve e.g. the
problems outlined in (<a href="#example:sphere_freefall">Example: Sphere in free fall</a>). In general, a file
containing Python-code may be executed either as a main program
(script), typically with <code>python filename.py</code> or imported in another
script/module with <code>import filename</code>.

<p>
A module file should not execute a main program, but rather just
define functions, import other modules, and define global
variables.
Inside modules, the standard practice is to only have functions and
not any statements outside functions. The reason is that all
statements in the module file are executed from top to bottom during
import in another module/script <a href="#Langtangen2011primer">[4]</a>, and thus a
desirable behavior is no output to avoid confusion. However, in many
situations it is also desirable to allow for tests or demonstration of
usage inside the module file, and for such situations the need for a
main program arises. To meet these demands Python allows for a
fortunate construction to let a file act both as a module with
function definitions only (i.e. no main program) and as an ordinary
program we can run, with functions and a main program. The latter is possible by letting the
main program follow an <code>if</code> test of the form:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span><span style="color: #BA2121">&#39;__main__&#39;</span>:
    <span style="color: #666666">&lt;</span>main program statements<span style="color: #666666">&gt;</span>
</pre></div>
<p>
The <code>__name__</code> variable is automatically defined in any module and
equals the module name if the module is imported in another
program/script, but when the module file is executed as a program,
<code>__name__</code> equals the string <code>'__main__'</code>. Consequently, the <code>if</code> test
above will only be true whenever the module file is executed as a
program and allow for the execution of the <code>&lt;main program
statements&gt;</code>.  The <code>&lt;main program statements&gt;</code> is normally referred to
as the <em>test block</em> of a module.

<p>
The module name is the file name without the suffix <code>.py</code>
<a href="#Langtangen2011primer">[4]</a>, i.e. the module contained in the module file <code>filename.py</code> has the
module name <code>filename</code>. Note that a module can contain executable
statements as well as function definitions. These statements are
intended to initialize the module and are executed only the first time
the module name is encountered in an import statement. They are also
run if the file is executed as a script.

<p>
Below we have listed the content of the file
<code>DragCoefficientGeneric.py</code> to illustrate a specific implementation of
the module <code>DragCoefficientGeneric</code> and some other useful programming
features in Python. The functions in the module are the various
implementations of the drag coefficient functions from the previous
section.

<p>
<b>Python lists and dictionaries</b>

<ul>
    <li> Lists hold a list of values and are initialized with empty
      brackets, e.g. <code>fncnames = []</code>. The values of the list are
      accessed with an index, starting from zero. The first value of
      <code>fncnames</code> is <code>fncnames[0]</code>, the second value of <code>fncnames</code> is
      <code>fncnames[1]</code> and so on. You can remove values from the list,
      and add new values to the end by <code>fncnames</code>. Example:
      <code>fncnames.append(name)</code> will append <code>name</code> as the last value of
      the list <code>fncnames</code>. In case it was empty prior to the
      append-operation, <code>name</code> will be the only element in the list.</li>
    <li> Dictionaries are similar to what their name suggests - a
      dictionary - and an empty dictionary is initialized with empty
      braces, e.g. <code>CD = {}</code>.  In a dictionary, you have an 'index' of
      words or keys and the values accessed by their 'key'. Thus, the
      values in a dictionary aren't numbered or ordered, they are only
      accessed by the key. You can add, remove, and modify the values
      in dictionaries. For example with the statement <code>CD[name] =
      func(ReNrs)</code> the results of <code>func(ReNrs)</code> are stored in the list
      <code>CD</code> with key <code>name</code>.</li>
</ul>

To illustrate a very powerful feature of Python data structures
allowing for lists of e.g. function objects we put all the function
names in a list with the statement:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    funcs <span style="color: #666666">=</span> [cd_sphere_py_vector, cd_sphere_vector, cd_sphere_vector_bool, \ 
             cd_sphere_auto_vector]  <span style="color: #408080; font-style: italic"># list of functions to test</span>
</pre></div>
<p>
which allows for convenient looping over all of the functions with the following construction:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #008000; font-weight: bold">for</span> func <span style="color: #AA22FF; font-weight: bold">in</span> funcs:
</pre></div>
<p>
<b>Exception handling</b> Python has a very convenient construction for
testing of potential errors with <a href="https://wiki.python.org/moin/HandlingExceptions" target="_self">try-except</a> blocks:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">try</span>:
    <span style="color: #666666">&lt;</span>statements<span style="color: #666666">&gt;</span>
<span style="color: #008000; font-weight: bold">except</span> ExceptionType1:
    <span style="color: #666666">&lt;</span>remedy <span style="color: #008000; font-weight: bold">for</span> ExceptionType1 errors<span style="color: #666666">&gt;</span>
<span style="color: #008000; font-weight: bold">except</span> ExceptionType2:
    <span style="color: #666666">&lt;</span>remedy <span style="color: #008000; font-weight: bold">for</span> ExceptionType1 errors<span style="color: #666666">&gt;</span>
<span style="color: #008000; font-weight: bold">except</span>:
    <span style="color: #666666">&lt;</span>remedy <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">any</span> other errors<span style="color: #666666">&gt;</span>
</pre></div>
<p>
In the <code>DragCoefficientGeneric</code> module, this feature is used to handle
the function name for a function which has been vectorized
automatically. For such a function <code>func.func_name</code> has no value and
will return an error, and the name may be found by the statements in
the exception block.

<p>
<b>Efficiency and benchmarking</b> The function <code>clock</code> in the module
<a href="https://docs.python.org/2/library/time.html" target="_self">time</a>, return a time
expressed in seconds for the current statement and is frequently used
for benchmarking in Python or timing of functions. By subtracting the
time <code>t0</code> recored immediately before a function call from the time
immediately after the function call, an estimate of the elapsed
cpu-time is obtained. In our module <code>DragCoefficientGeneric</code> the
efficiency is implemented with the codelines:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">        t0 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
        CD[name] <span style="color: #666666">=</span> func(ReNrs) 
        exec_times[name] <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock() <span style="color: #666666">-</span> t0
</pre></div>
<p>
<b>Sorting of dictionaries</b>
The computed execution times are for convenience stored in the dictionary <code>exec_time</code> to allow for pairing of the names of the functions and their execution time.
The dictionary may be <a href="http://stackoverflow.com/questions/575819/sorting-dictionary-keys-in-python" target="_self">sorted</a> on the values and the corresponding keys sorted are returned by:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    exec_keys_sorted <span style="color: #666666">=</span> <span style="color: #008000">sorted</span>(exec_times, key<span style="color: #666666">=</span>exec_times<span style="color: #666666">.</span>get)
</pre></div>
<p>
Afterwards the results may be printed with name and execution time, ordered by the latter, with the most efficient function at the top:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #008000; font-weight: bold">for</span> name_key <span style="color: #AA22FF; font-weight: bold">in</span> exec_keys_sorted:
        <span style="color: #008000; font-weight: bold">print</span> name_key, <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BA2121"> execution time = &#39;</span>, <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%6.6f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> exec_times[name_key]
</pre></div>
<p>
By running the module <code>DragCoefficientGeneric</code> as a script, and with
500 elements in the <code>ReNrs</code> array we got the following output:
<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">cd_sphere_vector_bool   execution time = 0.000312
cd_sphere_vector        execution time = 0.000641
cd_sphere_auto_vector   execution time = 0.009497
cd_sphere_py_vector     execution time = 0.010144
</pre></div>
<p>
Clearly, the function with the boolean variables was fastest,
the straight forward vectorized version <code>cd_sphere_py_vector</code> was slowest
and the built-in function <code>vectorize</code> was nearly as inefficient.

<p>
The complete module <b>DragCoefficientGeneric</b> is listed below.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter1/src-ch1/DragCoefficientGeneric.py</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace,array,append,logspace,zeros_like,where,vectorize,\
    logical_and
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>  
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> loglog,xlabel,ylabel,grid,savefig,show,rc,hold,\
    legend, setp

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy.core.multiarray</span> <span style="color: #008000; font-weight: bold">import</span> scalar

<span style="color: #408080; font-style: italic"># single-valued function</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere</span>(Re):
    <span style="color: #BA2121">&quot;Computes the drag coefficient of a sphere as a function of the Reynolds number Re.&quot;</span>
    <span style="color: #408080; font-style: italic"># Curve fitted after fig . A -56 in Evett and Liu: &quot;Fluid Mechanics and Hydraulics&quot;</span>
    
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log10,array,polyval    
    
    <span style="color: #008000; font-weight: bold">if</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.0</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">8.0e6</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.0</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span>:
        CD <span style="color: #666666">=</span> <span style="color: #666666">24.0/</span>Re
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.5</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">100.0</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">4.22</span>,<span style="color: #666666">-14.05</span>,<span style="color: #666666">34.87</span>,<span style="color: #666666">0.658</span>])
        CD <span style="color: #666666">=</span> polyval(p,<span style="color: #666666">1.0/</span>Re) 
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">100.0</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">1.0e4</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-30.41</span>,<span style="color: #666666">43.72</span>,<span style="color: #666666">-17.08</span>,<span style="color: #666666">2.41</span>])
        CD <span style="color: #666666">=</span> polyval(p,<span style="color: #666666">1.0/</span>log10(Re))
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">1.0e4</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">3.35e5</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.1584</span>,<span style="color: #666666">2.031</span>,<span style="color: #666666">-8.472</span>,<span style="color: #666666">11.932</span>])
        CD <span style="color: #666666">=</span> polyval(p,log10(Re))
    <span style="color: #008000; font-weight: bold">elif</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">3.35e5</span> <span style="color: #AA22FF; font-weight: bold">and</span> Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">5.0e5</span>:
        x1 <span style="color: #666666">=</span> log10(Re<span style="color: #666666">/4.5e5</span>)
        CD <span style="color: #666666">=</span> <span style="color: #666666">91.08*</span>x1<span style="color: #666666">**4</span> <span style="color: #666666">+</span> <span style="color: #666666">0.0764</span>
    <span style="color: #008000; font-weight: bold">else</span>:
        p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.06338</span>,<span style="color: #666666">1.1905</span>,<span style="color: #666666">-7.332</span>,<span style="color: #666666">14.93</span>])
        CD <span style="color: #666666">=</span> polyval(p,log10(Re))
    <span style="color: #008000; font-weight: bold">return</span> CD

<span style="color: #408080; font-style: italic"># simple extension cd_sphere</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere_py_vector</span>(ReNrs):
    CD <span style="color: #666666">=</span> zeros_like(ReNrs)
    counter <span style="color: #666666">=</span> <span style="color: #666666">0</span>

    <span style="color: #008000; font-weight: bold">for</span> Re <span style="color: #AA22FF; font-weight: bold">in</span> ReNrs:
        CD[counter] <span style="color: #666666">=</span> cd_sphere(Re)
        counter <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">return</span> CD

<span style="color: #408080; font-style: italic"># vectorized function</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere_vector</span>(Re):
    <span style="color: #BA2121">&quot;Computes the drag coefficient of a sphere as a function of the Reynolds number Re.&quot;</span>
    <span style="color: #408080; font-style: italic"># Curve fitted after fig . A -56 in Evett and Liu: &quot;Fluid Mechanics and Hydraulics&quot;</span>

    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log10, array, polyval, where, zeros_like
    CD <span style="color: #666666">=</span> zeros_like(Re)
   
    CD <span style="color: #666666">=</span> where(Re <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>, <span style="color: #666666">0.0</span>, CD)     <span style="color: #408080; font-style: italic"># condition 1</span>
    
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.0</span>) <span style="color: #666666">&amp;</span> (Re <span style="color: #666666">&lt;=0.5</span>), <span style="color: #666666">24/</span>Re, CD) <span style="color: #408080; font-style: italic"># condition 2</span>

    p <span style="color: #666666">=</span> array([<span style="color: #666666">4.22</span>, <span style="color: #666666">-14.05</span>, <span style="color: #666666">34.87</span>, <span style="color: #666666">0.658</span>])
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">0.5</span>) <span style="color: #666666">&amp;</span> (Re <span style="color: #666666">&lt;=100.0</span>), polyval(p, <span style="color: #666666">1.0/</span>Re), CD) <span style="color: #408080; font-style: italic">#condition 3</span>

    p <span style="color: #666666">=</span> array([<span style="color: #666666">-30.41</span>, <span style="color: #666666">43.72</span>, <span style="color: #666666">-17.08</span>, <span style="color: #666666">2.41</span>])
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">100.0</span>)  <span style="color: #666666">&amp;</span> (Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">1.0e4</span>), polyval(p, <span style="color: #666666">1.0/</span>log10(Re)), CD) <span style="color: #408080; font-style: italic">#condition 4</span>

    p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.1584</span>, <span style="color: #666666">2.031</span>, <span style="color: #666666">-8.472</span>, <span style="color: #666666">11.932</span>])
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">1.0e4</span>)  <span style="color: #666666">&amp;</span>  (Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">3.35e5</span>), polyval(p, log10(Re)), CD) <span style="color: #408080; font-style: italic">#condition 5</span>

    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">3.35e5</span>) <span style="color: #666666">&amp;</span> (Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">5.0e5</span>), <span style="color: #666666">91.08*</span>(log10(Re<span style="color: #666666">/4.5e5</span>))<span style="color: #666666">**4</span> <span style="color: #666666">+</span> <span style="color: #666666">0.0764</span>, CD) <span style="color: #408080; font-style: italic">#condition 6</span>

    p  <span style="color: #666666">=</span> array([<span style="color: #666666">-0.06338</span>, <span style="color: #666666">1.1905</span>, <span style="color: #666666">-7.332</span>, <span style="color: #666666">14.93</span>])
    CD <span style="color: #666666">=</span> where((Re <span style="color: #666666">&gt;</span> <span style="color: #666666">5.05e5</span>)  <span style="color: #666666">&amp;</span>  (Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">8.0e6</span>), polyval(p, log10(Re)), CD) <span style="color: #408080; font-style: italic">#condition 7</span>
    
    CD <span style="color: #666666">=</span> where(Re <span style="color: #666666">&gt;</span> <span style="color: #666666">8.0e6</span>, <span style="color: #666666">0.2</span>, CD)  <span style="color: #408080; font-style: italic"># condition 8</span>
    <span style="color: #008000; font-weight: bold">return</span> CD

<span style="color: #408080; font-style: italic"># vectorized boolean</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cd_sphere_vector_bool</span>(Re):
    <span style="color: #BA2121">&quot;Computes the drag coefficient of a sphere as a function of the Reynolds number Re.&quot;</span>
    <span style="color: #408080; font-style: italic"># Curve fitted after fig . A -56 in Evett and Liu: &quot;Fluid Mechanics and Hydraulics&quot;</span>
    
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log10, array, polyval, zeros_like
       
    condition1 <span style="color: #666666">=</span> Re <span style="color: #666666">&lt;</span> <span style="color: #666666">0</span>
    condition2 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">0</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.5</span>)
    condition3 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">0.5</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">100.0</span>)
    condition4 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">100.0</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">1.0e4</span>)
    condition5 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">1.0e4</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">3.35e5</span>)
    condition6 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">3.35e5</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">5.0e5</span>)
    condition7 <span style="color: #666666">=</span> logical_and(<span style="color: #666666">5.0e5</span> <span style="color: #666666">&lt;</span> Re, Re <span style="color: #666666">&lt;=</span> <span style="color: #666666">8.0e6</span>)
    condition8 <span style="color: #666666">=</span> Re <span style="color: #666666">&gt;</span> <span style="color: #666666">8.0e6</span>
    
    CD <span style="color: #666666">=</span> zeros_like(Re)
    CD[condition1] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    
    CD[condition2] <span style="color: #666666">=</span> <span style="color: #666666">24/</span>Re[condition2]
    
    p <span style="color: #666666">=</span> array([<span style="color: #666666">4.22</span>,<span style="color: #666666">-14.05</span>,<span style="color: #666666">34.87</span>,<span style="color: #666666">0.658</span>])
    CD[condition3] <span style="color: #666666">=</span> polyval(p,<span style="color: #666666">1.0/</span>Re[condition3]) 
    
    p <span style="color: #666666">=</span> array([<span style="color: #666666">-30.41</span>,<span style="color: #666666">43.72</span>,<span style="color: #666666">-17.08</span>,<span style="color: #666666">2.41</span>])
    CD[condition4] <span style="color: #666666">=</span> polyval(p,<span style="color: #666666">1.0/</span>log10(Re[condition4]))
    
    p <span style="color: #666666">=</span> array([<span style="color: #666666">-0.1584</span>,<span style="color: #666666">2.031</span>,<span style="color: #666666">-8.472</span>,<span style="color: #666666">11.932</span>])
    CD[condition5] <span style="color: #666666">=</span> polyval(p,log10(Re[condition5]))
    
    CD[condition6] <span style="color: #666666">=</span> <span style="color: #666666">91.08*</span>(log10(Re[condition6]<span style="color: #666666">/4.5e5</span>))<span style="color: #666666">**4</span> <span style="color: #666666">+</span> <span style="color: #666666">0.0764</span>
    
    p  <span style="color: #666666">=</span> array([<span style="color: #666666">-0.06338</span>,<span style="color: #666666">1.1905</span>,<span style="color: #666666">-7.332</span>,<span style="color: #666666">14.93</span>])
    CD[condition7] <span style="color: #666666">=</span> polyval(p,log10(Re[condition7]))
    
    CD[condition8] <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
    
    <span style="color: #008000; font-weight: bold">return</span> CD
    

<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:              
<span style="color: #408080; font-style: italic">#Check whether this file is executed (name==main) or imported as a module</span>
    
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> mean
    
    CD <span style="color: #666666">=</span> {} <span style="color: #408080; font-style: italic"># Empty list for all CD computations</span>
    

    ReNrs <span style="color: #666666">=</span> logspace(<span style="color: #666666">-2</span>,<span style="color: #666666">7</span>,num<span style="color: #666666">=500</span>)
    
    <span style="color: #408080; font-style: italic"># make a vectorized version of the function automatically</span>
    cd_sphere_auto_vector <span style="color: #666666">=</span> vectorize(cd_sphere) 
    
    <span style="color: #408080; font-style: italic"># make a list of all function objects</span>
    funcs <span style="color: #666666">=</span> [cd_sphere_py_vector, cd_sphere_vector, cd_sphere_vector_bool, \
             cd_sphere_auto_vector]  <span style="color: #408080; font-style: italic"># list of functions to test   </span>
    
    
    <span style="color: #408080; font-style: italic"># Put all exec_times in a dictionary and fncnames in a list </span>
    exec_times <span style="color: #666666">=</span> {}
    fncnames <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> func <span style="color: #AA22FF; font-weight: bold">in</span> funcs:
        <span style="color: #008000; font-weight: bold">try</span>:
            name <span style="color: #666666">=</span> func<span style="color: #666666">.</span>func_name
        <span style="color: #008000; font-weight: bold">except</span>: 
            scalarname <span style="color: #666666">=</span> func<span style="color: #666666">.</span>__getattribute__(<span style="color: #BA2121">&#39;pyfunc&#39;</span>)
            name <span style="color: #666666">=</span> scalarname<span style="color: #666666">.</span>__name__<span style="color: #666666">+</span><span style="color: #BA2121">&#39;_auto_vector&#39;</span>
                      
        fncnames<span style="color: #666666">.</span>append(name)
                                      
        <span style="color: #408080; font-style: italic"># benchmark </span>
        t0 <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock()
        CD[name] <span style="color: #666666">=</span> func(ReNrs) 
        exec_times[name] <span style="color: #666666">=</span> time<span style="color: #666666">.</span>clock() <span style="color: #666666">-</span> t0
    
    <span style="color: #408080; font-style: italic"># sort the dictionary exec_times on values and return a list of the corresponding keys   </span>
    exec_keys_sorted <span style="color: #666666">=</span> <span style="color: #008000">sorted</span>(exec_times, key<span style="color: #666666">=</span>exec_times<span style="color: #666666">.</span>get)
    
    <span style="color: #408080; font-style: italic"># print the exec_times by ascending values</span>
    <span style="color: #008000; font-weight: bold">for</span> name_key <span style="color: #AA22FF; font-weight: bold">in</span> exec_keys_sorted:
        <span style="color: #008000; font-weight: bold">print</span> name_key, <span style="color: #BA2121">&#39;</span><span style="color: #BB6622; font-weight: bold">\t</span><span style="color: #BA2121"> execution time = &#39;</span>, <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%6.6f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> exec_times[name_key]

        
    <span style="color: #408080; font-style: italic"># set fontsize prms </span>
    fnSz <span style="color: #666666">=</span> <span style="color: #666666">16</span>; font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span>   : fnSz}; rc(<span style="color: #BA2121">&#39;font&#39;</span>,<span style="color: #666666">**</span>font)          
    
    <span style="color: #408080; font-style: italic"># set line styles</span>
    style <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;v-&#39;</span>, <span style="color: #BA2121">&#39;8-&#39;</span>, <span style="color: #BA2121">&#39;*-&#39;</span>, <span style="color: #BA2121">&#39;o-&#39;</span>]
    mrkevry <span style="color: #666666">=</span> [<span style="color: #666666">30</span>, <span style="color: #666666">35</span>, <span style="color: #666666">40</span>, <span style="color: #666666">45</span>]
    
    <span style="color: #408080; font-style: italic"># plot the result for all functions    </span>
    i<span style="color: #666666">=0</span>
    <span style="color: #008000; font-weight: bold">for</span> name <span style="color: #AA22FF; font-weight: bold">in</span> fncnames: 
        loglog(ReNrs, CD[name], style[i], markersize<span style="color: #666666">=10</span>, markevery<span style="color: #666666">=</span>mrkevry[i])
        hold(<span style="color: #BA2121">&#39;on&#39;</span>)
        i<span style="color: #666666">+=1</span> 
    
    <span style="color: #408080; font-style: italic"># use fncnames as plot legend</span>
    leg <span style="color: #666666">=</span> legend(fncnames) 
    leg<span style="color: #666666">.</span>get_frame()<span style="color: #666666">.</span>set_alpha(<span style="color: #666666">0.</span>)
    xlabel(<span style="color: #BA2121">&#39;$Re$&#39;</span>)
    ylabel(<span style="color: #BA2121">&#39;$C_D$&#39;</span>)
    grid(<span style="color: #BA2121">&#39;on&#39;</span>, <span style="color: #BA2121">&#39;both&#39;</span>, <span style="color: #BA2121">&#39;both&#39;</span>)
    <span style="color: #408080; font-style: italic"># savefig(&#39;example_sphere_generic.png&#39;, transparent=True) # save plot if needed</span>
    show()
</pre></div>
<p>
<!-- !split -->

<h1 id="ch1:sec:differences">Differences</h1>

<p>
We will study some simple methods to solve initial value
problems. Later we shall see that these methods also may be used to
solve boundary value problems for ODEs.

<p>
<center><p><img src="fig-ch1/4_new.png" align="bottom" width=300></p></center>

$$
\begin{equation*}
x_j=x_0+jh
\end{equation*}
$$

where \( h=\Delta x \) is assumed constant unless otherwise stated.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Illustration of how to obtain difference equations. <div id="fig:1.5"></div> </p></center>
<p><img src="fig-ch1/5_new.png" align="bottom" width=300></p>
</center>

<p>
Forward differences:
$$
\begin{equation*}
\Delta y_j=y_{j+1}-y_j
\end{equation*}
$$

<p>
Backward differences:
$$
\begin{equation}
\label{eq:1201}
\nabla y_j=y_j-y_{j-1}
\end{equation}
$$

<p>
Central differences:
$$
\begin{equation*}
\delta y_{j+\frac{1}{2}}=y_{j+1}-y_j
\end{equation*}
$$

<p>
The linear difference operators \( \Delta \), \( \nabla \) and \( \delta \) are useful when we are deriving more complicated expressions. An example of usage is as follows,
$$
\begin{equation*}
\delta ^2y_j=\delta (\delta y_j)=\delta (y_{1+\frac{1}{2}}-y_{1-\frac{1}{2}})
=y_{j+1}-y_j-(y_j-y_{j-1})=y_{j+1}-2y_j+y_{j-1}
\end{equation*}
$$

<p>
We will mainly write out the formulas entirely instead of using operators.

<p>
We shall find difference formulas and need again <b>Taylor's theorem</b>:
$$
\begin{align}
\label{eq:1202}
y(x)=&y(x_0)+y'(x_0)\cdot (x-x_0)+\frac{1}{2}y''(x_0)\cdot (x-x_0)^2 + \\ 
&\dots + \frac{1}{n!}y^{(n)}(x_0)\cdot (x-x_0)^n +R_n \nonumber
\end{align}
$$

<p>
The remainder \( R_n \) is given by
$$
\begin{align}
R_n&=\frac{1}{(n+1)!}y^{(n+1)}(\xi)\cdot (x-x_0)^{n+1}
\label{_auto9}\\ 
&\text{where } \xi \in (x_0,x) \nonumber
\end{align}
$$

<p>
By use of \eqref{eq:1202} we get
$$
\begin{align}
\label{eq:1203a}
y(x_{j+1}) \equiv &y(x_j+h)=y(x_j)+hy'(x_j) +\frac{h^2}{2}y''(x_j)+\\ 
&\dots+\frac{h^ny^{(n)}(x_j)}{n!}+R_n \nonumber
\end{align}
$$

where the remainder \( R_n=O(h^{n+1}),\ h\to 0  \).

<p>
From \eqref{eq:1203a} we also get
$$
\begin{equation}
\label{eq:1203b}
y(x_{j-1}) \equiv y(x_j-h)=y(x_j)-hy'(x_j)+\frac{h^2}{2}y''(x_j)+\dots+\frac{h^k(-1)^ky^{(k)}(x_j)}{k!}+\dots
\end{equation}
$$

<p>
We will here and subsequently assume that \( h \) is positive.

<p>
We solve \eqref{eq:1203a} with respect to \( y' \):
$$
\begin{equation}
\label{eq:1204a}
y'(x_j)=\frac{y(x_{j+1})-y(x_j)}{h}+O(h)
\end{equation}
$$

<p>
We solve \eqref{eq:1203b} with respect to \( y' \):
$$
\begin{equation}
\label{eq:1204b}
y'(x_j)=\frac{y(x_{j})-y(x_{j-1})}{h}+O(h)
\end{equation}
$$

<p>
By addition of \eqref{eq:1203b} and \eqref{eq:1203a} we get
$$
\begin{equation}
\label{eq:1204c}
y''(x_j)=\frac{y(x_{j+1})-2y(x_{j})+y(x_{j-1})}{h^2}+O(h^2)
\end{equation}
$$

<p>
By subtraction of \eqref{eq:1203b} from \eqref{eq:1203a} we get
$$
\begin{equation}
\label{eq:1204d}
y'(x_j)=\frac{y(x_{j+1})-y(x_{j-1})}{2h}+O(h^2)
\end{equation}
$$

<p>
<b>Notation:</b> We let \( y(x_j) \) always denote the function \( y(x) \) with \( x=x_j \). We use \( y_j \) both for the numerical and analytical value. Which is which will be implied.

<p>
Equations \eqref{eq:1204a}, \eqref{eq:1204b}, \eqref{eq:1204c} and \eqref{eq:1204d} then gives the following difference expressions:
$$
\begin{align}
\label{eq:1205a}
&y'_j=\frac{y_{j+1}-y_j}{h}\ ;\  \text{truncation error}\ O(h)\\ 
\label{eq:1205b}
&y'_j=\frac{y_{j}-y_{j-1}}{h}\ ;\  \text{truncation error}\ O(h)\\ 
\label{eq:1205c}
&y''_j=\frac{y_{j+1}-2y_j+y_{j-1}}{h^2}\ ;\  \text{truncation error}\ O(h^2)\\ 
\label{eq:1205d}
&y'_j=\frac{y_{j+1}-y_{j-1}}{2h}\ ;\  \text{truncation error}\ O(h^2)
\end{align}
$$

<p>
\eqref{eq:1205a} is a forward difference, \eqref{eq:1205b} is a backward difference while \eqref{eq:1205c} and \eqref{eq:1205d} are central differences.

<p>
<center><p><img src="fig-ch1/6.png" align="bottom" width=300></p></center>

<p>
The expressions in \eqref{eq:1205a}, \eqref{eq:1205b}, \eqref{eq:1205c} and \eqref{eq:1205d} are easily established from the figure.

<p>
\eqref{eq:1205a} follows directly.

<p>
\eqref{eq:1205c}:
$$
\begin{equation*}
y''_j(x_j)=\left(\frac{y_{j+1}-y_j}{h}-\frac{y_{j}-y_{j-1}}{h}\right)\cdot \frac{1}{h} = \frac{y_{j+1}-2y_j+y_{j-1}}{h^2}
\end{equation*}
$$

<p>
\eqref{eq:1205d}:

$$
\begin{equation*}
y'_j=\left(\frac{y_{j+1}-y_j}{h}-\frac{y_{j}+y_{j-1}}{h}\right)\cdot \frac{1}{2}=\frac{y_{j+1}-y_{j-1}}{2h}
\end{equation*}
$$

<p>
To find the truncation error we must use the Taylor series expansion.

<p>
The derivation above may be done more systematically. We set
$$
\begin{equation}
\label{eq:1206a}
y'(x_j)=a\cdot y(x_{j-1})+b\cdot y(x_j)+c\cdot y(x_{j+1})+O(h^m)
\end{equation}
$$

where we shall determine the constants \( a \), \( b \) and \( c \) together with the error term. For simplicity we use the notation \( y_j\equiv y(x_j),\ y'_j \equiv y'(x_j) \) and so on. From the Taylor series expansion in \eqref{eq:1203a} and \eqref{eq:1203b} we get
$$
\begin{align*}
&a\cdot y_{j-1}+b\cdot y_j +c\cdot y_{j+1} = \\ 
&a\cdot\left[y_j-hy'_j+\frac{h^2}{2}y''_j+\frac{h^3}{6}y'''_j(\xi)\right]+b\cdot y_j + \\ 
&c\cdot \left[y_j-hy'_j+\frac{h^2}{2}y''_j+\frac{h^3}{6}y'''_j(\xi)\right]
\end{align*}
$$

Collecting terms:
$$
\begin{align*}
a\cdot y_{j-1}+b\cdot y_j +c\cdot y_{j+1} = \\ 
(a+b+c)y_j+(c-a)hy'_j+ \\ 
(a+c)\frac{h^2}{2}y''_j+(c-a)\frac{h^3}{6}y'''(\xi)
\end{align*}
$$

We determine \( a \), \( b \) and \( c \) such that \( y'_j \) gets as high accuracy as possible:
$$
\begin{align}
a+b+c=0 \nonumber \\ 
(c-a)\cdot h=1
\label{eq:1206b}\\ \nonumber
a+c=1
\end{align}
$$

The solution to \eqref{eq:1206b} is
$$
\begin{equation*}
a=-\frac{1}{2h},\ b=0 \text{ and } c=\frac{1}{2h}
\end{equation*}
$$

which when inserted in \eqref{eq:1206a} gives
$$
\begin{equation}
\label{eq:1207}
y'_j=\frac{y_{j+1}-y_{j-1}}{2h}-\frac{h^2}{6}y'''(\xi)
\end{equation}
$$

Comparing \eqref{eq:1207} with \eqref{eq:1206a} we see that the error term is \( O(h^m)=-\frac{h^2}{6}y'''(\xi) \), which means that \( m=2 \). As expected, \eqref{eq:1207} is identical to \eqref{eq:1204d}.

<p>
Let's use this method to find a forward difference expression for \( y'(x_j) \) with accuracy of \( O(h^2) \). Second order accuracy requires at least three unknown coefficients. Thus,
$$
\begin{equation}
\label{eq:1208a}
y'(x_j)=a\cdot y_j + b\cdot y_{j+1} + c\cdot y_{j+2} + O(h^m)
\end{equation}
$$

The procedure goes as in the previous example as follows,
$$
\begin{align*}
a&\cdot y_{j}+b\cdot y_{j+1} +c\cdot y_{j+2} =\\ 
a&\cdot y_j+b\cdot\left[y_j+hy'_j+\frac{h^2}{2}y''_j+\frac{h^3}{6}y'''(\xi)\right]+\\ 
c&\cdot \left[y_j+2hy'_j+2h^2y''_j+\frac{8h^3}{6}y'''_j(\xi)\right]\\ 
=&(a+b+c)\cdot y_j+(b+2c)\cdot hy'_j \\ 
+& h^2\left(\frac{b}{2}+2c\right)\cdot y''_j+\frac{h^3}{6}(b+8c)\cdot y'''(\xi)
\end{align*}
$$

We determine \( a \), \( b \) and \( c \) such that \( y'_j \) becomes as accurate as possible. Then we get,
$$
\begin{align}
a+b+c=0 \nonumber\\ 
(b+2c)\cdot h=1
\label{eq:1208b}\\ 
\frac{b}{2}+2c=0\nonumber
\end{align}
$$

The solution of \eqref{eq:1208b} is
$$
\begin{equation*}
a=-\frac{3}{2h},\ b=\frac{2}{h},\ c=-\frac{1}{2h}\ 
\end{equation*}
$$

which inserted in \eqref{eq:1208a} gives
$$
\begin{equation}
\label{eq:1209}
y'_j=\frac{-3y_j+4y_{j+1}-y_{j+2}}{2h}+\frac{h^2}{3}y'''(\xi)
\end{equation}
$$

The error term \( O(h^m)=\frac{h^2}{3}y'''(\xi) \) shows that \( m=2 \).

<p>
Here follows some difference formulas derived with the procedure above:

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Forward differences: <div id="forward"></div>
$$
\begin{align*}
\dfrac{dy_i}{dx}&=\dfrac{y_{i}-y_{i-1}}{\Delta x}+\dfrac{1}{2}y''(\xi)\Delta x \\ 
\dfrac{dy_i}{dx}&=\dfrac{3y_i-4y_{i-1}+y_{i-2}}{2\Delta x}+\dfrac{1}{3}y'''(\xi)\cdot (\Delta x)^2 \\ 
\dfrac{dy_i}{dx}&=\dfrac{11y_i-18y_{i-1}+9y_{i-2}-y_{i-3}}{6\Delta x}+\dfrac{1}{4}y^{(4)}(\xi)\cdot (\Delta x)^3 \\ 
\dfrac{d^2y_i}{dx^2}&=\dfrac{y_i-2y_{i-1}+y_{i-2}}{(\Delta x)^2}+y'''(\xi)\cdot \Delta x \\ 
\dfrac{d^2y_i}{dx^2}&=\dfrac{2y_i-5y_{i-1}+4y_{i-2}-y_{i-3}}{(\Delta x)^2}+\dfrac{11}{12}y^{(4)}(\xi)\cdot (\Delta x)^2
\end{align*}
$$
</div>
<!-- end box -->


<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Backward differences: <div id="backward"></div>
$$
\begin{align*}
\dfrac{dy_i}{dx}&=\dfrac{y_{i}-y_{i-1}}{\Delta x}+\dfrac{1}{2}y''(\xi)\Delta x \\ 
\dfrac{dy_i}{dx}&=\dfrac{3y_i-4y_{i-1}+y_{i-2}}{2\Delta x}+\dfrac{1}{3}y'''(\xi)\cdot (\Delta x)^2 \\ 
\dfrac{dy_i}{dx}&=\dfrac{11y_i-18y_{i-1}+9y_{i-2}-y_{i-3}}{6\Delta x}+\dfrac{1}{4}y^{(4)}(\xi)\cdot (\Delta x)^3 \\ 
\dfrac{d^2y_i}{dx^2}&=\dfrac{y_i-2y_{i-1}+y_{i-2}}{(\Delta x)^2}+y'''(\xi)\cdot \Delta x \\ 
\dfrac{d^2y_i}{dx^2}&=\dfrac{2y_i-5y_{i-1}+4y_{i-2}-y_{i-3}}{(\Delta x)^2}+\dfrac{11}{12}y^{(4)}(\xi)\cdot (\Delta x)^2
\end{align*}
$$
</div>
<!-- end box -->


<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Central differences: <div id="central"></div>
$$
\begin{align*}
\dfrac{dy_i}{dx}&=\dfrac{y_{i+1}-y_{i-1}}{2\Delta x}-\dfrac{1}{6}y'''(\xi)(\Delta x)^2 \\ 
\dfrac{dy_i}{dx}&=\dfrac{-y_{i+2}+8y_{i+1}-8y_{i-1}+y_{i-2}}{12\Delta x}+\dfrac{1}{30}y^{(5)}(\xi)\cdot (\Delta x)^4 \\ 
\dfrac{d^2y_i}{dx^2}&=\dfrac{y_{i+1}-2y_{i}+y_{i-1}}{(\Delta x)^2}-\dfrac{1}{12}y^{(4)}(\xi)\cdot (\Delta x)^2 \\ 
\dfrac{d^2y_i}{dx^2}&=\dfrac{-y_{i+2}+16y_{i+1}-30y_{i}+16y_{i-1}-y_{i-2}}{12(\Delta x)^2}+\dfrac{1}{90}y^{(6)}(\xi)\cdot (\Delta x)^4 \\ 
\dfrac{d^3y_i}{dx^3}&=\dfrac{y_{i+2}-2y_{i+1}+2y_{i-1}-y_{i-2}}{2(\Delta x)^3}+\dfrac{1}{4}y^{(5)}(\xi)\cdot (\Delta x)^2
\end{align*}
$$
</div>
<!-- end box -->


<p>
<!-- !split -->

<h3 id="___sec12">Treatment of the term \( \frac{d}{dx} \left[ p(x) \frac{d}{dx} u(x)\right] \) </h3>

This term often appears in difference equations, and it may be clever to treat the term as it is instead of first execute the differentiation.

<p>
<b>Central differences:</b>
We use central differences (recall Figure <a href="#fig:1.5">2</a>) as follows,
$$
\begin{align*}
\frac{d}{dx}\left[p(x)\cdot \frac{d}{dx}u(x)\right]\bigg|_i \approx& \frac{[p(x)\cdot u'(x)]|_{i+\frac{1}{2}}-[p(x)\cdot u'(x)]|_{i-\frac{1}{2}}}{h}\\ 
=& \frac{p(x_{i+\frac{1}{2}})\cdot u'(x_{i+\frac{1}{2}})-p(x_{i-\frac{1}{2}})\cdot u'(x_{i-\frac{1}{2}})}{h}
\end{align*}
$$

Using central differences again, we get
$$
\begin{equation*}
u'(x_{i+\frac{1}{2}}) \approx \frac{u_{i+1}-u_i}{h},\ u'(x_{i-\frac{1}{2}}) \approx \frac{u_{i}-u_{i-1}}{h},\ 
\end{equation*}
$$

which inserted in the previous equation gives the final expression
$$
\begin{equation}
\label{eq:12010a}
\frac{d}{dx}\left[p(x)\cdot \frac{d}{dx}u(x)\right]\bigg|_i \approx \frac{p_{i-\frac{1}{2}}\cdot {u_{i-1}-(p_{i+\frac{1}{2}}+p_{i-\frac{1}{2}})\cdot u_i+p_{i+\frac{1}{2}}\cdot u_{i+1}}}{h^2} + \text{error term}
\end{equation}
$$

where
$$
\begin{equation*}
\text{error term} =-\frac{h^2}{24}\cdot \frac{d}{dx} \bigg(p(x)\cdot u'''(x)+[p(x)\cdot u'(x)]''\bigg) + O(h^3)
\end{equation*}
$$

If \( p(x_{1+\frac{1}{2}}) \) and \( p(x_{1-\frac{1}{2}}) \) cannot be found directly, we use
$$
\begin{equation}
\label{eq:12011}
p(x_{1+\frac{1}{2}})\approx \frac{1}{2}(p_{i+1}+p_i),\ p(x_{1-\frac{1}{2}}) \approx \frac{1}{2}(p_i+p_{i-1})
\end{equation}
$$

Note that for \( p(x)=1=\text{constant} \) we get the usual expression
$$
\begin{equation*}
\frac{d^2u}{dx^2}\bigg|_i=\frac{u_{i+1}-2u_i+u_{i-1}}{h^2}+O(h^2)
\end{equation*}
$$

<b>Forward differences:</b>
We start with
$$
\begin{align*}
\frac{d}{dx}\left[p(x)\cdot \frac{du}{dx}\right]\bigg|_i &\approx \frac{p(x_{i+\frac{1}{2}})\cdot u'(x_{i+\frac{1}{2}})-p(x_i)\cdot u'(x_i)}{\frac{h}{2}}\\ 
 &\approx \frac{p(x_{i+\frac{1}{2}})\cdot\left( \frac{u_{i+1}-u_i}{h}\right) -p(x_i)\cdot u'(x_i)}{\frac{h}{2}}
\end{align*}
$$

which gives
$$
\begin{equation}
\label{eq:12012a}
\frac{d}{dx}\left[p(x)\cdot \frac{du}{dx}\right]\bigg|_i = \frac{2\cdot [p(x_{i+\frac{1}{2}})\cdot {(u_{i+1}-u_i)-h\cdot p(x_i)\cdot u'(x_i)]}}{h^2} +\text{error term}
\end{equation}
$$

where
$$
\begin{equation}
\label{eq:12012b}
\text{error term} =- \frac{h}{12}[3p''(x_i)\cdot u'(x_i)+6p'(x_i)\cdot u''(x_i)+4p(x_i)\cdot u'''(x_i)]+O(h^2)
\end{equation}
$$

We have kept the term \( u'(x_i) \) since \eqref{eq:12012a} usually is used at the boundary, and \( u'(x_i) \) may be prescribed there.
For \( p(x)=1=\text{constant} \) we get the expression
$$
\begin{equation}
\label{eq:12013}
u''_i = \frac{2\cdot [u_{i+1}-u_i-h\cdot u'(x_i)]}{h^2}-\frac{h}{3}u'''(x_i)+O(h^2)
\end{equation}
$$

<p>
<b>Backward Differences:</b>
We start with
$$
\begin{align*}
\frac{d}{dx}\left[p(x)\frac{du}{dx}\right]\bigg|_i \approx& \frac{p(x_i)\cdot u'(x_i)-p(x_i)\cdot u'(x_{i-\frac{1}{2}})\cdot u'(x_{i-\frac{1}{2}})}{\frac{h}{2}}\\ \approx& \frac{p(x_i)\cdot u'(x_i)-p(x_{i-\frac{1}{2}})\left(\frac{u_i-u_{i-1}}{h}\right)}{\frac{h}{2}}
\end{align*}
$$

which gives
$$
\begin{equation}
\label{eq:12014a}
\frac{d}{dx}\left[p(x)\frac{du}{dx}\right]\bigg|_i = \frac{2\cdot [h\cdot p(x_i)u'(x_i)-p(x_{i-\frac{1}{2}})\cdot (u_i-u_{i-1})]}{h^2}+\text{error term}
\end{equation}
$$

where
$$
\begin{equation}
\label{eq:12014b}
\text{error term}=\frac{h}{12}[3p''(x_i)\cdot u'(x_i)+6p'(x_i)\cdot u''(x_i)+4p(x_i)\cdot u'''(x_i)]+O(h^2)
\end{equation}
$$

This is the same error term as in \eqref{eq:12012b} except from the sign. Also here we have kept the term \( u'(x_i) \) since \eqref{eq:12014b} usually is used at the boundary where \( u'(x_i) \) may be prescribed.
For \( p(x)=1=\text{constant} \) we get the expression
$$
\begin{equation}
u''_i = \frac{2\cdot [h\cdot u'(x_i)-(u_i-u_{i-1})]}{h^2}+\frac{h}{3}u'''(x_i)+O(h^2)
\label{_auto10}
\end{equation}
$$

<p>
<!-- !split -->

<h1 id="ex:euler_method">Euler's method</h1>
The ODE is given as
$$
\begin{align}
\label{eq:1301}
\frac{dy}{dx} = y'(x)&=f(x,y)\\ 
y(x_0)=&y_0
\label{_auto11}
\end{align}
$$

By using a first order forward approximation \eqref{eq:1204a}  of the derivative in \eqref{eq:1301} we obtain:
$$
\begin{equation*}
y(x_{n+1})=y(x_n)+h\cdot f(x_n,y(x_n))+O(h^2)
\end{equation*}
$$

or
$$
\begin{equation}
\label{eq:1302}
y_{n+1}=y_n+h\cdot f(x_n,y_n)
\end{equation}
$$

\eqref{eq:1302} is a difference equation and the scheme is called <b>Euler's method</b> (1768). The scheme is illustrated graphically in Figure <a href="#fig:1.7">3</a>. Euler's method is a first order method, since the expression for \( y'(x) \) is first order of \( h \). The method has a global error of order \( h \), and a local of order \( h^2 \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Graphical illustration of Euler's method. <div id="fig:1.7"></div> </p></center>
<p><img src="fig-ch1/7.png" align="bottom" width=400></p>
</center>

<p>
<!-- !split -->

<h2 id="ex:falling_sphere">Example: Falling sphere with constant and varying drag</h2>

<p>
We write \eqref{eq:sphere_1st_order} and \eqref{eq:sphere_second_order} as a system as follows,
$$
\begin{align}
& \frac{dz}{dt}=v \label{eq:1303a}\\ 
& \frac{dv}{dt}=g-\alpha v^2 \label{eq:1303b}
\end{align}
$$

where
$$
\begin{equation*}
\alpha =\frac{3\rho _f}{4\rho _k\cdot d}\cdot C_D
\end{equation*}
$$

The analytical solution with \( z(0)=0 \) and \( v(0)=0 \) is given by
$$
\begin{align} \label{eq:1304a}
 z(t)& =\frac{\ln(\cosh(\sqrt{\alpha g}\cdot t)}{\alpha} \\ 
v(t) &=\sqrt{\frac{g}{\alpha}}\cdot \tanh (\sqrt{\alpha g}\cdot t)
\label{_auto12}
\end{align}
$$

The terminal velocity \( v_t \) is found by \( \displaystyle \frac{dv}{dt}=0 \) which gives \( \displaystyle v_t=\sqrt{\frac{g}{\alpha}} \).

<p>
We use data from a golf ball: \( d= 41\text{ mm} \), \( \rho_k = 1275 \text{ kg/m}^3 \), \( \rho_k = 1.22 \text{ kg/m}^3 \), and choose \( C_D = 0.4 \) which gives \( \alpha = 7\cdot 10^{-3} \). The terminal velocity then becomes
$$
\begin{equation*}
v_t = \sqrt{\frac{g}{\alpha}} = 37.44
\end{equation*}
$$

<p>
If we use Taylor's method from the section <a href="#sec:taylor">Taylor's method</a> we get the following expression by using four terms in the series expansion:
$$
\begin{align}
\label{eq:1305}
z(t)=&\frac{1}{2}gt^2\cdot (1-\frac{1}{6}\alpha gt^2)\\ 
v(t)=&g t\cdot (1-\frac{1}{3}\alpha gt^2)
\label{_auto13}
\end{align}
$$

<p>
The Euler scheme \eqref{eq:1302} used on \eqref{eq:1303b} gives
$$
\begin{equation}
\label{eq:1306}
v_{n+1}=v_n+\Delta t\cdot (g-\alpha\cdot v^2_n),\ n=0,1,\dots
\end{equation}
$$

with \( v(0)=0 \).

<p>
One way of implementing the integration scheme is given in the following function <code>euler()</code>:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">euler</span>(func,z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Euler scheme for solution of systems of ODEs. </span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions, </span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns </span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>
    
    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time),np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0

    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(time)<span style="color: #666666">-1</span>):
        dt <span style="color: #666666">=</span> time[i<span style="color: #666666">+1</span>]<span style="color: #666666">-</span>time[i]
        z[i<span style="color: #666666">+1</span>,:]<span style="color: #666666">=</span>z[i,:] <span style="color: #666666">+</span> np<span style="color: #666666">.</span>asarray(func(z[i,:],time[i]))<span style="color: #666666">*</span>dt

    <span style="color: #008000; font-weight: bold">return</span> z
</pre></div>
<p>
The program <b>FallingSphereEuler.py</b>  computes the solution for the first 10 seconds, using a time step of \( \Delta t=0.5 \) s, and generates the plot in Figure <a href="#fig:faling_sphere_euler">4</a>. In addition to the case of constant drag coefficient, a solution for the case of varying \( C_D \) is included. To find \( C_D \) as function of velocity we use the function <code>cd_sphere()</code> that we implemented in (<a href="#example:sphere_freefall">Example: Sphere in free fall</a>). The complete program is as follows,

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter1/src-ch1/FallingSphereEuler.py;DragCoefficientGeneric.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/src-ch1/DragCoefficientGeneric.py;</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">DragCoefficientGeneric</span> <span style="color: #008000; font-weight: bold">import</span> cd_sphere    
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #408080; font-style: italic"># change some default values to make plots more readable </span>
LNWDT<span style="color: #666666">=5</span>; FNT<span style="color: #666666">=11</span>
rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT


g <span style="color: #666666">=</span> <span style="color: #666666">9.81</span>      <span style="color: #408080; font-style: italic"># Gravity m/s^2</span>
d <span style="color: #666666">=</span> <span style="color: #666666">41.0e-3</span>   <span style="color: #408080; font-style: italic"># Diameter of the sphere</span>
rho_f <span style="color: #666666">=</span> <span style="color: #666666">1.22</span>  <span style="color: #408080; font-style: italic"># Density of fluid [kg/m^3]</span>
rho_s <span style="color: #666666">=</span> <span style="color: #666666">1275</span>  <span style="color: #408080; font-style: italic"># Density of sphere [kg/m^3]</span>
nu <span style="color: #666666">=</span> <span style="color: #666666">1.5e-5</span>   <span style="color: #408080; font-style: italic"># Kinematical viscosity [m^2/s]</span>
CD <span style="color: #666666">=</span> <span style="color: #666666">0.4</span>      <span style="color: #408080; font-style: italic"># Constant drag coefficient</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;2x2 system for sphere with constant drag.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    alpha <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)<span style="color: #666666">*</span>CD
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>], g <span style="color: #666666">-</span> alpha<span style="color: #666666">*</span>z[<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>]
    <span style="color: #008000; font-weight: bold">return</span> zout 

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f2</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;2x2 system for sphere with Re-dependent drag.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    v <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(z[<span style="color: #666666">1</span>]) 
    Re <span style="color: #666666">=</span> v<span style="color: #666666">*</span>d<span style="color: #666666">/</span>nu
    CD <span style="color: #666666">=</span> cd_sphere(Re)
    alpha <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)<span style="color: #666666">*</span>CD
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>], g <span style="color: #666666">-</span> alpha<span style="color: #666666">*</span>z[<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>]
    <span style="color: #008000; font-weight: bold">return</span> zout

<span style="color: #408080; font-style: italic"># define euler scheme</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">euler</span>(func,z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Euler scheme for solution of systems of ODEs. </span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions, </span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns </span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>
    
    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time),np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0

    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(time)<span style="color: #666666">-1</span>):
        dt <span style="color: #666666">=</span> time[i<span style="color: #666666">+1</span>]<span style="color: #666666">-</span>time[i]
        z[i<span style="color: #666666">+1</span>,:]<span style="color: #666666">=</span>z[i,:] <span style="color: #666666">+</span> np<span style="color: #666666">.</span>asarray(func(z[i,:],time[i]))<span style="color: #666666">*</span>dt

    <span style="color: #008000; font-weight: bold">return</span> z

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">v_taylor</span>(t):
<span style="color: #408080; font-style: italic">#    z = np.zeros_like(t)</span>
    v <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(t)

    alpha <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)<span style="color: #666666">*</span>CD
    v<span style="color: #666666">=</span>g<span style="color: #666666">*</span>t<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>alpha<span style="color: #666666">*</span>g<span style="color: #666666">*</span>t<span style="color: #666666">**2</span>)
    <span style="color: #008000; font-weight: bold">return</span> v
     
<span style="color: #408080; font-style: italic"># main program starts here</span>

T <span style="color: #666666">=</span> <span style="color: #666666">10</span>  <span style="color: #408080; font-style: italic"># end of simulation</span>
N <span style="color: #666666">=</span> <span style="color: #666666">20</span>  <span style="color: #408080; font-style: italic"># no of time steps</span>
time <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)

z0<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #666666">2</span>)
z0[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>

ze <span style="color: #666666">=</span> euler(f, z0, time)     <span style="color: #408080; font-style: italic"># compute response with constant CD using Euler&#39;s method</span>
ze2 <span style="color: #666666">=</span> euler(f2, z0, time)   <span style="color: #408080; font-style: italic"># compute response with varying CD using Euler&#39;s method</span>

k1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(g<span style="color: #666666">*4*</span>rho_s<span style="color: #666666">*</span>d<span style="color: #666666">/</span>(<span style="color: #666666">3*</span>rho_f<span style="color: #666666">*</span>CD))
k2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">3*</span>rho_f<span style="color: #666666">*</span>g<span style="color: #666666">*</span>CD<span style="color: #666666">/</span>(<span style="color: #666666">4*</span>rho_s<span style="color: #666666">*</span>d))
v_a <span style="color: #666666">=</span> k1<span style="color: #666666">*</span>np<span style="color: #666666">.</span>tanh(k2<span style="color: #666666">*</span>time)   <span style="color: #408080; font-style: italic"># compute response with constant CD using analytical solution</span>

<span style="color: #408080; font-style: italic"># plotting</span>

legends<span style="color: #666666">=</span>[]
line_type<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;-&#39;</span>,<span style="color: #BA2121">&#39;:&#39;</span>,<span style="color: #BA2121">&#39;.&#39;</span>,<span style="color: #BA2121">&#39;-.&#39;</span>,<span style="color: #BA2121">&#39;--&#39;</span>]

plot(time, v_a, line_type[<span style="color: #666666">0</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Analytical (constant CD)&#39;</span>)

plot(time, ze[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">1</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Euler (constant CD)&#39;</span>)

plot(time, ze2[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">3</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Euler (varying CD)&#39;</span>)

time_taylor <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">4</span>, N<span style="color: #666666">+1</span>)

plot(time_taylor, v_taylor(time_taylor))
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Taylor (constant CD)&#39;</span>)

legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}
rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)
xlabel(<span style="color: #BA2121">&#39;Time [s]&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;Velocity [m/s]&#39;</span>)
<span style="color: #408080; font-style: italic">#savefig(&#39;example_sphere_falling_euler.png&#39;, transparent=True)</span>
show()
</pre></div>
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Euler's method with \( \Delta t=0.5 \) s. <div id="fig:faling_sphere_euler"></div> </p></center>
<p><img src="fig-ch1/example_sphere_falling_euler.png" align="bottom" width=400></p>
</center>

<p>
<!-- !split -->

<h2 id="ex:num_error">Example: Numerical error as a function of \( \Delta t \)</h2>
In this example we will assess how the error of our implementation of
the Euler method depends on the time step \( \Delta t \) in a systematic
manner. We will solve a problem with an analytical solution in a loop,
and for each new solution we do the following:

<ul>
<li> Divide the time step by two (or double the number of time steps)</li>
<li> Compute the error</li>
<li> Plot the error</li>
</ul>

Euler's method is a first order method and we expect the error to be
\( O(h)=O(\Delta t) \). Consequently if the timestep is divided by two,
the error should also be divided by two.
As errors normally are small values and are expected to be smaller and
smaller for decreasing time steps, we normally do not plot the error
itself, but rather the logarithm of the absolute value of the
error. The latter we do due to the fact that we are only interested in
the order of magnitude of the error, whereas errors may be both
positive and negative. As the initial value is always correct we
discard the first error at time zero to avoid problems with the
logarithm of zero in <code>log_error = np.log10(abs_error[1:])</code>.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter1/src-ch1/Euler_timestep_ctrl.py;DragCoefficientGeneric.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/src-ch1/DragCoefficientGeneric.py;</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">DragCoefficientGeneric</span> <span style="color: #008000; font-weight: bold">import</span> cd_sphere    
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #408080; font-style: italic"># change some default values to make plots more readable </span>
LNWDT<span style="color: #666666">=5</span>; FNT<span style="color: #666666">=11</span>
rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}; rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)



g <span style="color: #666666">=</span> <span style="color: #666666">9.81</span>      <span style="color: #408080; font-style: italic"># Gravity m/s^2</span>
d <span style="color: #666666">=</span> <span style="color: #666666">41.0e-3</span>   <span style="color: #408080; font-style: italic"># Diameter of the sphere</span>
rho_f <span style="color: #666666">=</span> <span style="color: #666666">1.22</span>  <span style="color: #408080; font-style: italic"># Density of fluid [kg/m^3]</span>
rho_s <span style="color: #666666">=</span> <span style="color: #666666">1275</span>  <span style="color: #408080; font-style: italic"># Density of sphere [kg/m^3]</span>
nu <span style="color: #666666">=</span> <span style="color: #666666">1.5e-5</span>   <span style="color: #408080; font-style: italic"># Kinematical viscosity [m^2/s]</span>
CD <span style="color: #666666">=</span> <span style="color: #666666">0.4</span>      <span style="color: #408080; font-style: italic"># Constant drag coefficient</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;2x2 system for sphere with constant drag.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    alpha <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)<span style="color: #666666">*</span>CD
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>], g <span style="color: #666666">-</span> alpha<span style="color: #666666">*</span>z[<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>]
    <span style="color: #008000; font-weight: bold">return</span> zout 

<span style="color: #408080; font-style: italic"># define euler scheme</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">euler</span>(func,z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Euler scheme for solution of systems of ODEs. </span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions, </span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns </span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>
    
    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time),np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0

    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(time)<span style="color: #666666">-1</span>):
        dt <span style="color: #666666">=</span> time[i<span style="color: #666666">+1</span>]<span style="color: #666666">-</span>time[i]
        z[i<span style="color: #666666">+1</span>,:]<span style="color: #666666">=</span>z[i,:] <span style="color: #666666">+</span> np<span style="color: #666666">.</span>asarray(func(z[i,:],time[i]))<span style="color: #666666">*</span>dt
    <span style="color: #008000; font-weight: bold">return</span> z

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">v_taylor</span>(t):
<span style="color: #408080; font-style: italic">#    z = np.zeros_like(t)</span>
    v <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(t)
    alpha <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)<span style="color: #666666">*</span>CD
    v<span style="color: #666666">=</span>g<span style="color: #666666">*</span>t<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>alpha<span style="color: #666666">*</span>g<span style="color: #666666">*</span>t<span style="color: #666666">**2</span>)
    <span style="color: #008000; font-weight: bold">return</span> v
     
<span style="color: #408080; font-style: italic"># main program starts here</span>

T <span style="color: #666666">=</span> <span style="color: #666666">10</span>  <span style="color: #408080; font-style: italic"># end of simulation</span>
N <span style="color: #666666">=</span> <span style="color: #666666">10</span>  <span style="color: #408080; font-style: italic"># no of time steps</span>


z0<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #666666">2</span>)
z0[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>

<span style="color: #408080; font-style: italic"># Prms for the analytical solution </span>
k1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(g<span style="color: #666666">*4*</span>rho_s<span style="color: #666666">*</span>d<span style="color: #666666">/</span>(<span style="color: #666666">3*</span>rho_f<span style="color: #666666">*</span>CD))
k2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">3*</span>rho_f<span style="color: #666666">*</span>g<span style="color: #666666">*</span>CD<span style="color: #666666">/</span>(<span style="color: #666666">4*</span>rho_s<span style="color: #666666">*</span>d))

Ndts <span style="color: #666666">=</span> <span style="color: #666666">4</span>  <span style="color: #408080; font-style: italic"># Number of times to divide the dt by 2 </span>
legends<span style="color: #666666">=</span>[]
error_diff <span style="color: #666666">=</span> []

<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ndts<span style="color: #666666">+1</span>):
    time <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)
    ze <span style="color: #666666">=</span> euler(f, z0, time)     <span style="color: #408080; font-style: italic"># compute response with constant CD using Euler&#39;s method</span>
    v_a <span style="color: #666666">=</span> k1<span style="color: #666666">*</span>np<span style="color: #666666">.</span>tanh(k2<span style="color: #666666">*</span>time)   <span style="color: #408080; font-style: italic"># compute response with constant CD using analytical solution</span>
    abs_error<span style="color: #666666">=</span>np<span style="color: #666666">.</span>abs(ze[:,<span style="color: #666666">1</span>] <span style="color: #666666">-</span> v_a)
    log_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>log10(abs_error[<span style="color: #666666">1</span>:])
    max_log_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>max(log_error)
    <span style="color: #408080; font-style: italic">#plot(time, ze[:,1])</span>
    plot(time[<span style="color: #666666">1</span>:], log_error)
    legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Euler scheme: N &#39;</span> <span style="color: #666666">+</span> <span style="color: #008000">str</span>(N) <span style="color: #666666">+</span> <span style="color: #BA2121">&#39; timesteps&#39;</span> )
    N<span style="color: #666666">*=2</span>
    <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>:
        error_diff<span style="color: #666666">.</span>append(previous_max_log_err<span style="color: #666666">-</span>max_log_error)

    previous_max_log_err <span style="color: #666666">=</span> max_log_error
    
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #666666">10**</span>(np<span style="color: #666666">.</span>mean(error_diff)), np<span style="color: #666666">.</span>mean(error_diff)


<span style="color: #408080; font-style: italic"># plot analytical solution</span>
<span style="color: #408080; font-style: italic"># plot(time,v_a)</span>
<span style="color: #408080; font-style: italic"># legends.append(&#39;analytical&#39;)</span>

<span style="color: #408080; font-style: italic"># fix plot </span>
legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
xlabel(<span style="color: #BA2121">&#39;Time [s]&#39;</span>)
<span style="color: #408080; font-style: italic">#ylabel(&#39;Velocity [m/s]&#39;)</span>
ylabel(<span style="color: #BA2121">&#39;log10-error&#39;</span>)
savefig(<span style="color: #BA2121">&#39;example_euler_timestep_study.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
show()
</pre></div>
<p>
The plot resulting from the code above is shown in Figure
(<a href="#fig:error_evolution">5</a>). The difference or distance between the
curves seems to be rather constant after an initial transient. As we
have plotted the logarithm of the absolute value of the error \( \epsilon_i \), the difference \( d_{i+1} \) between two curves is \( d_{i+1}=
\log10 \epsilon_{i}-\log10 \epsilon_{i+1} = \displaystyle \log10
\frac{\epsilon_{i}}{\epsilon_{i+1}} \). A rough visual inspection of Figure
(<a href="#fig:error_evolution">5</a>) yields \( d_{i+1} \approx 0.3 \), from which we may deduce:
$$
\begin{equation}
\log10
\frac{\epsilon_{i}}{\epsilon_{i+1}} \approx 0.3 \Rightarrow \epsilon_{i+1} \approx 10^{-0.3}\, \epsilon_{i} \approx 0.501\, \epsilon_{i}
\label{eq:error_approx}
\end{equation}
$$

<p>
The     print     statement     <code>print     10**(np.mean(error_diff)),
np.mean(error_diff)</code>  returns <code>2.04715154702  0.311149993907</code>, thus  we
see  that   the  error  is   reduced  even  slightly  more   than  the
theoretically expected value for a first order scheme, i.e. \( \Delta t_{i+1} = \Delta t_{i}/2 \) yields \( \epsilon_{i+1} \approx\epsilon_{i}/2 \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Plots for the logarithmic errors for a falling sphere with constant drag. The timestep \( \Delta t \) is reduced by a factor two from one curve to the one immediately below.<div id="fig:error_evolution"></div> </p></center>
<p><img src="fig-ch1/example_euler_timestep_study.png" align="bottom" width=600></p>
</center>

<p>
<!-- !split -->

<h3 id="___sec16">Euler's method for a system </h3>

Euler's method may of course also be used for a system. Let's look at a simultaneous system of \( p \) equations
$$
\begin{align}
&y'_1=f_1(x,y_1,y_2,\dots y_p) \nonumber\\ 
&y'_2=f_2(x,y_1,y_2,\dots y_p) \nonumber\\ 
&. \label{eq:1307a}\\ 
&.\nonumber\\ 
&y'_p=f_p(x,y_1,y_2,\dots y_p)\nonumber
\end{align}
$$

with initial values
$$
\begin{equation}
\label{eq:1307b}
y_1(x_0)=a_1,\ y_2(x_0)=a_2,\dots,\ y_p(x_0)=a_p
\end{equation}
$$

Or, in vectorial format as follows,
$$
\begin{align}
\label{eq:1308}
\mathbf{y'}&=\mathbf{f}(x,\mathbf{y})\\ 
\mathbf{y}&(x_0)=\mathbf{a} \nonumber
\end{align}
$$

where \( \mathbf{y'} \), \( \mathbf{f} \), \( \mathbf{y} \) and \( \mathbf{a} \) are column vectors with \( p \) components.

<p>
The Euler scheme \eqref{eq:1302} used on \eqref{eq:1308} gives
$$
\begin{equation}
\label{eq:1309}
\mathbf{y_{n+1}}=\mathbf{y_n}+h\cdot \mathbf{f}(x_n,\mathbf{y_n})
\end{equation}
$$

For a system of three equations we get
$$
\begin{align}
y'_1=&y_2\nonumber\\ 
y'_2=&y_3
\label{eq:13010}\\ 
y'_3=&-y_1y_3\nonumber
\end{align}
$$

In this case \eqref{eq:1309} gives
$$
\begin{align}
&(y_1)_{n+1}=(y_1)_n+h\cdot (y_2)_n\nonumber\\ 
&(y_2)_{n+1}=(y_2)_n+h\cdot (y_3)_n
\label{eq:13011}\\ 
&(y_3)_{n+1}=(y_3)_n-h\cdot (y_1)_n\cdot (y_3)_n\nonumber\\ 
\label{_auto14}
\end{align}
$$

with \( y_1(x_0)=a_1,\ y_2(x_0)=a_2,\text{ and }y_3(x_0)=a_3 \)

<p>
In the section <a href="#subsec:reduction">Reduction of Higher order Equations</a> we have seen how we can reduce a higher order ODE to a set of first order ODEs. In \eqref{eq:1303a} and \eqref{eq:1303b} we have the equation \( \frac{d^2z}{dt^2}=g-\alpha\cdot \left(\frac{dz}{dt}\right)^2 \) which we have reduced to a system as
$$
\begin{align*}
\frac{dz}{dt}= v&\\ 
\frac{dv}{dt}= g&-\alpha\cdot v^2
\end{align*}
$$

which gives an Euler scheme as follows,
$$
\begin{align*}
&z_{n+1}=z_n+\Delta t\cdot v_n\\ 
&v_{n+1}=n_n+\Delta t\cdot [g-\alpha(v_n)^2]\\ 
&\text{med }z_0=0,\ v_0=0
\end{align*}
$$

<p>
<!-- !split -->

<h1 id="___sec17">Heun's method </h1>

<p>
From \eqref{eq:1204a} or \eqref{eq:1205a} we have
$$
\begin{equation}
\label{eq:1401}
y''(x_n,y_n)=f'\left(x_n,y(x_n,y_n)\right)\approx \frac{f(x_n+h)-f(x_n)}{h}
\end{equation}
$$

The Taylor series expansion \eqref{eq:1203a} gives
$$
\begin{equation*}
y(x_n+h)=y(x_n)+hy'[x_n,y(x_n)]+\frac{h^2}{2}y''[x_n,y(x_n)]+O(h^3)
\end{equation*}
$$

which, inserting \eqref{eq:1401}, gives
$$
\begin{equation}
\label{eq:1402}
y_{n+1}=y_n+\frac{h}{2}\cdot [f(x_n,y_n)+f(x_{n+1},y(x_{n+1}))]
\end{equation}
$$

<p>
This formula is called the trapezoidal formula, since it reduces to computing an integral with the trapezoidal rule if \( f(x,y) \) is only a function of \( x \). Since \( y_{n+1} \) appears on both sides of the equation, this is an implicit formula which means that we need to solve a system of non-linear algebraic equations if the function \( f(x,y) \) is non-linear. One way of making the scheme explicit is to use the Euler scheme \eqref{eq:1302} to calculate \( y(x_{n+1}) \) on the right side of \eqref{eq:1402}. The resulting scheme is often denoted <b>Heun's method</b>.

<p>
The scheme for Heun's method becomes
$$
\begin{align}
&y^p_{n+1}=y_n+h\cdot f(x_n,y_n)
\label{eq:1403a} \\ 
&y_{n +1}=y_n+\frac{h}{2}\cdot[f(x_n,y_n)+f(x_{n+1},y^p_{n+1})]
\label{eq:1403b}
\end{align}
$$

Index \( p \) stands for "predicted". \eqref{eq:1403a} is then the predictor and \eqref{eq:1403b} is the corrector. This is a second order method. For more details, see <a href="#cheney2012numerical">[5]</a>. Figure <a href="#fig:illustration_heun">6</a> is a graphical illustration of the method.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 6:  Illustration of Heun's method. <div id="fig:illustration_heun"></div> </p></center>
<p><img src="fig-ch1/9.png" align="bottom" width=400></p>
</center>

<p>
In principle we could make an iteration procedure where we after using the corrector use the corrected values to correct the corrected values to make a new predictor and so on. This will likely lead to a more accurate solution of the difference scheme, but not necessarily of the differential equation. We are therefore satisfied by using the corrector once. For a system, we get
$$
\begin{align}
& \mathbf{y^p_{n+1}}=\mathbf{y_n}+h\cdot \mathbf{f}(x_n,\mathbf{y_n})
\label{eq:1404a}\\ 
& \mathbf{y_{n+1}}=\mathbf{y_n} +\frac{h}{2}\cdot [\mathbf{f}(x_n,\mathbf{y_n})+\mathbf{f}(x_{n+1},\mathbf{y^p_{n+1}})]
\label{eq:1404b}
\end{align}
$$

Note that \( \mathbf{y}^p_{n+1} \) is a temporary variable that is not necessary to store.

<p>
If we use \eqref{eq:1404a} and \eqref{eq:1404b} on the example in \eqref{eq:13010} we get

<p>
Predictor:
$$
\begin{align*}
(y_1)^p_{n+1}&=(y_1)_n+h\cdot (y_2)_n&\\ 
(y_2)^p_{n+1}&=(y_2)_n+h\cdot (y_3)_n&\\ 
(y_3)^p_{n+1}&=(y_3)_n-h\cdot (y_1)_n\cdot (y_3)_n
\end{align*}
$$

Corrector:
$$
\begin{align*}
(y_1)_{n+1}&=(y_1)_n+0.5h\cdot [(y_2)_n+(y_2)^p_{n+1}]&\\ 
(y_2)_{n+1}&=(y_2)_n+0.5h\cdot [(y_3)_n+(y_3)^p_{n+1}]&\\ 
(y_3)_{n+1}&=(y_3)_n-0.5h\cdot [(y_1)_n\cdot (y_3)_n+(y_1)^p_{n+1}\cdot (y_3)^p_{n+1}]
\end{align*}
$$

<p>
<!-- !split -->

<h2 id="___sec18">Example: Newton's equation </h2>

<p>
Let's use Heun's method to solve Newton's equation from the section <a href="#section:introduction">Introduction</a>,
$$
\begin{equation}
\label{eq:1405a}
y'(x)=1-3x+y+x^2+xy,\ y(0)=0
\end{equation}
$$

with analytical solution
$$
\begin{align}
y(x)=&3\sqrt{2\pi e}\cdot \exp\left(x\left(1+\frac{x}{2}\right)\right)\cdot \left[\mbox{erf}\left(\frac{\sqrt{2}}{2}(1+x)\right)-\mbox{erf}\left(\frac{\sqrt{2}}{2}\right)\right]\nonumber \\ 
	+&4\cdot \left[1-\exp\left(x\left(1+\frac{x}{2}\right)\right)\right]-x
\label{eq:1405b}
\end{align}
$$

<p>
Here we have \( f(x,y)=1-3x+y+x^2+xy = 1+x(x-3)+(1+x)y \)

<p>
The following program <b>NewtonHeun.py</b> solves this problem using Heun's method, and the resulting figure is shown in Figure <a href="#fig:newton_heun">7</a>.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter1/src-ch1/NewtonHeun.py</span>
<span style="color: #408080; font-style: italic"># Program Newton</span>
<span style="color: #408080; font-style: italic"># Computes the solution of Newton&#39;s 1st order equation (1671):</span>
<span style="color: #408080; font-style: italic"># dy/dx = 1-3*x + y + x^2 +x*y , y(0) = 0</span>
<span style="color: #408080; font-style: italic"># using Heun&#39;s method.</span>

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

xend <span style="color: #666666">=</span> <span style="color: #666666">2</span>
dx <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
steps <span style="color: #666666">=</span> np<span style="color: #666666">.</span>int(np<span style="color: #666666">.</span>round(xend<span style="color: #666666">/</span>dx, <span style="color: #666666">0</span>)) <span style="color: #666666">+</span> <span style="color: #666666">1</span> 
y, x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((steps,<span style="color: #666666">1</span>), <span style="color: #008000">float</span>), np<span style="color: #666666">.</span>zeros((steps,<span style="color: #666666">1</span>), <span style="color: #008000">float</span>)
y[<span style="color: #666666">0</span>], x[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>, <span style="color: #666666">0.0</span>

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,steps<span style="color: #666666">-1</span>):
    x[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> (n<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>dx
    xn <span style="color: #666666">=</span> x[n]
    fn <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> xn<span style="color: #666666">*</span>(xn<span style="color: #666666">-3</span>) <span style="color: #666666">+</span> y[n]<span style="color: #666666">*</span>(<span style="color: #666666">1+</span>xn)
    yp <span style="color: #666666">=</span> y[n] <span style="color: #666666">+</span> dx<span style="color: #666666">*</span>fn    
    xnp1 <span style="color: #666666">=</span> x[n<span style="color: #666666">+1</span>]
    fnp1 <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> xnp1<span style="color: #666666">*</span>(xnp1<span style="color: #666666">-3</span>) <span style="color: #666666">+</span> yp<span style="color: #666666">*</span>(<span style="color: #666666">1+</span>xnp1)
    y[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> y[n] <span style="color: #666666">+</span> <span style="color: #666666">0.5*</span>dx<span style="color: #666666">*</span>(fn<span style="color: #666666">+</span>fnp1)

<span style="color: #408080; font-style: italic"># Analytical solution</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scipy.special</span> <span style="color: #008000; font-weight: bold">import</span> erf
a <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">2</span>)<span style="color: #666666">/2</span>
t1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>exp(x<span style="color: #666666">*</span>(<span style="color: #666666">1+</span> x<span style="color: #666666">/2</span>))
t2 <span style="color: #666666">=</span> erf((<span style="color: #666666">1+</span>x)<span style="color: #666666">*</span>a)<span style="color: #666666">-</span>erf(a)
ya <span style="color: #666666">=</span> <span style="color: #666666">3*</span>np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>np<span style="color: #666666">.</span>exp(<span style="color: #666666">1</span>))<span style="color: #666666">*</span>t1<span style="color: #666666">*</span>t2 <span style="color: #666666">+</span> <span style="color: #666666">4*</span>(<span style="color: #666666">1-</span>t1)<span style="color: #666666">-</span>x

<span style="color: #408080; font-style: italic"># plotting</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pylab</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">py</span>
py<span style="color: #666666">.</span>plot(x, y, <span style="color: #BA2121">&#39;-b.&#39;</span>, x, ya, <span style="color: #BA2121">&#39;-g.&#39;</span>)
py<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x&#39;</span>)
py<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;y&#39;</span>)
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}
py<span style="color: #666666">.</span>rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)
py<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Solution to Newton</span><span style="color: #BB6622; font-weight: bold">\&#39;</span><span style="color: #BA2121">s equation&#39;</span>)
py<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;Heun&#39;</span>, <span style="color: #BA2121">&#39;Analytical&#39;</span>], loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
py<span style="color: #666666">.</span>grid()
py<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;newton_heun.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
py<span style="color: #666666">.</span>show()
</pre></div>
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 7:  Velocity of falling sphere using Euler's and Heun's methods. <div id="fig:newton_heun"></div> </p></center>
<p><img src="fig-ch1/newton_heun.png" align="bottom" width=400></p>
</center>

<p>
<!-- !split -->

<h2 id="___sec19">Example: Falling sphere with Heun's method </h2>

<p>
Let's go back to (<a href="#ex:falling_sphere">Example: Falling sphere with constant and varying drag</a>), and implement a new function <code>heun()</code> in the program <a href="https://lrhgit.github.io/tkt4140/allfiles/digital_compendium/./src-ch1/FallingSphereEuler.py" target="_self">FallingSphereEuler.py</a>.

<p>
We recall the system of equations as
$$
\begin{align*}
&\frac{dz}{dt}=v\\ 
&\frac{dv}{dt}=g-\alpha v^2
\end{align*}
$$

which by use of Heun's method in \eqref{eq:1404a} and \eqref{eq:1404b} becomes

<p>
Predictor:
$$
\begin{align}
z^p_{n+1}&=z_n+\Delta t v_n 
\label{_auto15}\\ 
v^p_{n+1}&= v_n +\Delta t \cdot (g-\alpha v^2_n) \nonumber
\end{align}
$$

Corrector:
$$
\begin{align}
z_{n+1}&=z_n+0.5\Delta t \cdot (v_n+v^p_{n+1}) 
\label{_auto16}\\ 
v_{n+1}&=v_n+0.5\Delta t \cdot \left[2g-\alpha[v^2_n+(v^p_{n+1})^2\right] \nonumber
\end{align}
$$

with initial values \( z_0=z(0)=0,\ v_0=v(0)=0 \). Note that we don't use the predictor \( z^p_{n+1} \) since it doesn't appear on the right hand side of the equation system.

<p>
One possible way of implementing this scheme is given in the following function named <code>heun()</code>, in the program <b>ODEschemes.py</b>:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">heun</span>(func, z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Heun scheme for solution of systems of ODEs.</span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions,</span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns</span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f_np</span>(z,t):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;A local function to ensure that the return of func is an np array</span>
<span style="color: #BA2121; font-style: italic">        and to avoid lengthy code for implementation of the Heun algorithm&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>asarray(func(z,t))

    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time), np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0
    zp <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z0)

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]):
        dt <span style="color: #666666">=</span> time[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> time[i]
        zp <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> f_np(z[i,:],t)<span style="color: #666666">*</span>dt   <span style="color: #408080; font-style: italic"># Predictor step</span>
        z[i<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> (f_np(z[i,:],t) <span style="color: #666666">+</span> f_np(zp,t<span style="color: #666666">+</span>dt))<span style="color: #666666">*</span>dt<span style="color: #666666">/2.0</span> <span style="color: #408080; font-style: italic"># Corrector step</span>
</pre></div>
<p>
Using the same time steps as in (<a href="#ex:falling_sphere">Example: Falling sphere with constant and varying drag</a>), we get the response plotted in Figure <a href="#fig:falling_sphere_euler_heun">8</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 8:  Velocity of falling sphere using Euler's and Heun's methods. <div id="fig:falling_sphere_euler_heun"></div> </p></center>
<p><img src="fig-ch1/example_sphere_falling_euler_heun.png" align="bottom" width=400></p>
</center>

<p>
The complete program <b>FallingSphereEulerHeun.py</b> is listed below. Note that the solver functions <code>euler</code> and <code>heun</code> are imported from the script <b>ODEschemes.py</b>.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter1/src-ch1/FallingSphereEulerHeun.py;ODEschemes.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/src-ch1/ODEschemes.py;</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">DragCoefficientGeneric</span> <span style="color: #008000; font-weight: bold">import</span> cd_sphere
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">ODEschemes</span> <span style="color: #008000; font-weight: bold">import</span> euler, heun
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #408080; font-style: italic"># change some default values to make plots more readable </span>
LNWDT<span style="color: #666666">=5</span>; FNT<span style="color: #666666">=11</span>
rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT

g <span style="color: #666666">=</span> <span style="color: #666666">9.81</span>      <span style="color: #408080; font-style: italic"># Gravity m/s^2</span>
d <span style="color: #666666">=</span> <span style="color: #666666">41.0e-3</span>   <span style="color: #408080; font-style: italic"># Diameter of the sphere</span>
rho_f <span style="color: #666666">=</span> <span style="color: #666666">1.22</span>  <span style="color: #408080; font-style: italic"># Density of fluid [kg/m^3]</span>
rho_s <span style="color: #666666">=</span> <span style="color: #666666">1275</span>  <span style="color: #408080; font-style: italic"># Density of sphere [kg/m^3]</span>
nu <span style="color: #666666">=</span> <span style="color: #666666">1.5e-5</span>   <span style="color: #408080; font-style: italic"># Kinematical viscosity [m^2/s]</span>
CD <span style="color: #666666">=</span> <span style="color: #666666">0.4</span>      <span style="color: #408080; font-style: italic"># Constant drag coefficient</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;2x2 system for sphere with constant drag.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    alpha <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)<span style="color: #666666">*</span>CD
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>], g <span style="color: #666666">-</span> alpha<span style="color: #666666">*</span>z[<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>]
    <span style="color: #008000; font-weight: bold">return</span> zout 

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f2</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;2x2 system for sphere with Re-dependent drag.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    v <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(z[<span style="color: #666666">1</span>]) 
    Re <span style="color: #666666">=</span> v<span style="color: #666666">*</span>d<span style="color: #666666">/</span>nu
    CD <span style="color: #666666">=</span> cd_sphere(Re)
    alpha <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)<span style="color: #666666">*</span>CD
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>], g <span style="color: #666666">-</span> alpha<span style="color: #666666">*</span>z[<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>]
    <span style="color: #008000; font-weight: bold">return</span> zout
        
<span style="color: #408080; font-style: italic"># main program starts here</span>

T <span style="color: #666666">=</span> <span style="color: #666666">10</span>  <span style="color: #408080; font-style: italic"># end of simulation</span>
N <span style="color: #666666">=</span> <span style="color: #666666">20</span>  <span style="color: #408080; font-style: italic"># no of time steps</span>
time <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)

z0<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #666666">2</span>)
z0[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>

ze <span style="color: #666666">=</span> euler(f, z0, time)     <span style="color: #408080; font-style: italic"># compute response with constant CD using Euler&#39;s method</span>
ze2 <span style="color: #666666">=</span> euler(f2, z0, time)   <span style="color: #408080; font-style: italic"># compute response with varying CD using Euler&#39;s method</span>

zh <span style="color: #666666">=</span> heun(f, z0, time)     <span style="color: #408080; font-style: italic"># compute response with constant CD using Heun&#39;s method</span>
zh2 <span style="color: #666666">=</span> heun(f2, z0, time)   <span style="color: #408080; font-style: italic"># compute response with varying CD using Heun&#39;s method</span>

k1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(g<span style="color: #666666">*4*</span>rho_s<span style="color: #666666">*</span>d<span style="color: #666666">/</span>(<span style="color: #666666">3*</span>rho_f<span style="color: #666666">*</span>CD))
k2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">3*</span>rho_f<span style="color: #666666">*</span>g<span style="color: #666666">*</span>CD<span style="color: #666666">/</span>(<span style="color: #666666">4*</span>rho_s<span style="color: #666666">*</span>d))
v_a <span style="color: #666666">=</span> k1<span style="color: #666666">*</span>np<span style="color: #666666">.</span>tanh(k2<span style="color: #666666">*</span>time)   <span style="color: #408080; font-style: italic"># compute response with constant CD using analytical solution</span>

<span style="color: #408080; font-style: italic"># plotting</span>

legends<span style="color: #666666">=</span>[]
line_type<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;-&#39;</span>,<span style="color: #BA2121">&#39;:&#39;</span>,<span style="color: #BA2121">&#39;.&#39;</span>,<span style="color: #BA2121">&#39;-.&#39;</span>,<span style="color: #BA2121">&#39;--&#39;</span>]

plot(time, v_a, line_type[<span style="color: #666666">0</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Analytical (constant CD)&#39;</span>)

plot(time, ze[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">1</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Euler (constant CD)&#39;</span>)

plot(time, zh[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">2</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Heun (constant CD)&#39;</span>)

plot(time, ze2[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">3</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Euler (varying CD)&#39;</span>)

plot(time, zh2[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">4</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Heun (varying CD)&#39;</span>)

legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}
rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)
xlabel(<span style="color: #BA2121">&#39;Time [s]&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;Velocity [m/s]&#39;</span>)
savefig(<span style="color: #BA2121">&#39;example_sphere_falling_euler_heun.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
show()
</pre></div>
<p>
<!-- !split -->

<h1 id="___sec20">Runge-Kutta of 4th order </h1>

<p>
Euler's method and Heun's method belong to the Runge-Kutta family of explicit methods, and is respectively Runge-Kutta of 1st and 2nd order, the latter with one time use of corrector. Explicit Runge-Kutta schemes are single step schemes that try to copy the Taylor series expansion of the differential equation to a given order.

<p>
The classical Runge-Kutta scheme of 4th order (RK4) is given by
$$
\begin{align}
&k_1=f(x_n,y_n)\nonumber\\ 
&k_2=f(x_n+\frac{h}{2}, y_n+\frac{h}{2}k_1)\nonumber\\ 
\label{eq:1501}
&k_3=f(x_n+\frac{h}{2},y_n+\frac{h}{2}k_2)\\ 
&k_4=f(x_n+h,y_n+hk_3)\nonumber\\ 
&y_{n+1}=y_n+\frac{h}{6}(k_1+2k_2+2k_3+k_4)\nonumber
\end{align}
$$

<p>
We see that we are actually using Euler's method four times and find a weighted gradient. The local error is of order \( O(h^5) \), while the global is of \( O(h^4) \). We refer to <a href="#cheney2012numerical">[5]</a>.

<p>
Figure <a href="#fig:RK4_illustration">9</a> shows a graphical illustration of the RK4 scheme.

<p>
In detail we have

<ol>
 <li> In point \( (x_n,y_n) \) we know the gradient \( k_1 \) and use this when we go forward a step \( h/2 \) where the gradient \( k_2 \) is calculated.</li>
 <li> With this gradient we start again in point \( (x_n,y_n) \), go forward a step \( h/2 \) and find a new gradient \( k_3 \).</li>
 <li> With this gradient we start again in point \( (x_n,y_n) \), but go forward a complete step \( h \) and find a new gradient \( k_4 \).</li>
 <li> The four gradients are averaged with weights \( 1/6 \), \( 2/6 \), \( 2/6 \) and \( 1/6 \). Using the averaged gradient we calculate the final value \( y_{n+1} \).</li>
</ol>

Each of the steps above are Euler steps.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 9:  Illustration of the RK4 scheme. <div id="fig:RK4_illustration"></div> </p></center>
<p><img src="fig-ch1/12.png" align="bottom" width=400></p>
</center>

<p>
Using \eqref{eq:1501} on the equation system in \eqref{eq:13010} we get
$$
\begin{align}
&(y_1)_{n+1}=(y_1)_n +\frac{h}{6}(k_1+2k_2+2k_3+k_4) \nonumber\\ 
&(y_2)_{n+1}=(y_2)_n +\frac{h}{6}(l_1+2l_2+2l_3+l_4)
\label{eq:1502} \\ 
&(y_3)_{n+1}=(y_3)_n +\frac{h}{6}(m_1+2m_2+2m_3+m_4) \nonumber\\ 
\label{_auto17}
\end{align}
$$

where
$$
\begin{align*}
k_1&=y_2 \\ 
l_1&=y_3 \\ 
m_1&=-y_1y_3\\ 
\\ 
k_2&=(y_2+hl_l/2)\\ 
l_2&=(y_3+hm_1/2)\\ 
m_2&=-[(y_1+hk_1/2)(y_3+hm_1/2)]\\ 
\\ 
k_3&=(y_2+hl_2/2)\\ 
l_3&=(y_3+hm_2/2)\\ 
m_3&=-[(y_1+hk_2/2)(y_3+hm_2/2)]\\ 
\\ 
k_4&=(y_2+hl_3)\\ 
l_4&=(y_3+hm_3)\\ 
m_4&=-[(y_1+hk_3)(y_3+hm_3)
\end{align*}
$$

<p>
<!-- !split -->

<h2 id="example:falling_sphere_RK4">Example: Falling sphere using RK4</h2>

<p>
Let's implement the RK4 scheme and add it to the falling sphere example. The scheme has been implemented in the function <code>rk4()</code>, and is given below

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">rk4</span>(func, z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Runge-Kutta 4 scheme for solution of systems of ODEs.</span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions,</span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns</span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>

    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time),np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0
    zp <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z0)

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]):
        dt <span style="color: #666666">=</span> time[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> time[i]
        dt2 <span style="color: #666666">=</span> dt<span style="color: #666666">/2.0</span>
        k1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(func(z[i,:], t))                <span style="color: #408080; font-style: italic"># predictor step 1</span>
        k2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(func(z[i,:] <span style="color: #666666">+</span> k1<span style="color: #666666">*</span>dt2, t <span style="color: #666666">+</span> dt2)) <span style="color: #408080; font-style: italic"># predictor step 2</span>
        k3 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(func(z[i,:] <span style="color: #666666">+</span> k2<span style="color: #666666">*</span>dt2, t <span style="color: #666666">+</span> dt2)) <span style="color: #408080; font-style: italic"># predictor step 3</span>
        k4 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(func(z[i,:] <span style="color: #666666">+</span> k3<span style="color: #666666">*</span>dt, t <span style="color: #666666">+</span> dt))   <span style="color: #408080; font-style: italic"># predictor step 4</span>
        z[i<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> dt<span style="color: #666666">/6.0*</span>(k1 <span style="color: #666666">+</span> <span style="color: #666666">2.0*</span>k2 <span style="color: #666666">+</span> <span style="color: #666666">2.0*</span>k3 <span style="color: #666666">+</span> k4) <span style="color: #408080; font-style: italic"># Corrector step</span>
</pre></div>
<p>
Figure <a href="#fig:falling_sphere_euler_heun_rk4">10</a> shows the results using Euler, Heun and RK4. AS seen, RK4 and Heun are more accurate than Euler. The complete program <b>FallingSphereEulerHeunRK4.py</b> is listed below. The functions <code>euler</code>, <code>heun</code> and <code>rk4</code> are imported from the program <b>ODEschemes.py</b>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 10:  Velocity of falling sphere using Euler, Heun and RK4. <div id="fig:falling_sphere_euler_heun_rk4"></div> </p></center>
<p><img src="fig-ch1/example_sphere_falling_euler_heun_rk4.png" align="bottom" width=400></p>
</center>

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter1/src-ch1/FallingSphereEulerHeunRK4.py;ODEschemes.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/src-ch1/ODEschemes.py;</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">DragCoefficientGeneric</span> <span style="color: #008000; font-weight: bold">import</span> cd_sphere
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">ODEschemes</span> <span style="color: #008000; font-weight: bold">import</span> euler, heun, rk4 
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #408080; font-style: italic"># change some default values to make plots more readable </span>
LNWDT<span style="color: #666666">=5</span>; FNT<span style="color: #666666">=11</span>
rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT

g <span style="color: #666666">=</span> <span style="color: #666666">9.81</span>      <span style="color: #408080; font-style: italic"># Gravity m/s^2</span>
d <span style="color: #666666">=</span> <span style="color: #666666">41.0e-3</span>   <span style="color: #408080; font-style: italic"># Diameter of the sphere</span>
rho_f <span style="color: #666666">=</span> <span style="color: #666666">1.22</span>  <span style="color: #408080; font-style: italic"># Density of fluid [kg/m^3]</span>
rho_s <span style="color: #666666">=</span> <span style="color: #666666">1275</span>  <span style="color: #408080; font-style: italic"># Density of sphere [kg/m^3]</span>
nu <span style="color: #666666">=</span> <span style="color: #666666">1.5e-5</span>   <span style="color: #408080; font-style: italic"># Kinematical viscosity [m^2/s]</span>
CD <span style="color: #666666">=</span> <span style="color: #666666">0.4</span>      <span style="color: #408080; font-style: italic"># Constant drag coefficient</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;2x2 system for sphere with constant drag.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    alpha <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)<span style="color: #666666">*</span>CD
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>], g <span style="color: #666666">-</span> alpha<span style="color: #666666">*</span>z[<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>]
    <span style="color: #008000; font-weight: bold">return</span> zout 

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f2</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;2x2 system for sphere with Re-dependent drag.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    v <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(z[<span style="color: #666666">1</span>]) 
    Re <span style="color: #666666">=</span> v<span style="color: #666666">*</span>d<span style="color: #666666">/</span>nu
    CD <span style="color: #666666">=</span> cd_sphere(Re)
    alpha <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)<span style="color: #666666">*</span>CD
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>], g <span style="color: #666666">-</span> alpha<span style="color: #666666">*</span>z[<span style="color: #666666">1</span>]<span style="color: #666666">**2</span>]
    <span style="color: #008000; font-weight: bold">return</span> zout

<span style="color: #408080; font-style: italic"># main program starts here</span>

T <span style="color: #666666">=</span> <span style="color: #666666">10</span>  <span style="color: #408080; font-style: italic"># end of simulation</span>
N <span style="color: #666666">=</span> <span style="color: #666666">20</span>  <span style="color: #408080; font-style: italic"># no of time steps</span>
time <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)

z0<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #666666">2</span>)
z0[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>

ze <span style="color: #666666">=</span> euler(f, z0, time)     <span style="color: #408080; font-style: italic"># compute response with constant CD using Euler&#39;s method</span>
ze2 <span style="color: #666666">=</span> euler(f2, z0, time)   <span style="color: #408080; font-style: italic"># compute response with varying CD using Euler&#39;s method</span>

zh <span style="color: #666666">=</span> heun(f, z0, time)     <span style="color: #408080; font-style: italic"># compute response with constant CD using Heun&#39;s method</span>
zh2 <span style="color: #666666">=</span> heun(f2, z0, time)   <span style="color: #408080; font-style: italic"># compute response with varying CD using Heun&#39;s method</span>

zrk4 <span style="color: #666666">=</span> rk4(f, z0, time)     <span style="color: #408080; font-style: italic"># compute response with constant CD using RK4</span>
zrk4_2 <span style="color: #666666">=</span> rk4(f2, z0, time)  <span style="color: #408080; font-style: italic"># compute response with varying CD using RK4</span>

k1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(g<span style="color: #666666">*4*</span>rho_s<span style="color: #666666">*</span>d<span style="color: #666666">/</span>(<span style="color: #666666">3*</span>rho_f<span style="color: #666666">*</span>CD))
k2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(<span style="color: #666666">3*</span>rho_f<span style="color: #666666">*</span>g<span style="color: #666666">*</span>CD<span style="color: #666666">/</span>(<span style="color: #666666">4*</span>rho_s<span style="color: #666666">*</span>d))
v_a <span style="color: #666666">=</span> k1<span style="color: #666666">*</span>np<span style="color: #666666">.</span>tanh(k2<span style="color: #666666">*</span>time)   <span style="color: #408080; font-style: italic"># compute response with constant CD using analytical solution</span>

<span style="color: #408080; font-style: italic"># plotting</span>

legends<span style="color: #666666">=</span>[]
line_type<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;-&#39;</span>,<span style="color: #BA2121">&#39;:&#39;</span>,<span style="color: #BA2121">&#39;.&#39;</span>,<span style="color: #BA2121">&#39;-.&#39;</span>,<span style="color: #BA2121">&#39;:&#39;</span>,<span style="color: #BA2121">&#39;.&#39;</span>,<span style="color: #BA2121">&#39;-.&#39;</span>]

plot(time, v_a, line_type[<span style="color: #666666">0</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Analytical (constant CD)&#39;</span>)

plot(time, ze[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">1</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Euler (constant CD)&#39;</span>)

plot(time, zh[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">2</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Heun (constant CD)&#39;</span>)

plot(time, zrk4[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">3</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;RK4 (constant CD)&#39;</span>)

plot(time, ze2[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">4</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Euler (varying CD)&#39;</span>)

plot(time, zh2[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">5</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Heun (varying CD)&#39;</span>)

plot(time, zrk4_2[:,<span style="color: #666666">1</span>], line_type[<span style="color: #666666">6</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;RK4 (varying CD)&#39;</span>)

legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)

font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}
rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)
xlabel(<span style="color: #BA2121">&#39;Time [s]&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;Velocity [m/s]&#39;</span>)
savefig(<span style="color: #BA2121">&#39;example_sphere_falling_euler_heun_rk4.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
show()
</pre></div>
<p>
<!-- !split -->

<h2 id="___sec22">Example: Particle motion in two dimensions </h2>
In this example we will calculate the motion of a particle in two dimensions. First we will calculate the motion of a smooth ball with drag coefficient given by the previously defined function <code>cd_sphere()</code> (see (<a href="#example:sphere_freefall">Example: Sphere in free fall</a>)), and then of a golf ball with drag and lift.

<p>
The problem is illustrated in the following figure:
<center><p><img src="fig-ch1/14.png" align="bottom" width=400></p></center>

<p>
where \( v \) is the absolute velocity, \( v_f= \) is the velocity of the fluid, \( v_r=v-v_f \) is the relative velocity between the fluid and the ball, \( \alpha \) is the elevation angle, \( v_0 \) is the initial velocity and \( \phi \) is the angle between the \( x \)-axis and \( v_r \).

<p>
\( \mathbf{F}_l \) is the lift force stemming from the rotation of the ball (the Magnus-effect) and is normal to \( v_r \). With the given direction the ball rotates counter-clockwise (backspin). \( \mathbf{F}_d \) is the fluids resistance against the motion and is parallel to \( v_r \). These forces are given by
$$
\begin{align}
\mathbf{F}_d=\frac{1}{2}\rho _f AC_Dv_r^2
\label{eq:1504a}\\ 
\mathbf{F}_l=\frac{1}{2}\rho _f AC_Lv_r^2
\label{eq:150b}
\end{align}
$$

<p>
\( C_D \) is the drag coefficient, \( C_L \) is the lift coefficient, \( A \) is the area projected in the velocity direction and \( \rho_F \) is the density of the fluid.

<p>
Newton's law in \( x \)- and \( y \)-directions gives
$$
\begin{align}
\label{eq:1505a}
\frac{dv_x}{dt}&= -\rho _f\frac{A}{2m}v_r^2(C_D\cdot \cos(\phi)+C_L\sin(\phi)) \\ 
\frac{dv_y}{dt}&=\rho _f\frac{A}{2m}v_r^2(C_L\cdot \cos(\phi)-C_D\sin(\phi))-g
\label{eq:1505b}
\end{align}
$$

<p>
From the figure we have
$$
\begin{align*}
\cos (\phi)&=\frac{v_{rx}}{v_r} \\ 
\sin(\phi)&=\frac{v_{ry}}{v_r}
\end{align*}
$$

<p>
We assume that the particle is a sphere, such that \( C=\rho _f\frac{A}{2m}=\frac{3\rho_f}{4\rho_kd} \) as in (<a href="#example:sphere_freefall">Example: Sphere in free fall</a>). Here \( d \) is the diameter of the sphere and \( \rho_k \) the density of the sphere.

<p>
Now \eqref{eq:1505a} and \eqref{eq:1505b} become
$$
\begin{align}
\label{eq:1506a}
\frac{dv_x}{dt} &= -C\cdot v_r(C_D\cdot v_{rx}+C_L\cdot v_{ry})\\ 
\frac{dv_y}{dt} &= C\cdot v_r(C_L\cdot v_{rx}-C_D\cdot v_{ry})-
\label{eq:1506b}g
\end{align}
$$

<p>
With \( \frac{dx}{dt}=v_x \) and \( \frac{dy}{dt}=v_y \) we get a system of 1st order equations as follows,
$$
\begin{align}
&\frac{dx}{dt}=v_x \nonumber \\ 
& \frac{dy}{dt}=v_y \nonumber\\ 
& \frac{dv_x}{dt} = -C\cdot v_r(C_D\cdot v_{rx}+C_L\cdot v_{ry})
\label{eq:1507}\\ 
&\frac{dv_y}{dt} = C\cdot v_r(C_L\cdot v_{rx}-C_D\cdot v_{ry})-g \nonumber
\end{align}
$$

<p>
Introducing the notation \( x=y_1 \), \( y=y_2 \), \( v_x=y_3 \), \( v_y=y_4 \), we get
$$
\begin{align}
&\frac{dy_1}{dt}=y_3\nonumber\\ 
& \frac{dy_2}{dt}=y_4\nonumber\\ 
& \frac{dy_3}{dt} = -C\cdot v_r(C_D\cdot v_{rx}+C_L\cdot v_{ry})
\label{eq:1508}\\ 
&\frac{dy_4}{dt} = C\cdot v_r(C_L\cdot v_{rx}-C_D\cdot v_{ry})-g\nonumber
\end{align}
$$

<p>
Here we have \( v_{rx}=v_x-v_{fx}=y_3-v_{fx},\ v_{ry}=v_y-v_{fy}=y_4-v_{fy},\\ v_r=\sqrt{v_{rx}^2+v_{ry}^2} \)

<p>
Initial conditions for \( t=0 \) are
$$
\begin{align*}
y_1&=y_2=0 \\ 
y_3&=v_0\cos(\alpha)\\ 
y_4&=v_0\sin(\alpha)
\end{align*}
$$

<p>
<hr>

<p>
Let's first look at the case of a smooth ball. We use the following data (which are the data for a golf ball):
$$
\begin{equation*}
\label{eq:1509}
\text{Diameter } d = 41 \text{mm},\text{ mass } m = 46\text{g which gives } \rho_k=\frac{6m}{\pi d^3} = 1275 \text{kg/m}^3
\end{equation*}
$$

We use the initial velocity \( v_0=50 \) m/s and solve \eqref{eq:1508} using the Runge-Kutta 4 scheme. In this example we have used the Python package <b>Odespy</b> (ODE Software in Python), which offers a large collection of functions for solving ODE's. The RK4 scheme available in Odespy is used herein.

<p>
The right hand side in \eqref{eq:1508} is implemented as the following function:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;4x4 system for smooth sphere with drag in two directions.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    C <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)
    vrx <span style="color: #666666">=</span> z[<span style="color: #666666">2</span>] <span style="color: #666666">-</span> vfx
    vry <span style="color: #666666">=</span> z[<span style="color: #666666">3</span>] <span style="color: #666666">-</span> vfy
    vr <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(vrx<span style="color: #666666">**2</span> <span style="color: #666666">+</span> vry<span style="color: #666666">**2</span>)
    Re <span style="color: #666666">=</span> vr<span style="color: #666666">*</span>d<span style="color: #666666">/</span>nu
    CD <span style="color: #666666">=</span> cd_sphere(Re) <span style="color: #408080; font-style: italic"># using the already defined function</span>
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">2</span>], z[<span style="color: #666666">3</span>], <span style="color: #666666">-</span>C<span style="color: #666666">*</span>vr<span style="color: #666666">*</span>(CD<span style="color: #666666">*</span>vrx), C<span style="color: #666666">*</span>vr<span style="color: #666666">*</span>(<span style="color: #666666">-</span>CD<span style="color: #666666">*</span>vry) <span style="color: #666666">-</span> g]
</pre></div>
<p>
Note that we have used the function <code>cd_sphere()</code> defined in (<a href="#example:sphere_freefall">Example: Sphere in free fall</a>) to calculate the drag coefficient of the smooth sphere.

<p>
The results are shown for some initial angles in Figure <a href="#fig:smooth_ball_drag">11</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 11:  Motion of smooth ball with drag. <div id="fig:smooth_ball_drag"></div> </p></center>
<p><img src="fig-ch1/example_particle_motion_2d_1.png" align="bottom" width=700></p>
</center>

<p>
<hr>

<p>
Now let's look at the same case for a golf ball. The dimension and weight are the same as for the sphere. Now we need to account for the lift force from the spin of the ball. In addition, the drag data for a golf ball are completely different from the smooth sphere. We use the data from Bearman and Harvey <a href="#Bearman1976112">[6]</a> who measured the drag and lift of a golf ball for different spin velocities in a vindtunnel. We choose as an example 3500 rpm, and an initial velocity of \( v_0=50 \) m/s.

<p>
The right hand side in \eqref{eq:1508} is now implemented as the following function:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f3</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;4x4 system for golf ball with drag and lift in two directions.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    C <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)
    vrx <span style="color: #666666">=</span> z[<span style="color: #666666">2</span>] <span style="color: #666666">-</span> vfx
    vry <span style="color: #666666">=</span> z[<span style="color: #666666">3</span>] <span style="color: #666666">-</span> vfy
    vr <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(vrx<span style="color: #666666">**2</span> <span style="color: #666666">+</span> vry<span style="color: #666666">**2</span>)
    Re <span style="color: #666666">=</span> vr<span style="color: #666666">*</span>d<span style="color: #666666">/</span>nu
    CD, CL <span style="color: #666666">=</span> cdcl(vr, nrpm)
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">2</span>], z[<span style="color: #666666">3</span>], <span style="color: #666666">-</span>C<span style="color: #666666">*</span>vr<span style="color: #666666">*</span>(CD<span style="color: #666666">*</span>vrx <span style="color: #666666">+</span> CL<span style="color: #666666">*</span>vry), C<span style="color: #666666">*</span>vr<span style="color: #666666">*</span>(CL<span style="color: #666666">*</span>vrx <span style="color: #666666">-</span> CD<span style="color: #666666">*</span>vry) <span style="color: #666666">-</span> g]
</pre></div>
<p>
The function <code>cdcl()</code> (may be downloaded <a href="https://lrhgit.github.io/tkt4140/allfiles/digital_compendium/./src-ch1/cdclgolfball.py" target="_self">here</a>) gives the drag and lift data for a given velocity and spin.

<p>
The results are shown in Figure <a href="#fig:golf_drag_lift">12</a>. The motion of a golf ball with drag but without lift is also included. We see that the golf ball goes much farther than the smooth sphere, due to less drag and the lift.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 12:  Motion of golf ball with drag and lift. <div id="fig:golf_drag_lift"></div> </p></center>
<p><img src="fig-ch1/example_particle_motion_2d_2.png" align="bottom" width=700></p>
</center>

<p>
The complete program <b>ParticleMotion2D.py</b> is listed below.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter1/src-ch1/ParticleMotion2D.py;DragCoefficientGeneric.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/src-ch1/DragCoefficientGeneric.py;cdclgolfball.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter1/src-ch1/cdclgolfball.py;</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">DragCoefficientGeneric</span> <span style="color: #008000; font-weight: bold">import</span> cd_sphere
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cdclgolfball</span> <span style="color: #008000; font-weight: bold">import</span> cdcl  
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">odespy</span>

g <span style="color: #666666">=</span> <span style="color: #666666">9.81</span>      <span style="color: #408080; font-style: italic"># Gravity [m/s^2]</span>
nu <span style="color: #666666">=</span> <span style="color: #666666">1.5e-5</span>   <span style="color: #408080; font-style: italic"># Kinematical viscosity [m^2/s]</span>
rho_f <span style="color: #666666">=</span> <span style="color: #666666">1.20</span>  <span style="color: #408080; font-style: italic"># Density of fluid [kg/m^3]</span>
rho_s <span style="color: #666666">=</span> <span style="color: #666666">1275</span>  <span style="color: #408080; font-style: italic"># Density of sphere [kg/m^3]</span>
d <span style="color: #666666">=</span> <span style="color: #666666">41.0e-3</span>   <span style="color: #408080; font-style: italic"># Diameter of the sphere [m]</span>
v0 <span style="color: #666666">=</span> <span style="color: #666666">50.0</span>     <span style="color: #408080; font-style: italic"># Initial velocity [m/s]</span>
vfx <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>     <span style="color: #408080; font-style: italic"># x-component of fluid&#39;s velocity</span>
vfy <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>     <span style="color: #408080; font-style: italic"># y-component of fluid&#39;s velocity</span>

nrpm <span style="color: #666666">=</span> <span style="color: #666666">3500</span>   <span style="color: #408080; font-style: italic"># no of rpm of golf ball</span>

<span style="color: #408080; font-style: italic"># smooth ball</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;4x4 system for smooth sphere with drag in two directions.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    C <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)
    vrx <span style="color: #666666">=</span> z[<span style="color: #666666">2</span>] <span style="color: #666666">-</span> vfx
    vry <span style="color: #666666">=</span> z[<span style="color: #666666">3</span>] <span style="color: #666666">-</span> vfy
    vr <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(vrx<span style="color: #666666">**2</span> <span style="color: #666666">+</span> vry<span style="color: #666666">**2</span>)
    Re <span style="color: #666666">=</span> vr<span style="color: #666666">*</span>d<span style="color: #666666">/</span>nu
    CD <span style="color: #666666">=</span> cd_sphere(Re) <span style="color: #408080; font-style: italic"># using the already defined function</span>
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">2</span>], z[<span style="color: #666666">3</span>], <span style="color: #666666">-</span>C<span style="color: #666666">*</span>vr<span style="color: #666666">*</span>(CD<span style="color: #666666">*</span>vrx), C<span style="color: #666666">*</span>vr<span style="color: #666666">*</span>(<span style="color: #666666">-</span>CD<span style="color: #666666">*</span>vry) <span style="color: #666666">-</span> g]
    <span style="color: #008000; font-weight: bold">return</span> zout 

<span style="color: #408080; font-style: italic"># golf ball without lift</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f2</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;4x4 system for golf ball with drag in two directions.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    C <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)
    vrx <span style="color: #666666">=</span> z[<span style="color: #666666">2</span>] <span style="color: #666666">-</span> vfx
    vry <span style="color: #666666">=</span> z[<span style="color: #666666">3</span>] <span style="color: #666666">-</span> vfy
    vr <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(vrx<span style="color: #666666">**2</span> <span style="color: #666666">+</span> vry<span style="color: #666666">**2</span>)
    Re <span style="color: #666666">=</span> vr<span style="color: #666666">*</span>d<span style="color: #666666">/</span>nu
    CD, CL <span style="color: #666666">=</span> cdcl(vr, nrpm)
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">2</span>], z[<span style="color: #666666">3</span>], <span style="color: #666666">-</span>C<span style="color: #666666">*</span>vr<span style="color: #666666">*</span>(CD<span style="color: #666666">*</span>vrx), C<span style="color: #666666">*</span>vr<span style="color: #666666">*</span>(<span style="color: #666666">-</span>CD<span style="color: #666666">*</span>vry) <span style="color: #666666">-</span> g]
    <span style="color: #008000; font-weight: bold">return</span> zout 

<span style="color: #408080; font-style: italic"># golf ball with lift</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f3</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;4x4 system for golf ball with drag and lift in two directions.&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    C <span style="color: #666666">=</span> <span style="color: #666666">3.0*</span>rho_f<span style="color: #666666">/</span>(<span style="color: #666666">4.0*</span>rho_s<span style="color: #666666">*</span>d)
    vrx <span style="color: #666666">=</span> z[<span style="color: #666666">2</span>] <span style="color: #666666">-</span> vfx
    vry <span style="color: #666666">=</span> z[<span style="color: #666666">3</span>] <span style="color: #666666">-</span> vfy
    vr <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sqrt(vrx<span style="color: #666666">**2</span> <span style="color: #666666">+</span> vry<span style="color: #666666">**2</span>)
    Re <span style="color: #666666">=</span> vr<span style="color: #666666">*</span>d<span style="color: #666666">/</span>nu
    CD, CL <span style="color: #666666">=</span> cdcl(vr, nrpm)
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">2</span>], z[<span style="color: #666666">3</span>], <span style="color: #666666">-</span>C<span style="color: #666666">*</span>vr<span style="color: #666666">*</span>(CD<span style="color: #666666">*</span>vrx <span style="color: #666666">+</span> CL<span style="color: #666666">*</span>vry), C<span style="color: #666666">*</span>vr<span style="color: #666666">*</span>(CL<span style="color: #666666">*</span>vrx <span style="color: #666666">-</span> CD<span style="color: #666666">*</span>vry) <span style="color: #666666">-</span> g]
    <span style="color: #008000; font-weight: bold">return</span> zout 


<span style="color: #408080; font-style: italic"># main program starts here</span>

T <span style="color: #666666">=</span> <span style="color: #666666">7</span>   <span style="color: #408080; font-style: italic"># end of simulation</span>
N <span style="color: #666666">=</span> <span style="color: #666666">60</span>  <span style="color: #408080; font-style: italic"># no of time steps</span>
time <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)

N2 <span style="color: #666666">=</span> <span style="color: #666666">4</span>
alfa <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">30</span>, <span style="color: #666666">15</span>, N2)   <span style="color: #408080; font-style: italic"># Angle of elevation [degrees]</span>
angle <span style="color: #666666">=</span> alfa<span style="color: #666666">*</span>np<span style="color: #666666">.</span>pi<span style="color: #666666">/180.0</span> <span style="color: #408080; font-style: italic"># convert to radians</span>

legends<span style="color: #666666">=</span>[]
line_color<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;k&#39;</span>,<span style="color: #BA2121">&#39;m&#39;</span>,<span style="color: #BA2121">&#39;b&#39;</span>,<span style="color: #BA2121">&#39;r&#39;</span>]
figure(figsize<span style="color: #666666">=</span>(<span style="color: #666666">20</span>, <span style="color: #666666">8</span>))
hold(<span style="color: #BA2121">&#39;on&#39;</span>)
LNWDT<span style="color: #666666">=4</span>; FNT<span style="color: #666666">=18</span>
rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT

<span style="color: #408080; font-style: italic"># computing and plotting</span>

<span style="color: #408080; font-style: italic"># smooth ball with drag</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,N2):
    z0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #666666">4</span>)
    z0[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> v0<span style="color: #666666">*</span>np<span style="color: #666666">.</span>cos(angle[i])
    z0[<span style="color: #666666">3</span>] <span style="color: #666666">=</span> v0<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sin(angle[i])
    solver <span style="color: #666666">=</span> odespy<span style="color: #666666">.</span>RK4(f)
    solver<span style="color: #666666">.</span>set_initial_condition(z0)
    z, t <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>solve(time)
    plot(z[:,<span style="color: #666666">0</span>], z[:,<span style="color: #666666">1</span>], <span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span>line_color[i])
    legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;angle=&#39;</span><span style="color: #666666">+</span><span style="color: #008000">str</span>(alfa[i])<span style="color: #666666">+</span><span style="color: #BA2121">&#39;, smooth ball&#39;</span>)
    
<span style="color: #408080; font-style: italic"># golf ball with drag</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,N2):
    z0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #666666">4</span>)
    z0[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> v0<span style="color: #666666">*</span>np<span style="color: #666666">.</span>cos(angle[i])
    z0[<span style="color: #666666">3</span>] <span style="color: #666666">=</span> v0<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sin(angle[i])
    solver <span style="color: #666666">=</span> odespy<span style="color: #666666">.</span>RK4(f2)
    solver<span style="color: #666666">.</span>set_initial_condition(z0)
    z, t <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>solve(time)
    plot(z[:,<span style="color: #666666">0</span>], z[:,<span style="color: #666666">1</span>], <span style="color: #BA2121">&#39;-.&#39;</span>, color<span style="color: #666666">=</span>line_color[i])
    legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;angle=&#39;</span><span style="color: #666666">+</span><span style="color: #008000">str</span>(alfa[i])<span style="color: #666666">+</span><span style="color: #BA2121">&#39;, golf ball&#39;</span>)
     
<span style="color: #408080; font-style: italic"># golf ball with drag and lift</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>,N2):
    z0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #666666">4</span>)
    z0[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> v0<span style="color: #666666">*</span>np<span style="color: #666666">.</span>cos(angle[i])
    z0[<span style="color: #666666">3</span>] <span style="color: #666666">=</span> v0<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sin(angle[i])
    solver <span style="color: #666666">=</span> odespy<span style="color: #666666">.</span>RK4(f3)
    solver<span style="color: #666666">.</span>set_initial_condition(z0)
    z, t <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>solve(time)
    plot(z[:,<span style="color: #666666">0</span>], z[:,<span style="color: #666666">1</span>], <span style="color: #BA2121">&#39;.&#39;</span>, color<span style="color: #666666">=</span>line_color[i])
    legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;angle=&#39;</span><span style="color: #666666">+</span><span style="color: #008000">str</span>(alfa[i])<span style="color: #666666">+</span><span style="color: #BA2121">&#39;, golf ball (with lift)&#39;</span>)
 
legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
xlabel(<span style="color: #BA2121">&#39;x [m]&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;y [m]&#39;</span>)
axis([<span style="color: #666666">0</span>, <span style="color: #666666">250</span>, <span style="color: #666666">0</span>, <span style="color: #666666">50</span>])
savefig(<span style="color: #BA2121">&#39;example_particle_motion_2d_2.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
show()
</pre></div>
<p>
<!-- !split -->

<h2 id="___sec23">Example: Numerical error as  a function of \( \Delta t \) for ODE-schemes </h2>

<p>
To investigate whether the various ODE-schemes in our module 'ODEschemes.py' 
have the expected, theoretical order, we proceed in the same manner as
outlined in (<a href="#ex:num_error">Example: Numerical error as a function of \( \Delta t \)</a>). The complete code is listed at the end
of this section but we will highlight and explain some details in the
following.

<p>
To test the numerical order for the schemes we solve a somewhat general linear ODE:
$$
\begin{align}
\label{eq:gen_lin_ode}
 u'(t)&= a \, u + b \\ 
 u(t_0)&= u_0 \nonumber
\end{align}
$$

which has the analytical solutions:
$$
\begin{equation}
u =\begin{cases}
 \left (u_0 + \frac{b}{a} \right )   \; e^{a\, t} -\frac{b}{a},& \quad a \neq 0 \\ 
 u_0 + b\, t, &\quad a = 0 
\end{cases}
\label{_auto18}
\end{equation}
$$

<p>
The right hand side defining the differential equation has been
implemented in function <code>f3</code> and the corresponding
analytical solution is computed by <code>u_nonlin_analytical</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f3</span>(z, t, a<span style="color: #666666">=2.0</span>, b<span style="color: #666666">=-1.0</span>):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> a<span style="color: #666666">*</span>z <span style="color: #666666">+</span> b

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u_nonlin_analytical</span>(u0, t, a<span style="color: #666666">=2.0</span>, b<span style="color: #666666">=-1.0</span>):
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> exp
        TOL <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
        <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">abs</span>(a)<span style="color: #666666">&gt;</span>TOL):
            <span style="color: #008000; font-weight: bold">return</span> (u0 <span style="color: #666666">+</span> b<span style="color: #666666">/</span>a)<span style="color: #666666">*</span>exp(a<span style="color: #666666">*</span>t)<span style="color: #666666">-</span>b<span style="color: #666666">/</span>a
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">return</span> u0 <span style="color: #666666">+</span> b<span style="color: #666666">*</span>t
</pre></div>
<p>
<hr>
The basic idea for the convergence test in  the function <code>convergence_test</code> is that we start out by
solving numerically an ODE with an analytical solution on a relatively
coarse grid, allowing for direct computations of the error. We then
reduce the timestep by a factor two (or double the grid size),
repeatedly, and compute the error for each grid and compare it with
the error of previous grid.

<p>
The Euler scheme \eqref{eq:1302} is \( O(h) \), whereas the Heun scheme
\eqref{eq:1403a} is \( O(h^2) \), and Runge-Kutta \eqref{eq:1501} is
\( O(h^4) \), where the \( h \) denote a generic step size which for the
current example is the timestep \( \Delta t \). The order of a particular
scheme is given exponent \( n \) in the error term \( O(h^n) \). Consequently, the Euler scheme is a first oder scheme, Heun is second order, whereas Runge-Kutta is fourth order.

<p>
By letting \( \epsilon_{i+1} \) and \( \epsilon_i \) denote the errors on two consecutive grids with corresponding timesteps \( \displaystyle \Delta t_{i+1} = \frac{\Delta t_i}{2} \). The errors \( \epsilon_{i+1} \) and \( \epsilon_{i} \) for a scheme of order \( n \) are then related by:
$$
\begin{equation}
\label{eq:eps}
\epsilon_{i+1} = \frac{1}{2^n} \epsilon_{i}
\end{equation}
$$

Consequently, whenever  \( \epsilon_{i+1} \) and \( \epsilon_{i} \) are known from consecutive simulations an estimate of the order of the scheme may be obtained by:
$$
\begin{equation}
\label{eq:epsapprox}
 n \approx \log_2 \frac{\epsilon_{i}}{\epsilon_{i+1}}
\end{equation}
$$

The theoretical value of \( n \) is thus \( n=1 \) for Euler's method, \( n=2 \) for Heun's method and \( n=4 \) for RK4.

<p>
In the function <code>convergence_test</code> the schemes we will subject to a
convergence test is ordered in a list <code>scheme_list</code>. This allows for a convenient loop over all schemes with the clause: <code>for scheme in
scheme_list:</code>. Subsequently, for each scheme we refine the initial
grid (<code>N=30</code>) <code>Ndts</code> times in the loop <code>for i in range(Ndts+1):</code> and
solve and compute the order estimate given by \eqref{eq:epsapprox} with
the clause <code>order_approx.append(previous_max_log_err -
max_log_err)</code>. Note that we can not compute this for the first
iteration (<code>i=0</code>), and that we use a an initial empty list
<code>order_approx</code> to store the approximation of the order <code>n</code> for each
grid refinement. For each grid we plot
\( \log_2(\epsilon) \) as a function of time with: <code>plot(time[1:],
log_error, linestyles[i]+colors[iclr], markevery=N/5)</code> and for each
plot we construct the corresponding legend by appending a new element
to the legends-list <code>legends.append(scheme.func_name +': N = ' + str(N))</code>.   This construct produces a string with both the scheme name and the number of elements \( N \). The plot is not reproduced below, but you may see the result by downloading and running the module yourself.

<p>
Having completed the given number of refinements <code>Ndts</code> for a specific scheme
we store the <code>order_approx</code> for the scheme in a dictionary using the
name of the scheme as a key by <code>schemes_orders[scheme.func_name] =
order_approx</code>. This allows for an illustrative plot of the order estimate for each scheme with the clause:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> schemes_orders:
            plot(N_list, (np<span style="color: #666666">.</span>asarray(schemes_orders[key])))
</pre></div>
<p>
and the resulting plot is shown in Figure <a href="#fig:convergence_rate">13</a>, and we see that our numerical approximations for the orders of our schemes approach the theoretical values as the number of timesteps increase (or as the timestep is reduced by a factor two consecutively).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 13:  The convergence rate for the various ODE-solvers a function of the number of timesteps. <div id="fig:convergence_rate"></div> </p></center>
<p><img src="fig-ch1/ConvergenceODEschemes.png" align="bottom" width=500></p>
</center>

<p>
The complete function <code>convergence_test</code> is a part of the module <code>ODEschemes</code> and is isolated below:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">convergence_test</span>():
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Test convergence rate of the methods &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, size, <span style="color: #008000">abs</span>, log10, mean, log2
        figure()
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
        T <span style="color: #666666">=</span> <span style="color: #666666">8.0</span>   <span style="color: #408080; font-style: italic"># end of simulation</span>
        Ndts <span style="color: #666666">=</span> <span style="color: #666666">5</span> <span style="color: #408080; font-style: italic"># Number of times to refine timestep in convergence test</span>

        z0 <span style="color: #666666">=</span> <span style="color: #666666">2</span>

        schemes <span style="color: #666666">=</span>[euler, heun, rk4]
        legends<span style="color: #666666">=</span>[]
        schemes_order<span style="color: #666666">=</span>{}
        
        colors <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;r&#39;</span>, <span style="color: #BA2121">&#39;g&#39;</span>, <span style="color: #BA2121">&#39;b&#39;</span>, <span style="color: #BA2121">&#39;m&#39;</span>, <span style="color: #BA2121">&#39;k&#39;</span>, <span style="color: #BA2121">&#39;y&#39;</span>, <span style="color: #BA2121">&#39;c&#39;</span>]
        linestyles <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;-&#39;</span>, <span style="color: #BA2121">&#39;--&#39;</span>, <span style="color: #BA2121">&#39;-.&#39;</span>, <span style="color: #BA2121">&#39;:&#39;</span>, <span style="color: #BA2121">&#39;v--&#39;</span>, <span style="color: #BA2121">&#39;*-.&#39;</span>]
        iclr <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">for</span> scheme <span style="color: #AA22FF; font-weight: bold">in</span> schemes:
            N <span style="color: #666666">=</span> <span style="color: #666666">30</span>    <span style="color: #408080; font-style: italic"># no of time steps</span>
            time <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)

            order_approx <span style="color: #666666">=</span> []
            
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ndts<span style="color: #666666">+1</span>):
                z <span style="color: #666666">=</span> scheme(f3, z0, time)   
                abs_error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_nonlin_analytical(z0, time)<span style="color: #666666">-</span>z[:,<span style="color: #666666">0</span>])
                log_error <span style="color: #666666">=</span> log2(abs_error[<span style="color: #666666">1</span>:]) <span style="color: #408080; font-style: italic"># Drop 1st elt to avoid log2-problems (1st elt is zero)</span>
                max_log_err <span style="color: #666666">=</span> <span style="color: #008000">max</span>(log_error)
                plot(time[<span style="color: #666666">1</span>:], log_error, linestyles[i]<span style="color: #666666">+</span>colors[iclr], markevery<span style="color: #666666">=</span>N<span style="color: #666666">/5</span>)
                legends<span style="color: #666666">.</span>append(scheme<span style="color: #666666">.</span>func_name <span style="color: #666666">+</span><span style="color: #BA2121">&#39;: N = &#39;</span> <span style="color: #666666">+</span> <span style="color: #008000">str</span>(N))
                hold(<span style="color: #BA2121">&#39;on&#39;</span>)
                
                <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>: <span style="color: #408080; font-style: italic"># Compute the log2 error difference</span>
                    order_approx<span style="color: #666666">.</span>append(previous_max_log_err <span style="color: #666666">-</span> max_log_err) 
                previous_max_log_err <span style="color: #666666">=</span> max_log_err

                N <span style="color: #666666">*=2</span>
                time <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)
            
            schemes_order[scheme<span style="color: #666666">.</span>func_name] <span style="color: #666666">=</span> order_approx
            iclr <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>)
        xlabel(<span style="color: #BA2121">&#39;Time&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;log(error)&#39;</span>)
        grid()
        
        N <span style="color: #666666">=</span> N<span style="color: #666666">/2**</span>Ndts
        N_list <span style="color: #666666">=</span> [N<span style="color: #666666">*2**</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Ndts<span style="color: #666666">+1</span>)]
        N_list <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(N_list)
        
        figure()
        <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> schemes_order:
            plot(N_list, (np<span style="color: #666666">.</span>asarray(schemes_order[key])))
        
        <span style="color: #408080; font-style: italic"># Plot theoretical n for 1st, 2nd and 4th order schemes</span>
        axhline(<span style="color: #666666">1.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        axhline(<span style="color: #666666">2.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        axhline(<span style="color: #666666">4.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        xticks(N_list, rotation<span style="color: #666666">=-70</span>)
        legends <span style="color: #666666">=</span> schemes_order<span style="color: #666666">.</span>keys()
        legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;theoretical&#39;</span>) 
        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        xlabel(<span style="color: #BA2121">&#39;Number of unknowns&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;Scheme order approximation&#39;</span>)
        axis([<span style="color: #666666">0</span>, <span style="color: #008000">max</span>(N_list), <span style="color: #666666">0</span>, <span style="color: #666666">5</span>])
        savefig(<span style="color: #BA2121">&#39;ConvergenceODEschemes.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
        
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">manufactured_solution</span>():
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Test convergence rate of the methods, by using the Method of Manufactured solutions.</span>
<span style="color: #BA2121; font-style: italic">            The coefficient function f is chosen to be the normal distribution</span>
<span style="color: #BA2121; font-style: italic">            f = (1/(sigma*sqrt(2*pi)))*exp(-((t-mu)**2)/(2*sigma**2)).</span>
<span style="color: #BA2121; font-style: italic">            The ODE to be solved is than chosen to be: f&#39;&#39;&#39; + f&#39;&#39;*f + f&#39; = RHS,</span>
<span style="color: #BA2121; font-style: italic">            leading to to f&#39;&#39;&#39; = RHS - f&#39;&#39;*f - f</span>
<span style="color: #BA2121; font-style: italic">         &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, size, <span style="color: #008000">abs</span>, log10, mean, log2
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> exp, symbols, diff, lambdify
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sqrt, pi
    
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&quot;solving equation f&#39;&#39;&#39; + f&#39;&#39;*f + f&#39; = RHS&quot;</span>
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&quot;which lead to f&#39;&#39;&#39; = RHS - f&#39;&#39;*f - f&quot;</span>
        t <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;t&#39;</span>)
        sigma<span style="color: #666666">=0.5</span> <span style="color: #408080; font-style: italic"># standard deviation</span>
        mu<span style="color: #666666">=0.5</span> <span style="color: #408080; font-style: italic"># mean value</span>
        Domain<span style="color: #666666">=</span>[<span style="color: #666666">-1.5</span>, <span style="color: #666666">2.5</span>]
        t0 <span style="color: #666666">=</span> Domain[<span style="color: #666666">0</span>]
        tend <span style="color: #666666">=</span> Domain[<span style="color: #666666">1</span>]
        
        f <span style="color: #666666">=</span> (<span style="color: #666666">1/</span>(sigma<span style="color: #666666">*</span>sqrt(<span style="color: #666666">2*</span>pi)))<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>((t<span style="color: #666666">-</span>mu)<span style="color: #666666">**2</span>)<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>sigma<span style="color: #666666">**2</span>))
        dfdt <span style="color: #666666">=</span> diff(f, t)
        d2fdt <span style="color: #666666">=</span> diff(dfdt, t)
        d3fdt <span style="color: #666666">=</span> diff(d2fdt, t)
        RHS <span style="color: #666666">=</span> d3fdt <span style="color: #666666">+</span> dfdt<span style="color: #666666">*</span>d2fdt <span style="color: #666666">+</span> f
    
        f <span style="color: #666666">=</span> lambdify([t], f)
        dfdt <span style="color: #666666">=</span> lambdify([t], dfdt)
        d2fdt <span style="color: #666666">=</span> lambdify([t], d2fdt)
        RHS <span style="color: #666666">=</span> lambdify([t], RHS)

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">func</span>(y,t):
            yout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(y)
            yout[:] <span style="color: #666666">=</span> [y[<span style="color: #666666">1</span>], y[<span style="color: #666666">2</span>], RHS(t) <span style="color: #666666">-</span>y[<span style="color: #666666">0</span>]<span style="color: #666666">-</span> y[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>y[<span style="color: #666666">2</span>]]
            
            <span style="color: #008000; font-weight: bold">return</span> yout
            
        z0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([f(t0), dfdt(t0), d2fdt(t0)])
        
        figure()
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
        Ndts <span style="color: #666666">=</span> <span style="color: #666666">5</span> <span style="color: #408080; font-style: italic"># Number of times to refine timestep in convergence test</span>
        schemes <span style="color: #666666">=</span>[euler, heun, rk4]
        legends<span style="color: #666666">=</span>[]
        schemes_order<span style="color: #666666">=</span>{}
        
        colors <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;r&#39;</span>, <span style="color: #BA2121">&#39;g&#39;</span>, <span style="color: #BA2121">&#39;b&#39;</span>, <span style="color: #BA2121">&#39;m&#39;</span>, <span style="color: #BA2121">&#39;k&#39;</span>, <span style="color: #BA2121">&#39;y&#39;</span>, <span style="color: #BA2121">&#39;c&#39;</span>]
        linestyles <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;-&#39;</span>, <span style="color: #BA2121">&#39;--&#39;</span>, <span style="color: #BA2121">&#39;-.&#39;</span>, <span style="color: #BA2121">&#39;:&#39;</span>, <span style="color: #BA2121">&#39;v--&#39;</span>, <span style="color: #BA2121">&#39;*-.&#39;</span>]
        iclr <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">for</span> scheme <span style="color: #AA22FF; font-weight: bold">in</span> schemes:
            N <span style="color: #666666">=</span> <span style="color: #666666">100</span>    <span style="color: #408080; font-style: italic"># no of time steps</span>
            time <span style="color: #666666">=</span> linspace(t0, tend, N<span style="color: #666666">+1</span>)
            fanalytic <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(time)
            k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">for</span> tau <span style="color: #AA22FF; font-weight: bold">in</span> time:
                fanalytic[k] <span style="color: #666666">=</span> f(tau)
                k <span style="color: #666666">=</span> k <span style="color: #666666">+</span> <span style="color: #666666">1</span>

            order_approx <span style="color: #666666">=</span> []
            
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ndts<span style="color: #666666">+1</span>):
                z <span style="color: #666666">=</span> scheme(func, z0, time)   
                abs_error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(fanalytic<span style="color: #666666">-</span>z[:,<span style="color: #666666">0</span>])
                log_error <span style="color: #666666">=</span> log2(abs_error[<span style="color: #666666">1</span>:]) <span style="color: #408080; font-style: italic"># Drop 1st elt to avoid log2-problems (1st elt is zero)</span>
                max_log_err <span style="color: #666666">=</span> <span style="color: #008000">max</span>(log_error)
                plot(time[<span style="color: #666666">1</span>:], log_error, linestyles[i]<span style="color: #666666">+</span>colors[iclr], markevery<span style="color: #666666">=</span>N<span style="color: #666666">/5</span>)
                legends<span style="color: #666666">.</span>append(scheme<span style="color: #666666">.</span>func_name <span style="color: #666666">+</span><span style="color: #BA2121">&#39;: N = &#39;</span> <span style="color: #666666">+</span> <span style="color: #008000">str</span>(N))
                hold(<span style="color: #BA2121">&#39;on&#39;</span>)
                
                <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>: <span style="color: #408080; font-style: italic"># Compute the log2 error difference</span>
                    order_approx<span style="color: #666666">.</span>append(previous_max_log_err <span style="color: #666666">-</span> max_log_err) 
                previous_max_log_err <span style="color: #666666">=</span> max_log_err

                N <span style="color: #666666">*=2</span>
                time <span style="color: #666666">=</span> linspace(t0, tend, N<span style="color: #666666">+1</span>)
                fanalytic <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(time)
                k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
                <span style="color: #008000; font-weight: bold">for</span> tau <span style="color: #AA22FF; font-weight: bold">in</span> time:
                    fanalytic[k] <span style="color: #666666">=</span> f(tau)
                    k <span style="color: #666666">=</span> k <span style="color: #666666">+</span> <span style="color: #666666">1</span>
            
            schemes_order[scheme<span style="color: #666666">.</span>func_name] <span style="color: #666666">=</span> order_approx
            iclr <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>)
        xlabel(<span style="color: #BA2121">&#39;Time&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;log(error)&#39;</span>)
        grid()
        
        N <span style="color: #666666">=</span> N<span style="color: #666666">/2**</span>Ndts
        N_list <span style="color: #666666">=</span> [N<span style="color: #666666">*2**</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Ndts<span style="color: #666666">+1</span>)]
        N_list <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(N_list)
        
        figure()
        <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> schemes_order:
            plot(N_list, (np<span style="color: #666666">.</span>asarray(schemes_order[key])))
        
        <span style="color: #408080; font-style: italic"># Plot theoretical n for 1st, 2nd and 4th order schemes</span>
        axhline(<span style="color: #666666">1.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        axhline(<span style="color: #666666">2.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        axhline(<span style="color: #666666">4.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        xticks(N_list, rotation<span style="color: #666666">=-70</span>)
        legends <span style="color: #666666">=</span> schemes_order<span style="color: #666666">.</span>keys()
        legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;theoretical&#39;</span>) 
        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        title(<span style="color: #BA2121">&#39;Method of Manufactured Solution&#39;</span>)
        xlabel(<span style="color: #BA2121">&#39;Number of unknowns&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;Scheme order approximation&#39;</span>)
        axis([<span style="color: #666666">0</span>, <span style="color: #008000">max</span>(N_list), <span style="color: #666666">0</span>, <span style="color: #666666">5</span>])
        savefig(<span style="color: #BA2121">&#39;MMSODEschemes.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #408080; font-style: italic"># test using MMS and solving a set of two nonlinear equations to find estimate of order</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">manufactured_solution_Nonlinear</span>():
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Test convergence rate of the methods, by using the Method of Manufactured solutions.</span>
<span style="color: #BA2121; font-style: italic">            The coefficient function f is chosen to be the normal distribution</span>
<span style="color: #BA2121; font-style: italic">            f = (1/(sigma*sqrt(2*pi)))*exp(-((t-mu)**2)/(2*sigma**2)).</span>
<span style="color: #BA2121; font-style: italic">            The ODE to be solved is than chosen to be: f&#39;&#39;&#39; + f&#39;&#39;*f + f&#39; = RHS,</span>
<span style="color: #BA2121; font-style: italic">            leading to f&#39;&#39;&#39; = RHS - f&#39;&#39;*f - f</span>
<span style="color: #BA2121; font-style: italic">         &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, <span style="color: #008000">abs</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> exp, symbols, diff, lambdify
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sqrt, pi
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log, log2
    
        t <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;t&#39;</span>)
        sigma<span style="color: #666666">=</span>  <span style="color: #666666">0.5</span> <span style="color: #408080; font-style: italic"># standard deviation</span>
        mu <span style="color: #666666">=</span> <span style="color: #666666">0.5</span> <span style="color: #408080; font-style: italic"># mean value</span>
        <span style="color: #408080; font-style: italic">#### Perform needed differentiations based on the differential equation ####</span>
        f <span style="color: #666666">=</span> (<span style="color: #666666">1/</span>(sigma<span style="color: #666666">*</span>sqrt(<span style="color: #666666">2*</span>pi)))<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>((t<span style="color: #666666">-</span>mu)<span style="color: #666666">**2</span>)<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>sigma<span style="color: #666666">**2</span>))
        dfdt <span style="color: #666666">=</span> diff(f, t)
        d2fdt <span style="color: #666666">=</span> diff(dfdt, t)
        d3fdt <span style="color: #666666">=</span> diff(d2fdt, t)
        RHS <span style="color: #666666">=</span> d3fdt <span style="color: #666666">+</span> dfdt<span style="color: #666666">*</span>d2fdt <span style="color: #666666">+</span> f
        <span style="color: #408080; font-style: italic">#### Create Python functions of f, RHS and needed differentiations of f ####</span>
        f <span style="color: #666666">=</span> lambdify([t], f, np)
        dfdt <span style="color: #666666">=</span> lambdify([t], dfdt, np)
        d2fdt <span style="color: #666666">=</span> lambdify([t], d2fdt)
        RHS <span style="color: #666666">=</span> lambdify([t], RHS)

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">func</span>(y,t):
            <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Function that returns the dfn/dt of the differential equation f + f&#39;&#39;*f + f&#39;&#39;&#39; = RHS</span>
<span style="color: #BA2121; font-style: italic">                as a system of 1st order equations; f = f1 </span>
<span style="color: #BA2121; font-style: italic">                        f1&#39; = f2 </span>
<span style="color: #BA2121; font-style: italic">                        f2&#39; = f3</span>
<span style="color: #BA2121; font-style: italic">                        f3&#39; = RHS - f1 - f2*f3</span>
<span style="color: #BA2121; font-style: italic">            </span>
<span style="color: #BA2121; font-style: italic">                Args:</span>
<span style="color: #BA2121; font-style: italic">                    y(array): solutian array [f1, f2, f3] at time t</span>
<span style="color: #BA2121; font-style: italic">                    t(float): current time</span>
<span style="color: #BA2121; font-style: italic">        </span>
<span style="color: #BA2121; font-style: italic">                Returns:</span>
<span style="color: #BA2121; font-style: italic">                    yout(array): differantiation array [f1&#39;, f2&#39;, f3&#39;] at time t</span>
<span style="color: #BA2121; font-style: italic">            &quot;&quot;&quot;</span>
            yout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(y)
            yout[:] <span style="color: #666666">=</span> [y[<span style="color: #666666">1</span>], y[<span style="color: #666666">2</span>], RHS(t) <span style="color: #666666">-</span>y[<span style="color: #666666">0</span>]<span style="color: #666666">-</span> y[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>y[<span style="color: #666666">2</span>]]
            
            <span style="color: #008000; font-weight: bold">return</span> yout
        
        t0, tend <span style="color: #666666">=</span> <span style="color: #666666">-1.5</span>, <span style="color: #666666">2.5</span>
        z0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([f(t0), dfdt(t0), d2fdt(t0)]) <span style="color: #408080; font-style: italic"># initial values</span>
        
        schemes <span style="color: #666666">=</span> [euler, heun, rk4] <span style="color: #408080; font-style: italic"># list of schemes; each of which is a function</span>
        schemes_error <span style="color: #666666">=</span> {} <span style="color: #408080; font-style: italic"># empty dictionary. to be filled in with lists of error-norms for all schemes</span>
        h <span style="color: #666666">=</span> [] <span style="color: #408080; font-style: italic"># empty list of time step</span>
        
        Ntds <span style="color: #666666">=</span> <span style="color: #666666">4</span> <span style="color: #408080; font-style: italic"># number of times to refine dt</span>
        
        fig, ax <span style="color: #666666">=</span> subplots(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(schemes), sharey <span style="color: #666666">=</span> <span style="color: #008000">True</span>, squeeze<span style="color: #666666">=</span><span style="color: #008000">False</span>)
         
        <span style="color: #008000; font-weight: bold">for</span> k, scheme <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(schemes):
            N <span style="color: #666666">=</span> <span style="color: #666666">20</span>    <span style="color: #408080; font-style: italic"># initial number of time steps</span>
            error <span style="color: #666666">=</span> [] <span style="color: #408080; font-style: italic"># start of with empty list of errors for all schemes</span>
            legendList <span style="color: #666666">=</span> [] 
            
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ntds <span style="color: #666666">+</span> <span style="color: #666666">1</span>):
                time <span style="color: #666666">=</span> linspace(t0, tend, N<span style="color: #666666">+1</span>)
                
                <span style="color: #008000; font-weight: bold">if</span> k<span style="color: #666666">==0</span>:
                    h<span style="color: #666666">.</span>append(time[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> time[<span style="color: #666666">0</span>]) <span style="color: #408080; font-style: italic"># add this iteration&#39;s dt to list h</span>
                z <span style="color: #666666">=</span> scheme(func, z0, time) <span style="color: #408080; font-style: italic"># Solve the ODE by calling the scheme with arguments. e.g: euler(func, z0, time) </span>
                fanalytic <span style="color: #666666">=</span> f(time) <span style="color: #408080; font-style: italic"># call analytic function f to compute analytical solutions at times: time</span>
                
                abs_error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(z[:,<span style="color: #666666">0</span>]<span style="color: #666666">-</span> fanalytic) <span style="color: #408080; font-style: italic"># calculate infinity norm of the error</span>
                error<span style="color: #666666">.</span>append(<span style="color: #008000">max</span>(abs_error))
                
                ax[<span style="color: #666666">0</span>][k]<span style="color: #666666">.</span>plot(time, z[:,<span style="color: #666666">0</span>])
                legendList<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;$h$ = &#39;</span> <span style="color: #666666">+</span> <span style="color: #008000">str</span>(h[i]))
                
                N <span style="color: #666666">*=2</span> <span style="color: #408080; font-style: italic"># refine dt</span>
            
            schemes_error[scheme<span style="color: #666666">.</span>func_name] <span style="color: #666666">=</span> error <span style="color: #408080; font-style: italic"># Add a key:value pair to the dictionary. e.g: &quot;euler&quot;:[error1, error2, ..., errorNtds]</span>

            
            ax[<span style="color: #666666">0</span>][k]<span style="color: #666666">.</span>plot(time, fanalytic, <span style="color: #BA2121">&#39;k:&#39;</span>)
            legendList<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;$u_m$&#39;</span>)
            ax[<span style="color: #666666">0</span>][k]<span style="color: #666666">.</span>set_title(scheme<span style="color: #666666">.</span>func_name)
            ax[<span style="color: #666666">0</span>][k]<span style="color: #666666">.</span>set_xlabel(<span style="color: #BA2121">&#39;time&#39;</span>) 
        
        ax[<span style="color: #666666">0</span>][<span style="color: #666666">2</span>]<span style="color: #666666">.</span>legend(legendList, loc <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        ax[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>set_ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
        setp(ax, xticks<span style="color: #666666">=</span>[<span style="color: #666666">-1.5</span>, <span style="color: #666666">0.5</span>,  <span style="color: #666666">2.5</span>], yticks<span style="color: #666666">=</span>[<span style="color: #666666">0.0</span>, <span style="color: #666666">0.4</span> , <span style="color: #666666">0.8</span>, <span style="color: #666666">1.2</span>])
            
        <span style="color: #408080; font-style: italic">#savefig(&#39;../figs/normal_distribution_refinement.png&#39;)</span>
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Newton_solver_sympy</span>(error, h, x0):
            <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Function that solves for the nonlinear set of equations</span>
<span style="color: #BA2121; font-style: italic">                error1 = C*h1^p --&gt; f1 = C*h1^p - error1 = 0</span>
<span style="color: #BA2121; font-style: italic">                error2 = C*h2^p --&gt; f2 = C h2^p - error 2 = 0</span>
<span style="color: #BA2121; font-style: italic">                where C is a constant h is the step length and p is the order,</span>
<span style="color: #BA2121; font-style: italic">                with use of a newton rhapson solver. In this case C and p are</span>
<span style="color: #BA2121; font-style: italic">                the unknowns, whereas h and error are knowns. The newton rhapson </span>
<span style="color: #BA2121; font-style: italic">                method is an iterative solver which take the form:</span>
<span style="color: #BA2121; font-style: italic">                xnew = xold - (J^-1)*F, where J is the Jacobi matrix and F is the </span>
<span style="color: #BA2121; font-style: italic">                residual funcion.</span>
<span style="color: #BA2121; font-style: italic">                    x = [C, p]^T</span>
<span style="color: #BA2121; font-style: italic">                    J = [[df1/dx1  df2/dx2],</span>
<span style="color: #BA2121; font-style: italic">                         [df2/dx1  df2/dx2]]</span>
<span style="color: #BA2121; font-style: italic">                    F = [f1, f2]</span>
<span style="color: #BA2121; font-style: italic">                This is very neatly done with use of the sympy module</span>
<span style="color: #BA2121; font-style: italic">                </span>
<span style="color: #BA2121; font-style: italic">                Args:</span>
<span style="color: #BA2121; font-style: italic">                    error(list): list of calculated errors [error(h1), error(h2)]</span>
<span style="color: #BA2121; font-style: italic">                    h(list): list of steplengths corresponding to the list of errors</span>
<span style="color: #BA2121; font-style: italic">                    x0(list): list of starting (guessed) values for x</span>
<span style="color: #BA2121; font-style: italic">                </span>
<span style="color: #BA2121; font-style: italic">                Returns:</span>
<span style="color: #BA2121; font-style: italic">                    x(array): iterated solution of x = [C, p]</span>
<span style="color: #BA2121; font-style: italic">        </span>
<span style="color: #BA2121; font-style: italic">            &quot;&quot;&quot;</span>
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> Matrix
            <span style="color: #408080; font-style: italic">#### Symbolic computiations: ####</span>
            C, p <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;C p&#39;</span>)
            f1 <span style="color: #666666">=</span> C<span style="color: #666666">*</span>h[<span style="color: #666666">-2</span>]<span style="color: #666666">**</span>p <span style="color: #666666">-</span> error[<span style="color: #666666">-2</span>]
            f2 <span style="color: #666666">=</span> C<span style="color: #666666">*</span>h[<span style="color: #666666">-1</span>]<span style="color: #666666">**</span>p <span style="color: #666666">-</span> error[<span style="color: #666666">-1</span>]
            F <span style="color: #666666">=</span> [f1, f2]
            x <span style="color: #666666">=</span> [C, p]
            
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">jacobiElement</span>(i,j):
                <span style="color: #008000; font-weight: bold">return</span> diff(F[i], x[j])
                
            Jacobi <span style="color: #666666">=</span> Matrix(<span style="color: #666666">2</span>, <span style="color: #666666">2</span>, jacobiElement) <span style="color: #408080; font-style: italic"># neat way of computing the Jacobi Matrix</span>
            JacobiInv <span style="color: #666666">=</span> Jacobi<span style="color: #666666">.</span>inv()
            <span style="color: #408080; font-style: italic">#### Numerical computations: ####</span>
            JacobiInvfunc <span style="color: #666666">=</span> lambdify([x], JacobiInv)
            Ffunc <span style="color: #666666">=</span> lambdify([x], F)
            x <span style="color: #666666">=</span> x0
            
            <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">8</span>): <span style="color: #408080; font-style: italic">#perform 8 iterations</span>
                F <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(Ffunc(x))
                Jinv <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(JacobiInvfunc(x))
                xnew <span style="color: #666666">=</span> x <span style="color: #666666">-</span> np<span style="color: #666666">.</span>dot(Jinv, F)
                x <span style="color: #666666">=</span> xnew
                <span style="color: #408080; font-style: italic">#print &quot;n, x: &quot;, n, x</span>
            x[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">round</span>(x[<span style="color: #666666">0</span>], <span style="color: #666666">2</span>)
            x[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> <span style="color: #008000">round</span>(x[<span style="color: #666666">1</span>], <span style="color: #666666">3</span>)
            <span style="color: #008000; font-weight: bold">return</span> x
        
        ht <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(h) 
        eulerError <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(schemes_error[<span style="color: #BA2121">&quot;euler&quot;</span>])
        heunError <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(schemes_error[<span style="color: #BA2121">&quot;heun&quot;</span>])
        rk4Error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(schemes_error[<span style="color: #BA2121">&quot;rk4&quot;</span>])
        
        
        [C_euler, p_euler] <span style="color: #666666">=</span> Newton_solver_sympy(eulerError, ht, [<span style="color: #666666">1</span>,<span style="color: #666666">1</span>])
        [C_heun, p_heun] <span style="color: #666666">=</span> Newton_solver_sympy(heunError, ht, [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>])
        [C_rk4, p_rk4] <span style="color: #666666">=</span> Newton_solver_sympy(rk4Error, ht, [<span style="color: #666666">1</span>,<span style="color: #666666">4</span>])
        
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> latex
        h <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;h&#39;</span>)
        epsilon_euler <span style="color: #666666">=</span> C_euler<span style="color: #666666">*</span>h<span style="color: #666666">**</span>p_euler
        epsilon_euler_latex <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;$&#39;</span> <span style="color: #666666">+</span> latex(epsilon_euler) <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;$&#39;</span>
        epsilon_heun <span style="color: #666666">=</span> C_heun<span style="color: #666666">*</span>h<span style="color: #666666">**</span>p_heun
        epsilon_heun_latex <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;$&#39;</span> <span style="color: #666666">+</span> latex(epsilon_heun) <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;$&#39;</span>
        epsilon_rk4 <span style="color: #666666">=</span> C_rk4<span style="color: #666666">*</span>h<span style="color: #666666">**</span>p_rk4
        epsilon_rk4_latex <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;$&#39;</span> <span style="color: #666666">+</span> latex(epsilon_rk4) <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;$&#39;</span>
        
        <span style="color: #008000; font-weight: bold">print</span> epsilon_euler_latex
        <span style="color: #008000; font-weight: bold">print</span> epsilon_heun_latex
        <span style="color: #008000; font-weight: bold">print</span> epsilon_rk4_latex
        
        epsilon_euler <span style="color: #666666">=</span> lambdify(h, epsilon_euler, np)
        epsilon_heun <span style="color: #666666">=</span> lambdify(h, epsilon_heun, np)
        epsilon_rk4 <span style="color: #666666">=</span> lambdify(h, epsilon_rk4, np)
        
        N <span style="color: #666666">=</span> N<span style="color: #666666">/2**</span>(Ntds <span style="color: #666666">+</span> <span style="color: #666666">2</span>)
        N_list <span style="color: #666666">=</span> [N<span style="color: #666666">*2**</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Ntds <span style="color: #666666">+</span> <span style="color: #666666">2</span>)]
        N_list <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(N_list)
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #008000">len</span>(N_list)
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #008000">len</span>(eulerError)
        figure()
        plot(N_list, log2(eulerError), <span style="color: #BA2121">&#39;b&#39;</span>)
        plot(N_list, log2(epsilon_euler(ht)), <span style="color: #BA2121">&#39;b--&#39;</span>)
        plot(N_list, log2(heunError), <span style="color: #BA2121">&#39;g&#39;</span>)
        plot(N_list, log2(epsilon_heun(ht)), <span style="color: #BA2121">&#39;g--&#39;</span>)
        plot(N_list, log2(rk4Error), <span style="color: #BA2121">&#39;r&#39;</span>)
        plot(N_list, log2(epsilon_rk4(ht)), <span style="color: #BA2121">&#39;r--&#39;</span>)
        LegendList <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;${\epsilon}_{euler}$&#39;</span>, epsilon_euler_latex, <span style="color: #BA2121">&#39;${\epsilon}_{heun}$&#39;</span>, epsilon_heun_latex, <span style="color: #BA2121">&#39;${\epsilon}_{rk4}$&#39;</span>, epsilon_rk4_latex]
        legend(LegendList, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        xlabel(<span style="color: #BA2121">&#39;-log(h)&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;-log($\epsilon$)&#39;</span>)
        
        <span style="color: #408080; font-style: italic">#savefig(&#39;../figs/MMS_example2.png&#39;)</span>
</pre></div>
<p>
The complete module <code>ODEschemes</code> is listed below and may easily be downloaded in your Eclipse/LiClipse IDE:
<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter1/src-ch1/ODEschemes.py</span>

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> plot, show, legend, hold,rcParams,rc, figure, axhline, close,\
    xticks, title, xlabel, ylabel, savefig, axis, grid, subplots, setp

<span style="color: #408080; font-style: italic"># change some default values to make plots more readable </span>
LNWDT<span style="color: #666666">=3</span>; FNT<span style="color: #666666">=10</span>
rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">10</span>}; rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)


<span style="color: #408080; font-style: italic"># define Euler solver</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">euler</span>(func, z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Euler scheme for solution of systems of ODEs.</span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions,</span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns</span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>

    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time), np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0

    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(time)<span style="color: #666666">-1</span>):
        dt <span style="color: #666666">=</span> time[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> time[i]
        z[i<span style="color: #666666">+1</span>,:]<span style="color: #666666">=</span>z[i,:] <span style="color: #666666">+</span> np<span style="color: #666666">.</span>asarray(func(z[i,:], time[i]))<span style="color: #666666">*</span>dt

    <span style="color: #008000; font-weight: bold">return</span> z


<span style="color: #408080; font-style: italic"># define Heun solver</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">heun</span>(func, z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Heun scheme for solution of systems of ODEs.</span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions,</span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns</span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f_np</span>(z,t):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;A local function to ensure that the return of func is an np array</span>
<span style="color: #BA2121; font-style: italic">        and to avoid lengthy code for implementation of the Heun algorithm&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>asarray(func(z,t))

    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time), np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0
    zp <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z0)

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]):
        dt <span style="color: #666666">=</span> time[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> time[i]
        zp <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> f_np(z[i,:],t)<span style="color: #666666">*</span>dt   <span style="color: #408080; font-style: italic"># Predictor step</span>
        z[i<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> (f_np(z[i,:],t) <span style="color: #666666">+</span> f_np(zp,t<span style="color: #666666">+</span>dt))<span style="color: #666666">*</span>dt<span style="color: #666666">/2.0</span> <span style="color: #408080; font-style: italic"># Corrector step</span>

    <span style="color: #008000; font-weight: bold">return</span> z


<span style="color: #408080; font-style: italic"># define rk4 scheme</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">rk4</span>(func, z0, time):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;The Runge-Kutta 4 scheme for solution of systems of ODEs.</span>
<span style="color: #BA2121; font-style: italic">    z0 is a vector for the initial conditions,</span>
<span style="color: #BA2121; font-style: italic">    the right hand side of the system is represented by func which returns</span>
<span style="color: #BA2121; font-style: italic">    a vector with the same size as z0 .&quot;&quot;&quot;</span>

    z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((np<span style="color: #666666">.</span>size(time),np<span style="color: #666666">.</span>size(z0)))
    z[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> z0
    zp <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z0)

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]):
        dt <span style="color: #666666">=</span> time[i<span style="color: #666666">+1</span>] <span style="color: #666666">-</span> time[i]
        dt2 <span style="color: #666666">=</span> dt<span style="color: #666666">/2.0</span>
        k1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(func(z[i,:], t))                <span style="color: #408080; font-style: italic"># predictor step 1</span>
        k2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(func(z[i,:] <span style="color: #666666">+</span> k1<span style="color: #666666">*</span>dt2, t <span style="color: #666666">+</span> dt2)) <span style="color: #408080; font-style: italic"># predictor step 2</span>
        k3 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(func(z[i,:] <span style="color: #666666">+</span> k2<span style="color: #666666">*</span>dt2, t <span style="color: #666666">+</span> dt2)) <span style="color: #408080; font-style: italic"># predictor step 3</span>
        k4 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(func(z[i,:] <span style="color: #666666">+</span> k3<span style="color: #666666">*</span>dt, t <span style="color: #666666">+</span> dt))   <span style="color: #408080; font-style: italic"># predictor step 4</span>
        z[i<span style="color: #666666">+1</span>,:] <span style="color: #666666">=</span> z[i,:] <span style="color: #666666">+</span> dt<span style="color: #666666">/6.0*</span>(k1 <span style="color: #666666">+</span> <span style="color: #666666">2.0*</span>k2 <span style="color: #666666">+</span> <span style="color: #666666">2.0*</span>k3 <span style="color: #666666">+</span> k4) <span style="color: #408080; font-style: italic"># Corrector step</span>

    <span style="color: #008000; font-weight: bold">return</span> z


<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    a <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
    b <span style="color: #666666">=</span> <span style="color: #666666">3.0</span>
    u_exact <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: a<span style="color: #666666">*</span>t   <span style="color: #666666">+</span>  b

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f_local</span>(u,t):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;A function which returns an np.array but less easy to read</span>
<span style="color: #BA2121; font-style: italic">        than f(z,t) below. &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>asarray([a <span style="color: #666666">+</span> (u <span style="color: #666666">-</span> u_exact(t))<span style="color: #666666">**5</span>])

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Simple to read function implementation &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> [a <span style="color: #666666">+</span> (z <span style="color: #666666">-</span> u_exact(t))<span style="color: #666666">**5</span>]


    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_ODEschemes</span>():
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Use knowledge of an exact numerical solution for testing.&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, size

        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
        T <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>  <span style="color: #408080; font-style: italic"># end of simulation</span>
        N <span style="color: #666666">=</span> <span style="color: #666666">20</span>  <span style="color: #408080; font-style: italic"># no of time steps</span>
        time <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)


        z0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #666666">1</span>)
        z0[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u_exact(<span style="color: #666666">0.0</span>)

        schemes  <span style="color: #666666">=</span> [euler, heun, rk4]

        <span style="color: #008000; font-weight: bold">for</span> scheme <span style="color: #AA22FF; font-weight: bold">in</span> schemes:
            z <span style="color: #666666">=</span> scheme(f, z0, time)
            max_error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>max(u_exact(time) <span style="color: #666666">-</span> z[:,<span style="color: #666666">0</span>])
            msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> failed with error = </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (scheme<span style="color: #666666">.</span>func_name, max_error)
            <span style="color: #008000; font-weight: bold">assert</span> max_error <span style="color: #666666">&lt;</span> tol, msg

    <span style="color: #408080; font-style: italic"># f3 defines an ODE with ananlytical solution in u_nonlin_analytical</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f3</span>(z, t, a<span style="color: #666666">=2.0</span>, b<span style="color: #666666">=-1.0</span>):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> a<span style="color: #666666">*</span>z <span style="color: #666666">+</span> b

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u_nonlin_analytical</span>(u0, t, a<span style="color: #666666">=2.0</span>, b<span style="color: #666666">=-1.0</span>):
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> exp
        TOL <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
        <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">abs</span>(a)<span style="color: #666666">&gt;</span>TOL):
            <span style="color: #008000; font-weight: bold">return</span> (u0 <span style="color: #666666">+</span> b<span style="color: #666666">/</span>a)<span style="color: #666666">*</span>exp(a<span style="color: #666666">*</span>t)<span style="color: #666666">-</span>b<span style="color: #666666">/</span>a
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">return</span> u0 <span style="color: #666666">+</span> b<span style="color: #666666">*</span>t
            
         
    <span style="color: #408080; font-style: italic"># Function for convergence test</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">convergence_test</span>():
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Test convergence rate of the methods &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, size, <span style="color: #008000">abs</span>, log10, mean, log2
        figure()
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
        T <span style="color: #666666">=</span> <span style="color: #666666">8.0</span>   <span style="color: #408080; font-style: italic"># end of simulation</span>
        Ndts <span style="color: #666666">=</span> <span style="color: #666666">5</span> <span style="color: #408080; font-style: italic"># Number of times to refine timestep in convergence test</span>

        z0 <span style="color: #666666">=</span> <span style="color: #666666">2</span>

        schemes <span style="color: #666666">=</span>[euler, heun, rk4]
        legends<span style="color: #666666">=</span>[]
        schemes_order<span style="color: #666666">=</span>{}
        
        colors <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;r&#39;</span>, <span style="color: #BA2121">&#39;g&#39;</span>, <span style="color: #BA2121">&#39;b&#39;</span>, <span style="color: #BA2121">&#39;m&#39;</span>, <span style="color: #BA2121">&#39;k&#39;</span>, <span style="color: #BA2121">&#39;y&#39;</span>, <span style="color: #BA2121">&#39;c&#39;</span>]
        linestyles <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;-&#39;</span>, <span style="color: #BA2121">&#39;--&#39;</span>, <span style="color: #BA2121">&#39;-.&#39;</span>, <span style="color: #BA2121">&#39;:&#39;</span>, <span style="color: #BA2121">&#39;v--&#39;</span>, <span style="color: #BA2121">&#39;*-.&#39;</span>]
        iclr <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">for</span> scheme <span style="color: #AA22FF; font-weight: bold">in</span> schemes:
            N <span style="color: #666666">=</span> <span style="color: #666666">30</span>    <span style="color: #408080; font-style: italic"># no of time steps</span>
            time <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)

            order_approx <span style="color: #666666">=</span> []
            
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ndts<span style="color: #666666">+1</span>):
                z <span style="color: #666666">=</span> scheme(f3, z0, time)   
                abs_error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(u_nonlin_analytical(z0, time)<span style="color: #666666">-</span>z[:,<span style="color: #666666">0</span>])
                log_error <span style="color: #666666">=</span> log2(abs_error[<span style="color: #666666">1</span>:]) <span style="color: #408080; font-style: italic"># Drop 1st elt to avoid log2-problems (1st elt is zero)</span>
                max_log_err <span style="color: #666666">=</span> <span style="color: #008000">max</span>(log_error)
                plot(time[<span style="color: #666666">1</span>:], log_error, linestyles[i]<span style="color: #666666">+</span>colors[iclr], markevery<span style="color: #666666">=</span>N<span style="color: #666666">/5</span>)
                legends<span style="color: #666666">.</span>append(scheme<span style="color: #666666">.</span>func_name <span style="color: #666666">+</span><span style="color: #BA2121">&#39;: N = &#39;</span> <span style="color: #666666">+</span> <span style="color: #008000">str</span>(N))
                hold(<span style="color: #BA2121">&#39;on&#39;</span>)
                
                <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>: <span style="color: #408080; font-style: italic"># Compute the log2 error difference</span>
                    order_approx<span style="color: #666666">.</span>append(previous_max_log_err <span style="color: #666666">-</span> max_log_err) 
                previous_max_log_err <span style="color: #666666">=</span> max_log_err

                N <span style="color: #666666">*=2</span>
                time <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)
            
            schemes_order[scheme<span style="color: #666666">.</span>func_name] <span style="color: #666666">=</span> order_approx
            iclr <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>)
        xlabel(<span style="color: #BA2121">&#39;Time&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;log(error)&#39;</span>)
        grid()
        
        N <span style="color: #666666">=</span> N<span style="color: #666666">/2**</span>Ndts
        N_list <span style="color: #666666">=</span> [N<span style="color: #666666">*2**</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Ndts<span style="color: #666666">+1</span>)]
        N_list <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(N_list)
        
        figure()
        <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> schemes_order:
            plot(N_list, (np<span style="color: #666666">.</span>asarray(schemes_order[key])))
        
        <span style="color: #408080; font-style: italic"># Plot theoretical n for 1st, 2nd and 4th order schemes</span>
        axhline(<span style="color: #666666">1.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        axhline(<span style="color: #666666">2.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        axhline(<span style="color: #666666">4.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        xticks(N_list, rotation<span style="color: #666666">=-70</span>)
        legends <span style="color: #666666">=</span> schemes_order<span style="color: #666666">.</span>keys()
        legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;theoretical&#39;</span>) 
        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        xlabel(<span style="color: #BA2121">&#39;Number of unknowns&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;Scheme order approximation&#39;</span>)
        axis([<span style="color: #666666">0</span>, <span style="color: #008000">max</span>(N_list), <span style="color: #666666">0</span>, <span style="color: #666666">5</span>])
        savefig(<span style="color: #BA2121">&#39;ConvergenceODEschemes.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
        
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">manufactured_solution</span>():
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Test convergence rate of the methods, by using the Method of Manufactured solutions.</span>
<span style="color: #BA2121; font-style: italic">            The coefficient function f is chosen to be the normal distribution</span>
<span style="color: #BA2121; font-style: italic">            f = (1/(sigma*sqrt(2*pi)))*exp(-((t-mu)**2)/(2*sigma**2)).</span>
<span style="color: #BA2121; font-style: italic">            The ODE to be solved is than chosen to be: f&#39;&#39;&#39; + f&#39;&#39;*f + f&#39; = RHS,</span>
<span style="color: #BA2121; font-style: italic">            leading to to f&#39;&#39;&#39; = RHS - f&#39;&#39;*f - f</span>
<span style="color: #BA2121; font-style: italic">         &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, size, <span style="color: #008000">abs</span>, log10, mean, log2
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> exp, symbols, diff, lambdify
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sqrt, pi
    
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&quot;solving equation f&#39;&#39;&#39; + f&#39;&#39;*f + f&#39; = RHS&quot;</span>
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&quot;which lead to f&#39;&#39;&#39; = RHS - f&#39;&#39;*f - f&quot;</span>
        t <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;t&#39;</span>)
        sigma<span style="color: #666666">=0.5</span> <span style="color: #408080; font-style: italic"># standard deviation</span>
        mu<span style="color: #666666">=0.5</span> <span style="color: #408080; font-style: italic"># mean value</span>
        Domain<span style="color: #666666">=</span>[<span style="color: #666666">-1.5</span>, <span style="color: #666666">2.5</span>]
        t0 <span style="color: #666666">=</span> Domain[<span style="color: #666666">0</span>]
        tend <span style="color: #666666">=</span> Domain[<span style="color: #666666">1</span>]
        
        f <span style="color: #666666">=</span> (<span style="color: #666666">1/</span>(sigma<span style="color: #666666">*</span>sqrt(<span style="color: #666666">2*</span>pi)))<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>((t<span style="color: #666666">-</span>mu)<span style="color: #666666">**2</span>)<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>sigma<span style="color: #666666">**2</span>))
        dfdt <span style="color: #666666">=</span> diff(f, t)
        d2fdt <span style="color: #666666">=</span> diff(dfdt, t)
        d3fdt <span style="color: #666666">=</span> diff(d2fdt, t)
        RHS <span style="color: #666666">=</span> d3fdt <span style="color: #666666">+</span> dfdt<span style="color: #666666">*</span>d2fdt <span style="color: #666666">+</span> f
    
        f <span style="color: #666666">=</span> lambdify([t], f)
        dfdt <span style="color: #666666">=</span> lambdify([t], dfdt)
        d2fdt <span style="color: #666666">=</span> lambdify([t], d2fdt)
        RHS <span style="color: #666666">=</span> lambdify([t], RHS)

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">func</span>(y,t):
            yout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(y)
            yout[:] <span style="color: #666666">=</span> [y[<span style="color: #666666">1</span>], y[<span style="color: #666666">2</span>], RHS(t) <span style="color: #666666">-</span>y[<span style="color: #666666">0</span>]<span style="color: #666666">-</span> y[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>y[<span style="color: #666666">2</span>]]
            
            <span style="color: #008000; font-weight: bold">return</span> yout
            
        z0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([f(t0), dfdt(t0), d2fdt(t0)])
        
        figure()
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
        Ndts <span style="color: #666666">=</span> <span style="color: #666666">5</span> <span style="color: #408080; font-style: italic"># Number of times to refine timestep in convergence test</span>
        schemes <span style="color: #666666">=</span>[euler, heun, rk4]
        legends<span style="color: #666666">=</span>[]
        schemes_order<span style="color: #666666">=</span>{}
        
        colors <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;r&#39;</span>, <span style="color: #BA2121">&#39;g&#39;</span>, <span style="color: #BA2121">&#39;b&#39;</span>, <span style="color: #BA2121">&#39;m&#39;</span>, <span style="color: #BA2121">&#39;k&#39;</span>, <span style="color: #BA2121">&#39;y&#39;</span>, <span style="color: #BA2121">&#39;c&#39;</span>]
        linestyles <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;-&#39;</span>, <span style="color: #BA2121">&#39;--&#39;</span>, <span style="color: #BA2121">&#39;-.&#39;</span>, <span style="color: #BA2121">&#39;:&#39;</span>, <span style="color: #BA2121">&#39;v--&#39;</span>, <span style="color: #BA2121">&#39;*-.&#39;</span>]
        iclr <span style="color: #666666">=</span> <span style="color: #666666">0</span>
        <span style="color: #008000; font-weight: bold">for</span> scheme <span style="color: #AA22FF; font-weight: bold">in</span> schemes:
            N <span style="color: #666666">=</span> <span style="color: #666666">100</span>    <span style="color: #408080; font-style: italic"># no of time steps</span>
            time <span style="color: #666666">=</span> linspace(t0, tend, N<span style="color: #666666">+1</span>)
            fanalytic <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(time)
            k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">for</span> tau <span style="color: #AA22FF; font-weight: bold">in</span> time:
                fanalytic[k] <span style="color: #666666">=</span> f(tau)
                k <span style="color: #666666">=</span> k <span style="color: #666666">+</span> <span style="color: #666666">1</span>

            order_approx <span style="color: #666666">=</span> []
            
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ndts<span style="color: #666666">+1</span>):
                z <span style="color: #666666">=</span> scheme(func, z0, time)   
                abs_error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(fanalytic<span style="color: #666666">-</span>z[:,<span style="color: #666666">0</span>])
                log_error <span style="color: #666666">=</span> log2(abs_error[<span style="color: #666666">1</span>:]) <span style="color: #408080; font-style: italic"># Drop 1st elt to avoid log2-problems (1st elt is zero)</span>
                max_log_err <span style="color: #666666">=</span> <span style="color: #008000">max</span>(log_error)
                plot(time[<span style="color: #666666">1</span>:], log_error, linestyles[i]<span style="color: #666666">+</span>colors[iclr], markevery<span style="color: #666666">=</span>N<span style="color: #666666">/5</span>)
                legends<span style="color: #666666">.</span>append(scheme<span style="color: #666666">.</span>func_name <span style="color: #666666">+</span><span style="color: #BA2121">&#39;: N = &#39;</span> <span style="color: #666666">+</span> <span style="color: #008000">str</span>(N))
                hold(<span style="color: #BA2121">&#39;on&#39;</span>)
                
                <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>: <span style="color: #408080; font-style: italic"># Compute the log2 error difference</span>
                    order_approx<span style="color: #666666">.</span>append(previous_max_log_err <span style="color: #666666">-</span> max_log_err) 
                previous_max_log_err <span style="color: #666666">=</span> max_log_err

                N <span style="color: #666666">*=2</span>
                time <span style="color: #666666">=</span> linspace(t0, tend, N<span style="color: #666666">+1</span>)
                fanalytic <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(time)
                k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
                <span style="color: #008000; font-weight: bold">for</span> tau <span style="color: #AA22FF; font-weight: bold">in</span> time:
                    fanalytic[k] <span style="color: #666666">=</span> f(tau)
                    k <span style="color: #666666">=</span> k <span style="color: #666666">+</span> <span style="color: #666666">1</span>
            
            schemes_order[scheme<span style="color: #666666">.</span>func_name] <span style="color: #666666">=</span> order_approx
            iclr <span style="color: #666666">+=</span> <span style="color: #666666">1</span>

        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>)
        xlabel(<span style="color: #BA2121">&#39;Time&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;log(error)&#39;</span>)
        grid()
        
        N <span style="color: #666666">=</span> N<span style="color: #666666">/2**</span>Ndts
        N_list <span style="color: #666666">=</span> [N<span style="color: #666666">*2**</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Ndts<span style="color: #666666">+1</span>)]
        N_list <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(N_list)
        
        figure()
        <span style="color: #008000; font-weight: bold">for</span> key <span style="color: #AA22FF; font-weight: bold">in</span> schemes_order:
            plot(N_list, (np<span style="color: #666666">.</span>asarray(schemes_order[key])))
        
        <span style="color: #408080; font-style: italic"># Plot theoretical n for 1st, 2nd and 4th order schemes</span>
        axhline(<span style="color: #666666">1.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        axhline(<span style="color: #666666">2.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        axhline(<span style="color: #666666">4.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>N, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        xticks(N_list, rotation<span style="color: #666666">=-70</span>)
        legends <span style="color: #666666">=</span> schemes_order<span style="color: #666666">.</span>keys()
        legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;theoretical&#39;</span>) 
        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        title(<span style="color: #BA2121">&#39;Method of Manufactured Solution&#39;</span>)
        xlabel(<span style="color: #BA2121">&#39;Number of unknowns&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;Scheme order approximation&#39;</span>)
        axis([<span style="color: #666666">0</span>, <span style="color: #008000">max</span>(N_list), <span style="color: #666666">0</span>, <span style="color: #666666">5</span>])
        savefig(<span style="color: #BA2121">&#39;MMSODEschemes.png&#39;</span>, transparent<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #408080; font-style: italic"># test using MMS and solving a set of two nonlinear equations to find estimate of order</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">manufactured_solution_Nonlinear</span>():
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Test convergence rate of the methods, by using the Method of Manufactured solutions.</span>
<span style="color: #BA2121; font-style: italic">            The coefficient function f is chosen to be the normal distribution</span>
<span style="color: #BA2121; font-style: italic">            f = (1/(sigma*sqrt(2*pi)))*exp(-((t-mu)**2)/(2*sigma**2)).</span>
<span style="color: #BA2121; font-style: italic">            The ODE to be solved is than chosen to be: f&#39;&#39;&#39; + f&#39;&#39;*f + f&#39; = RHS,</span>
<span style="color: #BA2121; font-style: italic">            leading to f&#39;&#39;&#39; = RHS - f&#39;&#39;*f - f</span>
<span style="color: #BA2121; font-style: italic">         &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, <span style="color: #008000">abs</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> exp, symbols, diff, lambdify
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sqrt, pi
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log, log2
    
        t <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;t&#39;</span>)
        sigma<span style="color: #666666">=</span>  <span style="color: #666666">0.5</span> <span style="color: #408080; font-style: italic"># standard deviation</span>
        mu <span style="color: #666666">=</span> <span style="color: #666666">0.5</span> <span style="color: #408080; font-style: italic"># mean value</span>
        <span style="color: #408080; font-style: italic">#### Perform needed differentiations based on the differential equation ####</span>
        f <span style="color: #666666">=</span> (<span style="color: #666666">1/</span>(sigma<span style="color: #666666">*</span>sqrt(<span style="color: #666666">2*</span>pi)))<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>((t<span style="color: #666666">-</span>mu)<span style="color: #666666">**2</span>)<span style="color: #666666">/</span>(<span style="color: #666666">2*</span>sigma<span style="color: #666666">**2</span>))
        dfdt <span style="color: #666666">=</span> diff(f, t)
        d2fdt <span style="color: #666666">=</span> diff(dfdt, t)
        d3fdt <span style="color: #666666">=</span> diff(d2fdt, t)
        RHS <span style="color: #666666">=</span> d3fdt <span style="color: #666666">+</span> dfdt<span style="color: #666666">*</span>d2fdt <span style="color: #666666">+</span> f
        <span style="color: #408080; font-style: italic">#### Create Python functions of f, RHS and needed differentiations of f ####</span>
        f <span style="color: #666666">=</span> lambdify([t], f, np)
        dfdt <span style="color: #666666">=</span> lambdify([t], dfdt, np)
        d2fdt <span style="color: #666666">=</span> lambdify([t], d2fdt)
        RHS <span style="color: #666666">=</span> lambdify([t], RHS)

        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">func</span>(y,t):
            <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Function that returns the dfn/dt of the differential equation f + f&#39;&#39;*f + f&#39;&#39;&#39; = RHS</span>
<span style="color: #BA2121; font-style: italic">                as a system of 1st order equations; f = f1 </span>
<span style="color: #BA2121; font-style: italic">                        f1&#39; = f2 </span>
<span style="color: #BA2121; font-style: italic">                        f2&#39; = f3</span>
<span style="color: #BA2121; font-style: italic">                        f3&#39; = RHS - f1 - f2*f3</span>
<span style="color: #BA2121; font-style: italic">            </span>
<span style="color: #BA2121; font-style: italic">                Args:</span>
<span style="color: #BA2121; font-style: italic">                    y(array): solutian array [f1, f2, f3] at time t</span>
<span style="color: #BA2121; font-style: italic">                    t(float): current time</span>
<span style="color: #BA2121; font-style: italic">        </span>
<span style="color: #BA2121; font-style: italic">                Returns:</span>
<span style="color: #BA2121; font-style: italic">                    yout(array): differantiation array [f1&#39;, f2&#39;, f3&#39;] at time t</span>
<span style="color: #BA2121; font-style: italic">            &quot;&quot;&quot;</span>
            yout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(y)
            yout[:] <span style="color: #666666">=</span> [y[<span style="color: #666666">1</span>], y[<span style="color: #666666">2</span>], RHS(t) <span style="color: #666666">-</span>y[<span style="color: #666666">0</span>]<span style="color: #666666">-</span> y[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>y[<span style="color: #666666">2</span>]]
            
            <span style="color: #008000; font-weight: bold">return</span> yout
        
        t0, tend <span style="color: #666666">=</span> <span style="color: #666666">-1.5</span>, <span style="color: #666666">2.5</span>
        z0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([f(t0), dfdt(t0), d2fdt(t0)]) <span style="color: #408080; font-style: italic"># initial values</span>
        
        schemes <span style="color: #666666">=</span> [euler, heun, rk4] <span style="color: #408080; font-style: italic"># list of schemes; each of which is a function</span>
        schemes_error <span style="color: #666666">=</span> {} <span style="color: #408080; font-style: italic"># empty dictionary. to be filled in with lists of error-norms for all schemes</span>
        h <span style="color: #666666">=</span> [] <span style="color: #408080; font-style: italic"># empty list of time step</span>
        
        Ntds <span style="color: #666666">=</span> <span style="color: #666666">4</span> <span style="color: #408080; font-style: italic"># number of times to refine dt</span>
        
        fig, ax <span style="color: #666666">=</span> subplots(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(schemes), sharey <span style="color: #666666">=</span> <span style="color: #008000">True</span>, squeeze<span style="color: #666666">=</span><span style="color: #008000">False</span>)
         
        <span style="color: #008000; font-weight: bold">for</span> k, scheme <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(schemes):
            N <span style="color: #666666">=</span> <span style="color: #666666">20</span>    <span style="color: #408080; font-style: italic"># initial number of time steps</span>
            error <span style="color: #666666">=</span> [] <span style="color: #408080; font-style: italic"># start of with empty list of errors for all schemes</span>
            legendList <span style="color: #666666">=</span> [] 
            
            <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ntds <span style="color: #666666">+</span> <span style="color: #666666">1</span>):
                time <span style="color: #666666">=</span> linspace(t0, tend, N<span style="color: #666666">+1</span>)
                
                <span style="color: #008000; font-weight: bold">if</span> k<span style="color: #666666">==0</span>:
                    h<span style="color: #666666">.</span>append(time[<span style="color: #666666">1</span>] <span style="color: #666666">-</span> time[<span style="color: #666666">0</span>]) <span style="color: #408080; font-style: italic"># add this iteration&#39;s dt to list h</span>
                z <span style="color: #666666">=</span> scheme(func, z0, time) <span style="color: #408080; font-style: italic"># Solve the ODE by calling the scheme with arguments. e.g: euler(func, z0, time) </span>
                fanalytic <span style="color: #666666">=</span> f(time) <span style="color: #408080; font-style: italic"># call analytic function f to compute analytical solutions at times: time</span>
                
                abs_error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(z[:,<span style="color: #666666">0</span>]<span style="color: #666666">-</span> fanalytic) <span style="color: #408080; font-style: italic"># calculate infinity norm of the error</span>
                error<span style="color: #666666">.</span>append(<span style="color: #008000">max</span>(abs_error))
                
                ax[<span style="color: #666666">0</span>][k]<span style="color: #666666">.</span>plot(time, z[:,<span style="color: #666666">0</span>])
                legendList<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;$h$ = &#39;</span> <span style="color: #666666">+</span> <span style="color: #008000">str</span>(h[i]))
                
                N <span style="color: #666666">*=2</span> <span style="color: #408080; font-style: italic"># refine dt</span>
            
            schemes_error[scheme<span style="color: #666666">.</span>func_name] <span style="color: #666666">=</span> error <span style="color: #408080; font-style: italic"># Add a key:value pair to the dictionary. e.g: &quot;euler&quot;:[error1, error2, ..., errorNtds]</span>

            
            ax[<span style="color: #666666">0</span>][k]<span style="color: #666666">.</span>plot(time, fanalytic, <span style="color: #BA2121">&#39;k:&#39;</span>)
            legendList<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;$u_m$&#39;</span>)
            ax[<span style="color: #666666">0</span>][k]<span style="color: #666666">.</span>set_title(scheme<span style="color: #666666">.</span>func_name)
            ax[<span style="color: #666666">0</span>][k]<span style="color: #666666">.</span>set_xlabel(<span style="color: #BA2121">&#39;time&#39;</span>) 
        
        ax[<span style="color: #666666">0</span>][<span style="color: #666666">2</span>]<span style="color: #666666">.</span>legend(legendList, loc <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        ax[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>set_ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
        setp(ax, xticks<span style="color: #666666">=</span>[<span style="color: #666666">-1.5</span>, <span style="color: #666666">0.5</span>,  <span style="color: #666666">2.5</span>], yticks<span style="color: #666666">=</span>[<span style="color: #666666">0.0</span>, <span style="color: #666666">0.4</span> , <span style="color: #666666">0.8</span>, <span style="color: #666666">1.2</span>])
            
        <span style="color: #408080; font-style: italic">#savefig(&#39;../figs/normal_distribution_refinement.png&#39;)</span>
        <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Newton_solver_sympy</span>(error, h, x0):
            <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Function that solves for the nonlinear set of equations</span>
<span style="color: #BA2121; font-style: italic">                error1 = C*h1^p --&gt; f1 = C*h1^p - error1 = 0</span>
<span style="color: #BA2121; font-style: italic">                error2 = C*h2^p --&gt; f2 = C h2^p - error 2 = 0</span>
<span style="color: #BA2121; font-style: italic">                where C is a constant h is the step length and p is the order,</span>
<span style="color: #BA2121; font-style: italic">                with use of a newton rhapson solver. In this case C and p are</span>
<span style="color: #BA2121; font-style: italic">                the unknowns, whereas h and error are knowns. The newton rhapson </span>
<span style="color: #BA2121; font-style: italic">                method is an iterative solver which take the form:</span>
<span style="color: #BA2121; font-style: italic">                xnew = xold - (J^-1)*F, where J is the Jacobi matrix and F is the </span>
<span style="color: #BA2121; font-style: italic">                residual funcion.</span>
<span style="color: #BA2121; font-style: italic">                    x = [C, p]^T</span>
<span style="color: #BA2121; font-style: italic">                    J = [[df1/dx1  df2/dx2],</span>
<span style="color: #BA2121; font-style: italic">                         [df2/dx1  df2/dx2]]</span>
<span style="color: #BA2121; font-style: italic">                    F = [f1, f2]</span>
<span style="color: #BA2121; font-style: italic">                This is very neatly done with use of the sympy module</span>
<span style="color: #BA2121; font-style: italic">                </span>
<span style="color: #BA2121; font-style: italic">                Args:</span>
<span style="color: #BA2121; font-style: italic">                    error(list): list of calculated errors [error(h1), error(h2)]</span>
<span style="color: #BA2121; font-style: italic">                    h(list): list of steplengths corresponding to the list of errors</span>
<span style="color: #BA2121; font-style: italic">                    x0(list): list of starting (guessed) values for x</span>
<span style="color: #BA2121; font-style: italic">                </span>
<span style="color: #BA2121; font-style: italic">                Returns:</span>
<span style="color: #BA2121; font-style: italic">                    x(array): iterated solution of x = [C, p]</span>
<span style="color: #BA2121; font-style: italic">        </span>
<span style="color: #BA2121; font-style: italic">            &quot;&quot;&quot;</span>
            <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> Matrix
            <span style="color: #408080; font-style: italic">#### Symbolic computiations: ####</span>
            C, p <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;C p&#39;</span>)
            f1 <span style="color: #666666">=</span> C<span style="color: #666666">*</span>h[<span style="color: #666666">-2</span>]<span style="color: #666666">**</span>p <span style="color: #666666">-</span> error[<span style="color: #666666">-2</span>]
            f2 <span style="color: #666666">=</span> C<span style="color: #666666">*</span>h[<span style="color: #666666">-1</span>]<span style="color: #666666">**</span>p <span style="color: #666666">-</span> error[<span style="color: #666666">-1</span>]
            F <span style="color: #666666">=</span> [f1, f2]
            x <span style="color: #666666">=</span> [C, p]
            
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">jacobiElement</span>(i,j):
                <span style="color: #008000; font-weight: bold">return</span> diff(F[i], x[j])
                
            Jacobi <span style="color: #666666">=</span> Matrix(<span style="color: #666666">2</span>, <span style="color: #666666">2</span>, jacobiElement) <span style="color: #408080; font-style: italic"># neat way of computing the Jacobi Matrix</span>
            JacobiInv <span style="color: #666666">=</span> Jacobi<span style="color: #666666">.</span>inv()
            <span style="color: #408080; font-style: italic">#### Numerical computations: ####</span>
            JacobiInvfunc <span style="color: #666666">=</span> lambdify([x], JacobiInv)
            Ffunc <span style="color: #666666">=</span> lambdify([x], F)
            x <span style="color: #666666">=</span> x0
            
            <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">8</span>): <span style="color: #408080; font-style: italic">#perform 8 iterations</span>
                F <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(Ffunc(x))
                Jinv <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(JacobiInvfunc(x))
                xnew <span style="color: #666666">=</span> x <span style="color: #666666">-</span> np<span style="color: #666666">.</span>dot(Jinv, F)
                x <span style="color: #666666">=</span> xnew
                <span style="color: #408080; font-style: italic">#print &quot;n, x: &quot;, n, x</span>
            x[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #008000">round</span>(x[<span style="color: #666666">0</span>], <span style="color: #666666">2</span>)
            x[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> <span style="color: #008000">round</span>(x[<span style="color: #666666">1</span>], <span style="color: #666666">3</span>)
            <span style="color: #008000; font-weight: bold">return</span> x
        
        ht <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(h) 
        eulerError <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(schemes_error[<span style="color: #BA2121">&quot;euler&quot;</span>])
        heunError <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(schemes_error[<span style="color: #BA2121">&quot;heun&quot;</span>])
        rk4Error <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(schemes_error[<span style="color: #BA2121">&quot;rk4&quot;</span>])
        
        
        [C_euler, p_euler] <span style="color: #666666">=</span> Newton_solver_sympy(eulerError, ht, [<span style="color: #666666">1</span>,<span style="color: #666666">1</span>])
        [C_heun, p_heun] <span style="color: #666666">=</span> Newton_solver_sympy(heunError, ht, [<span style="color: #666666">1</span>,<span style="color: #666666">2</span>])
        [C_rk4, p_rk4] <span style="color: #666666">=</span> Newton_solver_sympy(rk4Error, ht, [<span style="color: #666666">1</span>,<span style="color: #666666">4</span>])
        
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> latex
        h <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;h&#39;</span>)
        epsilon_euler <span style="color: #666666">=</span> C_euler<span style="color: #666666">*</span>h<span style="color: #666666">**</span>p_euler
        epsilon_euler_latex <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;$&#39;</span> <span style="color: #666666">+</span> latex(epsilon_euler) <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;$&#39;</span>
        epsilon_heun <span style="color: #666666">=</span> C_heun<span style="color: #666666">*</span>h<span style="color: #666666">**</span>p_heun
        epsilon_heun_latex <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;$&#39;</span> <span style="color: #666666">+</span> latex(epsilon_heun) <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;$&#39;</span>
        epsilon_rk4 <span style="color: #666666">=</span> C_rk4<span style="color: #666666">*</span>h<span style="color: #666666">**</span>p_rk4
        epsilon_rk4_latex <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;$&#39;</span> <span style="color: #666666">+</span> latex(epsilon_rk4) <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;$&#39;</span>
        
        <span style="color: #008000; font-weight: bold">print</span> epsilon_euler_latex
        <span style="color: #008000; font-weight: bold">print</span> epsilon_heun_latex
        <span style="color: #008000; font-weight: bold">print</span> epsilon_rk4_latex
        
        epsilon_euler <span style="color: #666666">=</span> lambdify(h, epsilon_euler, np)
        epsilon_heun <span style="color: #666666">=</span> lambdify(h, epsilon_heun, np)
        epsilon_rk4 <span style="color: #666666">=</span> lambdify(h, epsilon_rk4, np)
        
        N <span style="color: #666666">=</span> N<span style="color: #666666">/2**</span>(Ntds <span style="color: #666666">+</span> <span style="color: #666666">2</span>)
        N_list <span style="color: #666666">=</span> [N<span style="color: #666666">*2**</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Ntds <span style="color: #666666">+</span> <span style="color: #666666">2</span>)]
        N_list <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(N_list)
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #008000">len</span>(N_list)
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #008000">len</span>(eulerError)
        figure()
        plot(N_list, log2(eulerError), <span style="color: #BA2121">&#39;b&#39;</span>)
        plot(N_list, log2(epsilon_euler(ht)), <span style="color: #BA2121">&#39;b--&#39;</span>)
        plot(N_list, log2(heunError), <span style="color: #BA2121">&#39;g&#39;</span>)
        plot(N_list, log2(epsilon_heun(ht)), <span style="color: #BA2121">&#39;g--&#39;</span>)
        plot(N_list, log2(rk4Error), <span style="color: #BA2121">&#39;r&#39;</span>)
        plot(N_list, log2(epsilon_rk4(ht)), <span style="color: #BA2121">&#39;r--&#39;</span>)
        LegendList <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;${\epsilon}_{euler}$&#39;</span>, epsilon_euler_latex, <span style="color: #BA2121">&#39;${\epsilon}_{heun}$&#39;</span>, epsilon_heun_latex, <span style="color: #BA2121">&#39;${\epsilon}_{rk4}$&#39;</span>, epsilon_rk4_latex]
        legend(LegendList, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        xlabel(<span style="color: #BA2121">&#39;-log(h)&#39;</span>)
        ylabel(<span style="color: #BA2121">&#39;-log($\epsilon$)&#39;</span>)
        
        <span style="color: #408080; font-style: italic">#savefig(&#39;../figs/MMS_example2.png&#39;)</span>
            
        
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">plot_ODEschemes_solutions</span>():
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Plot the solutions for the test schemes in schemes&quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace
        figure()
        T <span style="color: #666666">=</span> <span style="color: #666666">1.5</span>  <span style="color: #408080; font-style: italic"># end of simulation</span>
        N <span style="color: #666666">=</span> <span style="color: #666666">50</span>  <span style="color: #408080; font-style: italic"># no of time steps</span>
        time <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N<span style="color: #666666">+1</span>)

        z0 <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>

        schemes  <span style="color: #666666">=</span> [euler, heun, rk4]
        legends <span style="color: #666666">=</span> []

        <span style="color: #008000; font-weight: bold">for</span> scheme <span style="color: #AA22FF; font-weight: bold">in</span> schemes:
            z <span style="color: #666666">=</span> scheme(f3, z0, time)
            plot(time, z[:,<span style="color: #666666">-1</span>])
            legends<span style="color: #666666">.</span>append(scheme<span style="color: #666666">.</span>func_name)

        plot(time, u_nonlin_analytical(z0, time))
        legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;analytical&#39;</span>)
        legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)

    manufactured_solution_Nonlinear()
    <span style="color: #408080; font-style: italic">#test_ODEschemes()</span>
    <span style="color: #408080; font-style: italic">#convergence_test()</span>
    <span style="color: #408080; font-style: italic">#plot_ODEschemes_solutions()</span>
    <span style="color: #408080; font-style: italic">#manufactured_solution()</span>
    show()
</pre></div>
<p>
<!-- !split -->

<center><h1 id="ch:2">Shooting Methods for Boundary Value Problems</h1></center> <!-- chapter heading -->

<h1 id="section:linear">Linear equations</h1>

<p>
Skyteteknikk er en metode til å transformere et randverdiproblem for en ODL til et ekvivalent initialverdiproblem. Betegnelsen "skyteteknikk"
stammer fra problemstillingen skissert i Figure <a href="#fig:21">14</a> nedenfor.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 14:  <div id="fig:21"></div> </p></center>
<p><img src="fig-ch2/fig1.png" align="bottom" width=400></p>
</center>

<p>
Finn den vinkelen \( \alpha \)  som gir en gitt skytelengde \( x =  L \). Dette er et randverdiproblem der en betingelse er gitt for \( x= 0 \) og 
en for \( x= L  \). Ved å variere  \( \alpha \), virker det innlysende at dette problemet kan løses når \( L \le L_{maks}  \). Vi skal bruke tankegangen 
ovenfor på problemer som ikke har noe med prosjektiler å gjøre.

<p>
La oss se på et eksempel:

$$
\begin{equation} 
y'' = y(x)
\label{eq:2101}
\end{equation}
$$

<p>
med initialbetingelser:

$$
\begin{equation} 
y(0)=0, \ y'(0) =s  \nonumber
\label{_auto19}
\end{equation}
$$

<p>
\eqref{eq:2101} har følgende analytiske løsning:

$$
\begin{equation}
y(x)=s \cdot \sinh(x)
\label{eq:2102}
\end{equation}
$$

<p>
Vi vil få en ny kurve \( y(x) \) for hver s-verdi vi velger. Figure <a href="#fig:23">15</a> viser et eksempel med \( s= 0.2 \) og \( 0.7 \).

<p>
Vi ønsker egentlig å løse \eqref{eq:2101}  med følgende randbetingelser:

$$
\begin{equation}
y(0)=0, \ y(1) =1
\label{eq:2103}
\end{equation}
$$

<p>
Fra \eqref{eq:2102}  ser vi at dette problemet kan løses ved å velge \( s=s^* \)  slik at \( y(1)=s^*\cdot \sinh(1) \) eller

$$
\begin{equation}
s^*= \frac{1}{\sinh(1)}
\label{eq:2104}
\end{equation}
$$

<p>
I dette tilfellet er vi istand til å finne den analytiske løsningen av både initial- og randverdiproblemet. Når dette ikke er mulig, blir 
fremgangsmåten i vårt tilfelle å velge verdier av s helt til betingelsen \( y(1) = 1 \) er oppfylt. For vilkårlige verdier av s blir da \( y(1) \) en 
funksjon av s.

<p>
La oss se på et randverdiproblem for en 2. ordens <em>lineær</em> differensialligning:

$$
\begin{equation}
y''(x) = p(x) \cdot y'(x) + q(x) \cdot y(x) + r(x)
\label{eq:2105a}
\end{equation}
$$

<p>
med randbetingelser:

$$
\begin{equation}
y(\alpha)=\alpha,\ y(\beta)=\beta
\label{eq:2105b}
\end{equation}
$$

<p>
Skriver \eqref{eq:2105a} som et system:
$$
\begin{equation} \label{eq:2106}
\left.\begin{matrix}
&y'(x) =  g(x) \\ 
&g'(x) =   p(x) \cdot g(x) + q(x) \cdot y(x) + r(x) 
\end{matrix}\right.\ 
\end{equation}
$$

<p>
med randbetingelser gitt i \eqref{eq:2105b}

<p>
Velger randbetingelsen \( y(\alpha)=\alpha \)  som initialbetingelse. Trenger også en initialbetingelse for \( y'(\alpha) \equiv g(\alpha) \). Denne 
mangler, og for å kunne løse \eqref{eq:2106}  som et initialverdiproblem, må vi tippe en verdi for \( y'(\alpha) \)  slik at randbetingelsen 
\( y(b)=\beta  \) blir oppfylt. Da \eqref{eq:2105a} er en 2. ordens lineær differensialligning, er det tilstrekkelig å beregne to verdier for 
\( s=g(\alpha) \equiv y'(\alpha) \). Den rette verdien finnes ved lineær interpolering. Merk at \( y(x) \) alltid er proposjonal med \( s \) når ligningen 
er lineær og homogen.

<p>
Setter

$$
\begin{equation}
\phi (s) =y(b;s)-\beta
\label{eq:2107}
\end{equation}
$$

<p>
der

$$
\begin{equation*}
s=g(\alpha) \equiv y'(\alpha)
\end{equation*}
$$

<p>
Den rette verdien \( s= s^* \) er funnet når

$$
\begin{equation}
\phi (s^*)=0
\label{eq:2108}
\end{equation}
$$

<p>
Fremgangsmåten blir: Vi tipper to verdier \( s^0 \) og \( s^1 \)  og beregner de tilhørende verdiene \( \phi ^0 \) og \( \phi ^1 \)   fra \eqref{eq:2107}  ved å 
løse ligningsystemet i \eqref{eq:2106}. Egentlig bør vi skrive  \( s^{(0)} \) og \( s^{(1)} \), men bruker  \( s^0 \) og \( s^1 \)  når misforståelser 
(forhåpentligvis) ikke er mulig.

<p>
Den korrekte verdien for \( s \) finnes ved lineær interpolering som vist i Figure <a href="#fig:22">fig:22</a>.

<p>
<!-- FIGURE:[fig-ch2/fig2, width=250] <div id="fig:22"></div> -->

$$
\begin{equation*}
\phi=k\cdot s+b, \qquad k=\frac{\phi ^1-\phi ^0}{s^1-s^0}, \qquad b= \frac{s^1\cdot \phi ^0 - \phi ^1  \cdot s^0}{s^1-s^0}
\end{equation*}
$$

<p>
\( \phi =0 \) for \( s^*=-\dfrac{b}{k} \) som gir:

$$
\begin{equation}
\label{eq:2109}
s^*=s^1+\delta s, \ \delta s = -\phi ^1 \cdot \left(\frac{s^1-s^0}{\phi^1 - \phi^0}\right) \to s^*= \frac{\phi^1 s^0-\phi^0 s^1}{\phi^1-\phi^0}
\end{equation}
$$

<p>
La oss gå tilbake til eksemplet i \eqref{eq:2101}:

$$
\begin{equation} \label{eq:21010}
\left.\begin{matrix}
&y'' = y(x) \\ 
&y(0)=0,\ y(1) =1 
\end{matrix}\right.\ 
\end{equation}
$$

<p>
med analytisk løsning:

$$
\begin{equation*}
y(x)=\frac{\sinh(x)}{\sinh(1)}
\end{equation*}
$$

<p>
Skriver først \eqref{eq:21010}  som et system:
$$
\begin{equation} \label{eq:21011}
\left.\begin{matrix}
y'(x)=g(x) \\ 
g'(x)=y(x)
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Setter

$$
\begin{equation}
\phi (s)=y(1;s)-1
\label{eq:21012}
\end{equation}
$$

<p>
der \( s=y'(0)=g(0) \)

<p>
Randbetingelser: \( y(0)=0, y(1)=1 \)

<p>
Den rette verdien \( s= s^* \) er funnet når \eqref{eq:2108}  er oppfylt.

<p>
Velger \( s^0=0.2 \) og \( s^1=0.7 \).

<p>
Med disse verdiene for \( s \) og med \( \Delta x=0.1 \) , gir \eqref{eq:21010} med bruk av RK4 følgende tabell:

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( m \)</td> <td align="center">\( s^m \)</td> <td align="center">\( \phi(s^m) \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   0          </td> <td align="center">   0.2          </td> <td align="center">   -0.7650            </td> </tr>
<tr><td align="center">   1          </td> <td align="center">   0.7          </td> <td align="center">   -0.1774            </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-3 -->
<p>
\( m \) som øvre indeks brukes her og senere som nummerteller, f.eks. iterasjonsnummer.

<p>
Innsatt for tabellverdier i \eqref{eq:2109}:  \( s^*=0.8510 \)
Ved å bruke denne verdien for \( s=y'(0) \) får vi \( \phi (0.8510)=0.0001 \)

<p>
Korrekt verdi:  \( y'(0)=\dfrac{1}{\sinh(1)}=0.8509 \)

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 15:  <div id="fig:23"></div> </p></center>
<p><img src="fig-ch2/fig3.png" align="bottom" width=350></p>
</center>

<p>
Framstillingen ovenfor er valgt fordi den lett kan generaliseres til løsning av ikke-lineære differensialligninger. Dersom vi bare er interessert 
i  2. ordens <em>lineære</em>  ligninger, kan framstillingen forenkle. I det lineære tilfellet kan man løse følgende to startverdi-delproblemer:

$$
\begin{align}
&y_0''(x)=p(x) \cdot y_0'(x) + q(x) \cdot y_0(x) + r(x) \label{eq:21013a}\\ 
&y_0(a)=\alpha , \ y_0'(a)=0 \label{eq:21013b}\\ 
\label{_auto20}
\end{align}
$$


$$
\begin{align}
&y_1''(x)=p(x) \cdot y_1'(x) + q(x) \cdot y_1(x) \label{eq:21014a} \\ 
&y_1(a)=0 , \ y_1'(a)=1 \label{eq:21014b}
\end{align}
$$

<p>
Legg merke til at betingelsen \( y'(\alpha)=0 \)  i \eqref{eq:21013b}  tilsvarer \( s^0=0 \)  og betingelsen \( y'(\alpha)=1 \) i \eqref{eq:21014b} 
tilsvarer \( s^1=1 \).

<p>
La \( y_0(x) \)  være løsningen av \eqref{eq:21013a} med randbetingelsene \eqref{eq:21013b}  og \( y_1(x) \)  løsningen av \eqref{eq:21014a} med 
randbetingelsene \eqref{eq:21014b}. Den fullstendige løsningen av randverdiproblemet i \eqref{eq:2105a} med randbetingelsene \eqref{eq:2105b} er 
da gitt ved:

$$
\begin{equation}
y(x)=y_0(x) + \left[\frac{\beta - y_0(b)}{y_1(b)}\right]\cdot y_1(x) = y_0(x) - \left[\frac{\phi^0}{\phi^1+\beta}\right]\cdot y_1(x)
\label{eq:21015}
\end{equation}
$$

<p>
med \( s^0=0 \) og \( s^1=1 \).

<p>
<!-- !split -->

<h2 id="ex:21">Example: Couette - Poiseuille strømning</h2>

<p>
Dette er en strømning mellom to parallelle plater. Den ene plata beveger seg mens den andre er i ro. Dessuten har vi en foreskrevet trykkgradient.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 16:  <div id="fig:24"></div> </p></center>
<p><img src="fig-ch2/fig4transp_couette.png" align="bottom" width=600></p>
</center>

<p>
Plata ved \( Y= L \)  beveger seg med konstant hastighet \( U_0 \) . Hastigheten \( V \) i Y-retning \( =0 \) og trykkgradienten \( \frac{\delta p}{\delta x} \) 
er foreskrevet.

<p>
Kontinuitet: \( \frac{\partial U}{\partial X}=0 \) da \( V=0 \) som impliserer at \( U=U(Y) \). Bevegelsesligningen  i Y-retning forenkler seg til 
\( \frac{\partial p}{\partial Y}=-\rho g \) Bevegelsesligningen i X-retning:

$$
\begin{equation*}
\rho U \cdot \frac{\partial U}{\partial X}=-\frac{\partial p}{\partial X} + \mu \left(\frac{\partial^2U}{\partial X^2}+  \frac{\partial^2U}{\partial Y^2}\right) 
\rightarrow \frac{d^2U}{dY^2} =\frac{1}{\mu}\frac{dp}{dX}
\end{equation*}
$$

<p>
Randbetingelser: \( U(0)=0,\ U(L)=U_0 \).

<p>
Innfører dimensjonsløse variable:  \( u=\frac{U}{U_0},\ y=\frac{Y}{L},\ P=-\frac{1}{U_0}(\frac{dp}{dX})\frac{L^2}{\mu} \)

<p>
Får da følgende ligning: 

$$
\begin{equation}
\frac{d^2u}{dy^2}=-P
\label{eq:e2101a}
\end{equation}
$$

<p>
med randbetingelser:

$$
\begin{equation}
u=0 \ \text{for} \ y=0,\ u=1 \ \text{for} \ y=1
\label{eq:e2101b}
\end{equation}
$$

<p>
Den analytiske løsningen av \eqref{eq:e2101a} med randbetingelser \eqref{eq:e2101b} er:

$$
\begin{equation}
u=y \cdot \left[ 1+\frac{P}{2}(1-y) \right]
\label{eq:e2102}
\end{equation}
$$

<p>
For \( P\leq -2 \)  får vi tilbakestrømning. Figure <a href="#fig:25">17</a> viser hastighetsfordelingen for forskjellige verdier av P.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 17:  <div id="fig:25"></div> </p></center>
<p><img src="fig-ch2/fig5.png" align="bottom" width=400></p>
</center>

<p>
Skriver \eqref{eq:e2101a} som et ligningsystem:

$$
\begin{equation} \label{eq:e12103a} 
\left.\begin{matrix}
&u'(y)=u_1(y) \\ 
&u_1'(y)=-P
\end{matrix}\right.\ 
\end{equation}
$$

<p>
med randbetingelser:

$$
\begin{equation}
u(0)=0,\ u(1)=1
\label{eq:e12103b}
\end{equation}
$$

<p>
Vi må bestemme \( s=u'(0)=u_1(0) \)  slik at randbetingelsen \( u(1)=1 \) blir oppfylt.  Dette kan uttrykkes på følgende måte:

$$
\begin{align*}
\phi(s)=u(1;s)-1,  &\text{ slik at }&  \phi(s)=0 & \text{når} &s=s^*
\end{align*} 
$$

<p>
Vi tipper to verdier \( s^0 \)  og \( s^1 \) og beregner den rette s ved lineær interpolering, se ligning \eqref{eq:2109}. Programmet nedenfor 
\( Couette\_Poiseuille\_shoot.py \) for beregning og plotting av hastighetsfordelingen for ulike trykkgradienter.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter2/src-ch2/Couette_Poiseuille_shoot.py;ODEschemes.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter2/src-ch2/ODEschemes.py;</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">ODEschemes</span> <span style="color: #008000; font-weight: bold">import</span> euler, heun, rk4
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #408080; font-style: italic"># change some default values to make plots more readable </span>
LNWDT<span style="color: #666666">=5</span>; FNT<span style="color: #666666">=11</span>
rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}; rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)


N<span style="color: #666666">=200</span>
L <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>,L,N<span style="color: #666666">+1</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;RHS for Couette-Posieulle flow&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>], <span style="color: #666666">-</span>dpdx]
    <span style="color: #008000; font-weight: bold">return</span> zout 

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">u_a</span>(y,dpdx):
    <span style="color: #008000; font-weight: bold">return</span> y<span style="color: #666666">*</span>(<span style="color: #666666">1.0</span> <span style="color: #666666">+</span> dpdx<span style="color: #666666">*</span>(<span style="color: #666666">1.0-</span>y)<span style="color: #666666">/2.0</span>);

beta<span style="color: #666666">=1.0</span> <span style="color: #408080; font-style: italic"># Boundary value at y = L</span>


<span style="color: #408080; font-style: italic"># Guessed values</span>
s<span style="color: #666666">=</span>[<span style="color: #666666">1.0</span>, <span style="color: #666666">1.5</span>]

z0<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #666666">2</span>)

dpdx_list<span style="color: #666666">=</span>[<span style="color: #666666">-5.0</span>, <span style="color: #666666">-2.5</span>, <span style="color: #666666">-1.0</span>, <span style="color: #666666">0.0</span>, <span style="color: #666666">1.0</span>,<span style="color: #666666">2.5</span>, <span style="color: #666666">5.0</span>]
legends<span style="color: #666666">=</span>[]

<span style="color: #008000; font-weight: bold">for</span> dpdx <span style="color: #AA22FF; font-weight: bold">in</span> dpdx_list:
    phi <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> svalue <span style="color: #AA22FF; font-weight: bold">in</span> s:
        z0[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> svalue
        z <span style="color: #666666">=</span> rk4(f, z0, y)
        phi<span style="color: #666666">.</span>append(z[<span style="color: #666666">-1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">-</span> beta)
    
    <span style="color: #408080; font-style: italic"># Compute correct initial guess </span>
    s_star <span style="color: #666666">=</span> (s[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>phi[<span style="color: #666666">1</span>]<span style="color: #666666">-</span>s[<span style="color: #666666">1</span>]<span style="color: #666666">*</span>phi[<span style="color: #666666">0</span>])<span style="color: #666666">/</span>(phi[<span style="color: #666666">1</span>]<span style="color: #666666">-</span>phi[<span style="color: #666666">0</span>])
    z0[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> s_star
    
    <span style="color: #408080; font-style: italic"># Solve the initial value problem which is a solution to the boundary value problem</span>
    z <span style="color: #666666">=</span> rk4(f, z0, y)

    plot(z[:,<span style="color: #666666">0</span>],y,<span style="color: #BA2121">&#39;-.&#39;</span>)
    legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;rk4: dp=&#39;</span><span style="color: #666666">+</span><span style="color: #008000">str</span>(dpdx))
    
    <span style="color: #408080; font-style: italic"># Plot the analytical solution</span>
    plot(u_a(y, dpdx),y,<span style="color: #BA2121">&#39;:&#39;</span>)
    legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;exa: dp=&#39;</span><span style="color: #666666">+</span><span style="color: #008000">str</span>(dpdx))

<span style="color: #408080; font-style: italic"># Add the labels</span>
legend(legends,loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>,frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>) <span style="color: #408080; font-style: italic"># Add the legends</span>
xlabel(<span style="color: #BA2121">&#39;u/U0&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;y/L&#39;</span>)
show()
</pre></div>
<p>
<!-- !split -->

<h2 id="ex:22">Example: Bjelkesøyle med konstant tverrsnitt</h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 18:  <div id="fig:26"></div> </p></center>
<p><img src="fig-ch2/fig6transp_beam.png" align="bottom" width=400></p>
</center>

<p>
Figuren viser en bjelkesøyle påkjent av en jevnt fordelt last \( q \) pr. lengdeenhet samt en horisontal kraft \( P \).

<p>
Differensial-ligningen for utbøyningen \( U(X) \) er gitt ved: 

$$
\begin{equation}
\frac{d^2U}{dX^2}+\frac{P}{EI}U=-\frac{q}{2EI}(L^2-X^2), \ P>0
\label{eq:e22101a}
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{equation}
U(-L)=U(L)=0
\label{eq:e22101b}
\end{equation}
$$

<p>
\( EI \) er bjelkestivheten. Antar små utbøyninger. (Lineær ligning).

<p>
Alternativt kan vi benytte \( \frac{dU}{dX}(0)=0 \)   p.g.a symmtrien.

<p>
Dimensjonsløse variable:

$$
\begin{equation}
x=\frac{x}{L},\ u=\frac{P}{qL^2}\cdot U,\ \theta^2=\frac{PL^2}{EI}
\label{eq:e22102}
\end{equation}
$$

<p>
som innført i \eqref{eq:e22101a} og \eqref{eq:e22101b} gir:

$$
\begin{equation}
\frac{d^2u}{dx^2}+\theta^2 \cdot u=\theta^2\frac{(1-x^2)}{2},\ -1 < x < 1
\label{eq:e22103a}
\end{equation}
$$

<p>
med randbetingelser:

$$
\begin{equation}
u(-1)=0,\ \ u(1)=0
\label{eq:e22103b}
\end{equation}
$$

<p>
\eqref{eq:e22103a} med randbetingelsene \eqref{eq:e22103b} kan løses analytisk:

$$
\begin{equation}
u(x)=\frac{1}{\theta^2}\cdot \left[ \frac{\cos(\theta x)}{\cos(\theta)}-1 \right]-\frac{(1-x^2)}{2}
\label{eq:e22104}
\end{equation}
$$

<p>
Knekklasta for dette tilfellet er gitt ved \( P_k=\dfrac{\pi EI}{4L^2} \)   slik at

$$
\begin{equation}
0\leq \theta \leq \frac{\pi}{2}
\label{eq:e22105}
\end{equation}
$$

<p>
<b>Numerisk løsning</b>

<p>
Vi  ønsker å løse \eqref{eq:e22103a} ved bruk av skyteteknikk.  Velger nå å bruke fremgangsmåten i forbindelse med lign. \eqref{eq:21015}. 
Må da løse følgende to system:

$$
\begin{equation} \label{eq:e22106}
\left.\begin{matrix}
&u_0''(x)=-\theta ^2\cdot \left[ u_0(x)+\frac{(1-x^2)}{2} \right] \\ 
&u_0(-1)=0,\ \ u_0'(-1)=0
\end{matrix}\right.\ 
\end{equation}
$$


$$
\begin{equation} \label{eq:e22107} 
\left.\begin{matrix}
&u_1''(x)=-\theta^2\cdot u_1(x) \\ 
&u_1(-1)=0,\ \ u_1'(-1)=1
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Den fullstendige løsningen er da gitt ved:

$$
\begin{equation}
u(x)=u_0(x)-\frac{u_0(1)}{u_1(1)}\cdot u_1(x)
\label{eq:e22108}
\end{equation}
$$

<p>
Skriver \eqref{eq:e22106} og  \eqref{eq:e22107} som ligningsystem.

<p>
<b>System 1</b>
Med \( u_0=y_1 \) og \( u_o'=y_2 \):
$$
\begin{equation} \label{eq:e22109a}
\left.\begin{matrix}
&y_1'=y_2 \\ 
&y_2'=-\theta^2\cdot \left[ y_1+\frac{(1-x^2)}{2} \right]
\end{matrix}\right.\ 
\end{equation}
$$

<p>
med startbetingelser

$$
\begin{equation}
\label{eq:e22109b}
y_1(-1)=0,\ y_2(-1)=0
\end{equation}
$$

<p>
<b>System 2</b>
Med \( u_1=y_1 \) og \( u_1'=y_2 \):
$$

\begin{equation} \label{eq:e221010a}
\left.\begin{matrix}
&y_1'=y_2 \\ 
&y_2'=-\theta^2y_1
\end{matrix}\right.\ 
\end{equation}
$$

<p>
med startbetingelser

$$
\begin{equation}
\label{eq:e221010b}
y_1(-1)=0,\ y_2(-1)=1
\end{equation}
$$

<p>
Begge system integreres fra   til \( x=-1 \) til \( x=1 \) slik at \( u_0(1) \) og \( u_1(1) \)  kan finnes. Den fullstendige løsningen er da gitt 
av \eqref{eq:e22108}. Ved hjelp av RK4, og lastparameteren \( \theta =1 \) oppnås resultatene i tabellen under. Intervallet er delt i 20 deler og tabellen 
viser at overenstemmelsen er god mellom numerisk og  analytisk løsning. Dessuten ser vi at symmetribetingelsen er oppfylt.

<p>
<!-- Matlab-programmet <b>beamcol</b> viser hvordan dette kan gjøres. Vi har brukt <b>rk4c</b> i dette tilfellet. Intervallet er delt i -->
<!-- 20 deler og tabellen viser at over-enstemmelsen er god mellom numerisk og  analytisk løsning. Dessuten ser vi at -->
<!-- symmetribetingelsen er oppfylt. Beregningen er gjort for lastparameteren \( \theta =1 \) -->

<!-- begin inline comment -->
<font color="red">(<b>Marie 1</b>: I kompendiet henvises det til et matlab-program, beamcol. Foreløpig finnes ikke et tilsvarende python-program.)</font>
<!-- end inline comment -->

<p>

<div class="row">
  <div class="col-xs-4">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( x \)</td> <td align="center">\( u_{comput.} \)</td> <td align="center">\( u_{analyt.} \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   -1.000     </td> <td align="center">   0.0000e+000          </td> <td align="center">   0.0000e+000          </td> </tr>
<tr><td align="center">   -0.900     </td> <td align="center">   5.5485e-002          </td> <td align="center">   5.5485e-002          </td> </tr>
<tr><td align="center">   -0.800     </td> <td align="center">   1.0948e-001          </td> <td align="center">   1.0948e-001          </td> </tr>
<tr><td align="center">   -0.700     </td> <td align="center">   1.6058e-001          </td> <td align="center">   1.6058e-001          </td> </tr>
<tr><td align="center">   -0.600     </td> <td align="center">   2.0754e-001          </td> <td align="center">   2.0754e-001          </td> </tr>
<tr><td align="center">   -0.500     </td> <td align="center">   2.4924e-001          </td> <td align="center">   2.4924e-001          </td> </tr>
<tr><td align="center">   -0.400     </td> <td align="center">   2.8471e-001          </td> <td align="center">   2.8471e-001          </td> </tr>
<tr><td align="center">   -0.300     </td> <td align="center">   3.1315e-001          </td> <td align="center">   3.1315e-001          </td> </tr>
<tr><td align="center">   -0.200     </td> <td align="center">   3.3392e-001          </td> <td align="center">   3.3392e-001          </td> </tr>
<tr><td align="center">   -0.100     </td> <td align="center">   3.4657e-001          </td> <td align="center">   3.4657e-001          </td> </tr>
<tr><td align="center">   0.000      </td> <td align="center">   3.5081e-001          </td> <td align="center">   3.5082e-001          </td> </tr>
<tr><td align="center">   0.100      </td> <td align="center">   3.4657e-001          </td> <td align="center">   3.4657e-001          </td> </tr>
<tr><td align="center">   0.200      </td> <td align="center">   3.3392e-001          </td> <td align="center">   3.3392e-001          </td> </tr>
<tr><td align="center">   0.300      </td> <td align="center">   3.1315e-001          </td> <td align="center">   3.1315e-001          </td> </tr>
<tr><td align="center">   0.400      </td> <td align="center">   2.8471e-001          </td> <td align="center">   2.8471e-001          </td> </tr>
<tr><td align="center">   0.500      </td> <td align="center">   2.4924e-001          </td> <td align="center">   2.4924e-001          </td> </tr>
<tr><td align="center">   0.600      </td> <td align="center">   2.0754e-001          </td> <td align="center">   2.0754e-001          </td> </tr>
<tr><td align="center">   0.700      </td> <td align="center">   1.6058e-001          </td> <td align="center">   1.6058e-001          </td> </tr>
<tr><td align="center">   0.800      </td> <td align="center">   1.0948e-001          </td> <td align="center">   1.0948e-001          </td> </tr>
<tr><td align="center">   0.900      </td> <td align="center">   5.5485e-002          </td> <td align="center">   5.5485e-002          </td> </tr>
<tr><td align="center">   1.000      </td> <td align="center">   0.0000e+000          </td> <td align="center">   0.0000e+000          </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-4 -->
<p>
<!-- !split -->

<h2 id="ex:23">Example: Bjelkesøyler med variabelt tverrsnitt</h2>

<p>
Vi henviser til samme figuren som i forrige eksempel (<a href="#ex:22">Example: Bjelkesøyle med konstant tverrsnitt</a>). Forskjellen er at nå lar vi bjelken ha variabelt tverrsnitt der 2. arealmoment 
\( I \) er funksjon av \( X \). Med \( I_0 \)   som 2. arealmomet for \( X=0 \)  , lar vi \( I \) variere på følgende måte:

$$
\begin{equation}
I(X)=\frac{I_0}{1+(X/L)^n},\ n=2, 4, 6, \dots
\label{eq:e32101}
\end{equation}
$$

<p>
Dersom vi for eksempel betrakter et rektangulært tverrsnitt med høyde \( h \) og konstant bredde \( b \), vil høyden \( h \) variere som følger:

$$
\begin{equation}
h(X)=\frac{h_0}{[1+(X/L)^n]^{1/3}}
\label{eq:e32102}
\end{equation}
$$

<p>
der \( h_0 \)  er høyden for \( X=0 \).  Fra lign. \eqref{eq:e22101a}) i eksempel (<a href="#ex:22">Example: Bjelkesøyle med konstant tverrsnitt</a>):

$$
\begin{align}
\label{eq:e32103a}
&\frac{d^2U}{dX^2}+\frac{P}{EI}U=-\frac{q}{2EI}(L^2-X^2) \\ 
&U(-L)=U(L)=0,\ \frac{dU(0)}{dX}=0 
\label{_auto21}
\end{align}
$$

<p>
La oss først beregne momentfordelingen \( M(X) \)  i bjelken.

<p>
Nå har vi:

$$
\begin{equation}
\frac{d^2U}{dX^2}=-\frac{M}{EI}
\label{eq:e32104}
\end{equation}
$$

<p>
Ved å bruke \eqref{eq:e32104} i \eqref{eq:e32103a} og derivere to ganger, får vi:

$$
\begin{equation}
\frac{d^2M}{dX^2}+\frac{P}{EI}M=-q
\label{eq:e32105}
\end{equation}
$$

<p>
Innfører dimensjonsløse variable

$$
\begin{equation}
x=\frac{X}{L},\ m=\frac{M}{qL^2} \ \text{og setter} \  P=\frac{EI_0}{L^2}
\label{eq:e32106}
\end{equation}
$$

<p>
slik at \eqref{eq:e32105} blir:

$$
\begin{equation}
m''(x)+(1+x^n)\cdot m(x)=-1
\label{eq:e32107a}
\end{equation}
$$

<p>
med randbetingelser:

$$
\begin{equation}
m(-1)=m(1)=0,\ m'(0)=0
\label{eq:e32107b}
\end{equation}
$$

<p>
<br />

<p>
I motsetning til ligningene i forrige eksempel (<a href="#ex:22">Example: Bjelkesøyle med konstant tverrsnitt</a>), finnes det ikke en brukbar analytisk løsning av \eqref{eq:e32107a}, selv om 
ligningen er lineær.

<p>
Dersom du f. eks. har programmet <em>Maple</em> for hånden, kan du forsøke følgende:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">eq:= diff(m(x),x,x) + (1+x^2)*m(x) +1;
dsolve(eq,m(x));
</pre></div>
<p>
Når momentfordelingen er funnet, finnes nedbøyningen \( u(x) \) fra:

$$
\begin{equation}
u(x)=m(x)-\frac{1}{2}(1-x^2)
\label{eq:e32108}
\end{equation}
$$

<p>
Den dimensjonelle nedbøyningen \( U \) er gitt ved:

$$
\begin{equation}
U=\frac{qL^4}{EI_0} u
\label{eq:e32109}
\end{equation}
$$

<p>
Ved å sette \eqref{eq:e32108} inn i \eqref{eq:e32107a}, finner vi diff.ligningen for \( u(x) \):

$$
\begin{equation}
u''(x)+(1+x^n)\cdot u(x)=-\frac{1}{2}(1-x^2)\cdot (1+x^n)
\label{eq:e321010}
\end{equation}
$$

<p>
Ved å benytte oss av symmetrien, løser vi nå \eqref{eq:e32107a} med randbetingelsene \( m(1)=0,\ m'(0)=0 \) ved bruk av skyteteknikk, og beregner 
deretter \( u(x) \)  fra \eqref{eq:e32108}. Nå bruker vi <b>ode45</b> som løser istedenfor <b>rk4c</b>. 
<!-- begin inline comment -->
<font color="red">(<b>Marie 2</b>: Henvisninger til Matlab)</font>
<!-- end inline comment -->

<p>
Skriver  \eqref{eq:e32107a} som et system  med \( m(x)=y_1(x) \) og \( m'(x)=y_2(x) \):

$$
\begin{equation} \label{eq:e321011a}
\left.\begin{matrix}
&y_1'=y_2 \\ 
&y_2'=-[1+(1+x^n)\cdot y_1]
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{equation}
\label{eq:e321011b}
y_2(0)=y_1(1)=0
\end{equation}
$$

<p>
<br />

<p>
Da \( y_2(0)\equiv m'(0) \)  er gitt, må vi tippe \( m(0)\equiv y_1(0) \)   slik at betingelsen \( m(1)\equiv y_1(1)=0 \)   blir oppfylt. Eller uttrykt 
på standard-måten:

<p>
Velger \( s=y_1(0) \)   og setter \( \phi (s)=y_1(1;s) \). Bestemmer \( s=s^* \)   slik at betingelsen \( \phi (s^*)\equiv y_1(1;s^*)=0 \)  blir oppfylt. 
Da ligningen er lineær, finnes \( s^* \)  fra  \eqref{eq:2109}:

$$
\begin{equation}
s^*=\frac{\phi^1s^0-\phi^0s^1}{\phi^1-\phi^0}
\label{eq:e321012a}
\end{equation}
$$

<p>
Ved å velge \( s^0=0 \) og \( s^1=1 \):

$$
\begin{equation}
s^*=\frac{\phi^0}{\phi^0-\phi^1}
\label{eq:e321012b}
\end{equation}
$$

<p>
Vær klar over at valget i \eqref{eq:e321012b} ikke alltid er fornuftig selv om det er rett i prinsippet når ligningen er lineær. Dersom løsningen 
er av typen \( e^{\alpha x} \)   der \( \alpha \)   er stor samtidig som \( x \) er stor, kan vi risikere å komme utenfor tallområdet selv for dobbelpresisjon 
som er ca  \( 10^{308} \). I tilfellet ovenfor er ikke dette noe problem, slik at  \eqref{eq:e321012b} kan brukes. 
Beregningen er utført av programmet <b>momentdis</b> 
<!-- begin inline comment -->
<font color="red">(<b>Marie 3</b>: Henvisning til Matlab-program)</font>
<!-- end inline comment -->
 med tabell og plott nedenfor av både momentet og forskyvningen 
for \( n=2 \).

<p>

<div class="row">
  <div class="col-xs-5">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( \textbf{x} \)</td> <td align="center">\( \textbf{m} \)</td> <td align="center">\( \textbf{u} \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   0.000               </td> <td align="center">   9.3205e-001         </td> <td align="center">   4.3205e-001         </td> </tr>
<tr><td align="center">   0.050               </td> <td align="center">   9.2964e-001         </td> <td align="center">   4.3089e-001         </td> </tr>
<tr><td align="center">   0.100               </td> <td align="center">   9.2239e-001         </td> <td align="center">   4.2739e-001         </td> </tr>
<tr><td align="center">   0.150               </td> <td align="center">   9.1032e-001         </td> <td align="center">   4.2157e-001         </td> </tr>
<tr><td align="center">   0.200               </td> <td align="center">   8.9342e-001         </td> <td align="center">   4.1342e-001         </td> </tr>
<tr><td align="center">   0.250               </td> <td align="center">   8.7170e-001         </td> <td align="center">   4.0295e-001         </td> </tr>
<tr><td align="center">   0.300               </td> <td align="center">   8.4516e-001         </td> <td align="center">   3.9016e-001         </td> </tr>
<tr><td align="center">   0.350               </td> <td align="center">   8.1382e-001         </td> <td align="center">   3.7507e-001         </td> </tr>
<tr><td align="center">   0.400               </td> <td align="center">   7.7769e-001         </td> <td align="center">   3.5769e-001         </td> </tr>
<tr><td align="center">   0.450               </td> <td align="center">   7.3681e-001         </td> <td align="center">   3.3806e-001         </td> </tr>
<tr><td align="center">   0.500               </td> <td align="center">   6.9122e-001         </td> <td align="center">   3.1622e-001         </td> </tr>
<tr><td align="center">   0.550               </td> <td align="center">   6.4097e-001         </td> <td align="center">   2.9222e-001         </td> </tr>
<tr><td align="center">   0.600               </td> <td align="center">   5.8614e-001         </td> <td align="center">   2.6614e-001         </td> </tr>
<tr><td align="center">   0.650               </td> <td align="center">   5.2681e-001         </td> <td align="center">   2.3806e-001         </td> </tr>
<tr><td align="center">   0.700               </td> <td align="center">   4.6311e-001         </td> <td align="center">   2.0811e-001         </td> </tr>
<tr><td align="center">   0.750               </td> <td align="center">   3.9519e-001         </td> <td align="center">   1.7644e-001         </td> </tr>
<tr><td align="center">   0.800               </td> <td align="center">   3.2323e-001         </td> <td align="center">   1.4323e-001         </td> </tr>
<tr><td align="center">   0.850               </td> <td align="center">   2.4745e-001         </td> <td align="center">   1.0870e-001         </td> </tr>
<tr><td align="center">   0.900               </td> <td align="center">   1.6810e-001         </td> <td align="center">   7.3104e-002         </td> </tr>
<tr><td align="center">   0.950               </td> <td align="center">   8.5503e-002         </td> <td align="center">   3.6753e-002         </td> </tr>
<tr><td align="center">   1.000               </td> <td align="center">   7.7259e-012         </td> <td align="center">   7.7259e-012         </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-5 -->
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 19:  Moment m og nedbøyning u. <div id="fig:27"></div> </p></center>
<p><img src="fig-ch2/fig7.png" align="bottom" width=400></p>
</center>

<p>
<!-- !split -->

<h1 id="ch2:sec2">Ikke-lineære ligninger</h1>

<p>
Gitt randverdiproblemet
$$
\begin{equation} \label{eq:2201}
\left.\begin{matrix}
&y''(x)=\frac{3}{2}y^2 \\ 
&y(0)=4,\  y(1)=1
\end{matrix}\right.\ 
\end{equation}
$$

<p>
\eqref{eq:2201} har to løsninger som tilfredstiller de gitte randbetingelsene:

<p>
Løsning I:

$$
\begin{equation}
y_I=\frac{4}{(1+x)^2}
\label{eq:2202}
\end{equation}
$$

<p>
Løsning II kan uttrykkes ved elliptiske Jacobi-funksjoner; se appendiks G del G.3 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a> .
Begge løsningene er tegnet i Figure <a href="#fig:28">20</a> . Skriver \eqref{eq:2201} som et ligningsystem med  \( y\to y_1 \) og \( y'=y_1'=y_2 \):

$$
\begin{equation} \label{eq:2203a}
\left.\begin{matrix}
&y_1'(x)=y_2(x) \\ 
&y_2'(x)=\frac{3}{2}[y_1(x)]^2
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{equation}
y_1(0)=4,\ y_1(1)=1
\label{eq:2203b}
\end{equation}
$$

<p>
<br />

<p>
Vi bestemmer \( s=y'(0)=y_2(0) \)  slik at randbetingelsen \( y_1(1)=1 \)   blir oppfylt. Setter følgelig:

$$
\begin{align}
\phi (s^m)=y_1(1;s^m)-1,\ m=0,1,\dots
\label{eq:2204a}
\text{slik at} \ y_1(1)\to 1 \ \text{for} \ \phi (s^m)\to0,\ m\to \infty
\end{align}
$$

<p>
<br />

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 20:  De to løsningene \( y_I \) og \( y_{II} \) av differensialligningen \eqref{eq:2201} <div id="fig:28"></div> </p></center>
<p><img src="fig-ch2/fig8.png" align="bottom" width=400></p>
</center>

<p>
Da ligningen er ikke-lineær, må vi utføre en iterasjonsprosess som indikert i \eqref{eq:2204a}. Oppgava blir da å bestemme nullpunktet(ene) \( s^* \)    
i funksjonen \( \phi (s)=0 \). Vi velger å bruke <em>sekantmetoden</em> for dette formålet. (Se C&amp;K <a href="#cheney1999numerical">[7]</a>, avsnitt 3.3) 
Iterasjonsprosessen vist i Figure <a href="#fig:29">fig:29</a>  starter med at vi tipper to verdier \( s^0 \) og \( s^1 \)  og legger en sekant gjennom \( \phi (s^0) \) og 
\( \phi (s^1) \). Skjæringspunktet med s-aksen, \( s^{(2)} \), kan da beregnes.

<p>
For en vilkårlig iterasjon \( m \):

$$
\begin{equation}
s^{m+1}=s^m+\delta s
\label{eq:2205}
\end{equation}
$$

<p>
der

$$
\begin{equation*}
\delta s=s^{m+1}-s^m=-\phi (s^m)\cdot \left[ \frac{s^m-s^{m-1}}{\phi (s^m)-\phi (s^{m-1})} \right],\ m=1,2,\dots
\end{equation*}
$$

<p>
<!-- FIGURE:[fig-ch2/fig9, width=250] <div id="fig:29"></div> -->

<p>
Iterasjonsprosessen blir da som følger når \( \phi (s^{m-1}) \) og \( s^m \)  antas kjent:

<ol>
 <li> Beregn \( \phi (s^{m-1}) \) og \( \phi (s^m) \)  ved å løse \eqref{eq:2203a} sammen med \eqref{eq:2204a}.</li>
 <li> Beregn  \( \delta s \) og \( s^{m+1} \)   fra \eqref{eq:2205}</li>
 <li> Sett</li>

<ul>
     <li> \( s^{m-1}\gets s^m \)</li>
     <li> \( s^m \gets s^{m+1} \)</li> 
     <li> \( \phi (s^{m-1}) \gets \phi (s^m) \)
<!--  -->
<!-- bt -->
<!-- begin{equation*} -->
<!-- text{Sett } -->
<!-- begin{cases} -->
<!-- s^{m-1}\gets s^m \\ -->
<!-- s^m \gets s^{m+1} \\ -->
<!-- phi (s^{m-1}) \gets \phi (s^m) -->
<!-- end{cases} -->
<!-- end{equation*} -->
<!-- et -->
<!--  --></li>
</ul>

</ol>

Gjenta skritt 1–3 inntil  vi har fått konvergens.

<p>
Eksempel på konvergenskriterier :

<p>
Kontroll av absolutt feil:

$$
\begin{equation}
|\delta s|  < \varepsilon_1
\label{eq:2206a}
\end{equation}
$$

<p>
Kontroll av relativ feil:

$$
\begin{equation}
\left| \frac{\delta s}{s^{m+1}}\right| < \varepsilon_2
\label{eq:2206b}
\end{equation}
$$

<p>
\eqref{eq:2206a} og \eqref{eq:2206b} kombineres ofte med:

$$
\begin{equation}
|\phi (s^{m+1})| < \varepsilon_3
\label{eq:2206c}
\end{equation}
$$

<p>
<br />

<p>
Vi bruker nå den foreskrevne prosessen til å løse \eqref{eq:2203a}. Velger startverdier \( s^0=-3.0 \) og \( s^1=-6.0 \). 
Figure <a href="#fig:28">20</a> viser at vi sannsynligvis vil finne løsningen \( y_1 \)  med disse startverdiene. Velger \( \Delta x=0.1 \)  og 
bruker RK4. Får følgende tabell:

<p>

<div class="row">
  <div class="col-xs-11">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( m \)</td> <td align="center">\( s^{m-1} \)</td> <td align="center">\( \phi (s^{m-1}) \)</td> <td align="center">\( s^m \)</td> <td align="center">\( \phi (s^m) \)</td> <td align="center">\( s^{m+1} \)</td> <td align="center">\( \phi (s^{m+1}) \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   1          </td> <td align="center">   -3.0             </td> <td align="center">   26.8131                 </td> <td align="center">   -6.0         </td> <td align="center">   6.2161              </td> <td align="center">   -6.9054          </td> <td align="center">   2.9395                  </td> </tr>
<tr><td align="center">   2          </td> <td align="center">   -6.0             </td> <td align="center">   6.2161                  </td> <td align="center">   -6.9054      </td> <td align="center">   2.9395              </td> <td align="center">   -7.7177          </td> <td align="center">   0.6697                  </td> </tr>
<tr><td align="center">   3          </td> <td align="center">   -6.9054          </td> <td align="center">   2.9395                  </td> <td align="center">   -7.7177      </td> <td align="center">   0.6697              </td> <td align="center">   -7.9574          </td> <td align="center">   0.09875                 </td> </tr>
<tr><td align="center">   4          </td> <td align="center">   -7.7177          </td> <td align="center">   0.6697                  </td> <td align="center">   -7.9574      </td> <td align="center">   0.09875             </td> <td align="center">   -7.9989          </td> <td align="center">   0.0004                  </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-11 -->
<p>
Etter fire iterasjoner er \( s=y'(0)= -7.9989 \) , mens den analytiske verdien er \( -8.0 \).
Programmet \( non\_lin\_ode.py \) viser hvordan problemet kan løses, og sammeligner grafisk den numeriske løsningen med den analytiske.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter2/src-ch2/non_lin_ode.py;ODEschemes.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter2/src-ch2/ODEschemes.py;</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">ODEschemes</span> <span style="color: #008000; font-weight: bold">import</span> euler, heun, rk4
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> cos, sin
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #408080; font-style: italic"># change some default values to make plots more readable </span>
LNWDT<span style="color: #666666">=3</span>; FNT<span style="color: #666666">=11</span>
rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}; rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)


N<span style="color: #666666">=40</span>
L <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>,L,N<span style="color: #666666">+1</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">dsfunction</span>(phi0,phi1,s0,s1):
    <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">abs</span>(phi1<span style="color: #666666">-</span>phi0)<span style="color: #666666">&gt;0.0</span>):   
        <span style="color: #008000; font-weight: bold">return</span>    <span style="color: #666666">-</span>phi1 <span style="color: #666666">*</span>(s1 <span style="color: #666666">-</span> s0)<span style="color: #666666">/</span><span style="color: #008000">float</span>(phi1 <span style="color: #666666">-</span> phi0)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.0</span>


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>],<span style="color: #666666">3.0*</span>z[<span style="color: #666666">0</span>]<span style="color: #666666">**2/2.0</span>]
    <span style="color: #008000; font-weight: bold">return</span> zout 


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">y_analytical</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">4.0/</span>(<span style="color: #666666">1.0+</span>x)<span style="color: #666666">**2</span>
  

beta<span style="color: #666666">=1.0</span> <span style="color: #408080; font-style: italic"># Boundary value at x = L</span>

solvers <span style="color: #666666">=</span> [euler, heun, rk4] <span style="color: #408080; font-style: italic">#list of solvers</span>
solver<span style="color: #666666">=</span>solvers[<span style="color: #666666">2</span>] <span style="color: #408080; font-style: italic"># select specific solver</span>

<span style="color: #408080; font-style: italic"># Guessed values</span>
s<span style="color: #666666">=</span>[<span style="color: #666666">-34.0</span>,<span style="color: #666666">-20</span>]

z0<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #666666">2</span>)
z0[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">4.0</span>
z0[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> s[<span style="color: #666666">0</span>]

z <span style="color: #666666">=</span> solver(f,z0,x)
phi0 <span style="color: #666666">=</span> z[<span style="color: #666666">-1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">-</span> beta

nmax<span style="color: #666666">=10</span>
eps <span style="color: #666666">=</span> <span style="color: #666666">1.0e-3</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(nmax):
    z0[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> s[<span style="color: #666666">1</span>]
    z <span style="color: #666666">=</span> solver(f,z0,x)
    phi1 <span style="color: #666666">=</span> z[<span style="color: #666666">-1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">-</span> beta
    ds <span style="color: #666666">=</span> dsfunction(phi0,phi1,s[<span style="color: #666666">0</span>],s[<span style="color: #666666">1</span>])
    s[<span style="color: #666666">0</span>]  <span style="color: #666666">=</span> s[<span style="color: #666666">1</span>]
    s[<span style="color: #666666">1</span>] <span style="color: #666666">+=</span>  ds
    phi0 <span style="color: #666666">=</span> phi1
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;n = {}  s1 = {} and ds = {}&#39;</span><span style="color: #666666">.</span>format(n,s[<span style="color: #666666">1</span>],ds)
    
    <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">abs</span>(ds)<span style="color: #666666">&lt;=</span>eps):
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Solution converged for eps = {} and s1 ={} and ds = {}. </span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span><span style="color: #666666">.</span>format(eps,s[<span style="color: #666666">1</span>],ds)
        <span style="color: #008000; font-weight: bold">break</span>

legends<span style="color: #666666">=</span>[] <span style="color: #408080; font-style: italic"># empty list to append legends as plots are generated</span>

plot(x,z[:,<span style="color: #666666">0</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;y&#39;</span>)

plot(x,y_analytical(x),<span style="color: #BA2121">&#39;:^&#39;</span>)
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;y analytical&#39;</span>)

<span style="color: #408080; font-style: italic"># Add the labels</span>
legend(legends,loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>,frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>) <span style="color: #408080; font-style: italic"># Add the legends</span>
ylabel(<span style="color: #BA2121">&#39;y&#39;</span>)
xlabel(<span style="color: #BA2121">&#39;x/L&#39;</span>)
show()
</pre></div>
<p>
Sekantmetoden er enkel og effektiv. Vi slipper dessuten å finne det analytiske uttrykket(ene) for den(de) deriverte som i 
Newton-Raphsons metode. Bakdelen er at vi må ha to startverdier for å komme igang. Med kjennskap til fysikken i problemet, er dette 
vanligvis en overkommelig vanskelighet.

<p>
<!-- !split -->

<h2 id="ex:24">Example: Stor nedbøyning av kragbjelke</h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 21:  <div id="fig:210"></div> </p></center>
<p><img src="fig-ch2/fig10.png" align="bottom" ></p>
</center>

<p>
Figure <a href="#fig:210">21</a> viser en kragbjelke som er fast innspent ved \( A \) og påkjent av en vertikal last \( P \) på enden \( B \). Vi vil tillate store 
nedbøyninger og bruker derfor buelengden \( l \) og helningsvinkelen \( \theta \) som variable. Alle lengder er gjort dimensjonsløse ved divisjon 
med bjelkelengden \( L \). Buelengden \( l \) går derfor fra \( l=0 \)  i \( A \) til \( l=1 \)  i \( B \). Differensialligningen for den elastiske linja er gitt ved:

$$
\begin{equation}
\kappa=\frac{d\theta}{L\cdot dl}=\frac{M}{EI}
\label{eq:e12201}
\end{equation}
$$

<p>
der \( \kappa \)  er krumningen, \( M \) er momentet og \( EI \) bjelkestivheten.
Tar momentet om \( C \): \( M=P \cdot L(l_h-x) \)  som innsatt i \eqref{eq:e12201} gir:

$$
\begin{equation}
\frac{d\theta}{dl}=\frac{PL^2}{EI}(l_h-x)
\label{eq:e12202}
\end{equation}
$$

<p>
Fra figuren finner vi følgende geometriske relasjoner:

$$
\begin{equation}
\frac{dx}{dl}=\cos \theta,\ \frac{dy}{dl}=\sin \theta
\label{eq:e12203}
\end{equation}
$$

<p>
Deriverer  \eqref{eq:e12202} m.h.p. l og setter inn fra \eqref{eq:e12203}:

$$
\begin{equation}
\frac{d^2\theta}{dl^2}+\frac{PL^2}{EI}\cos \theta =0
\label{eq:e12204}
\end{equation}
$$

<p>
Innfører parameteren \( \alpha \)  definert ved:

$$
\begin{equation}
\alpha^2=\frac{PL^2}{EI}
\label{eq:e12205}
\end{equation}
$$

<p>
Vi må da løse følgende differensialligninger:

$$
\begin{equation}
\frac{d^2\theta}{dl^2}+\alpha^2\cos \theta =0
\label{eq:e12206a}
\end{equation}
$$


$$
\begin{equation}
\frac{dy}{dl}=\sin \theta
\label{eq:e12206b}
\end{equation}
$$

<p>
med følgende randbetingelser:

$$
\begin{equation}
y(0)=0,\ \theta (0)=0,\ \frac{d\theta}{dl}(1)=0
\label{eq:e12206c}
\end{equation}
$$

<p>
<br />

<p>
De to første randbetingelsene betyr at bjelken er fast innspent i \( A \), mens den siste betyr at momentet forsvinner i \( B \).
Den analytiske løsningen av dette problemet er gitt i appendiks G, del G.3 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>.

<p>
<br />

<p>
<b>Numerisk løsning</b>

<p>
Skriver \eqref{eq:e12206a} og \eqref{eq:e12206b} som et system av første ordens ligninger.
Med \( \theta=z_1,\ \theta'=z_2 \) og \( y=z_3 \)  får vi:

$$
\begin{align}
&z_1'=z_2 
\label{_auto22}\\ 
&z_2'=-\alpha^2\cos z_1 \label{eq:e12207a} \\ 
&z_3'=\sin z_1
\label{_auto23}
\end{align}
$$

<p>
Randbetingelser:

$$
\begin{equation}
z_1(0)=0,\ z_2(1)=0,\ z_3(0)=0
\label{eq:e12207b}
\end{equation}
$$

<p>
<br />

<p>
Vi må tippe \( \theta'(0) \)  slik at betingelsen \( \frac{d\theta}{dl}(1)=0 \)  blir oppfylt.
Setter \( s=\theta'(0) \)  og \( \phi (s)=\theta'(1;s) \). Må da bestemme \( s=s^* \)   slik at \( \phi (s^*)=0 \).
eller med z-variable: \( s=z_2(0) \). Bestem \( s=s^* \)  slik at \( \phi (s^*)=z_2(1;s^*)=0 \)
Dessuten finner vi:

$$
\begin{equation}
l_h=\frac{s^*}{\alpha^2}
\label{eq:e12208}
\end{equation}
$$

<p>
Bruker sekantmetoden og må da bestemme startverdier \( s^0 \) og \( s^1 \)  for å starte iterasjonsprosessen. Dette gjøres ved å fremstille 
funksjonen \( \phi (s) \) grafisk. Dette kan gjøres med f.eks Python- programmet \( phi\_plot\_beam\_deflect\_shoot \) , som resulterer i Figure <a href="#fig:211">22</a>.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter2/src-ch2/phi_plot_beam_shoot.py;ODEschemes.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter2/src-ch2/ODEschemes.py;</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">ODEschemes</span> <span style="color: #008000; font-weight: bold">import</span> euler, heun, rk4
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> cos, sin
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #408080; font-style: italic"># change some default values to make plots more readable </span>
LNWDT<span style="color: #666666">=3</span>; FNT<span style="color: #666666">=11</span>
rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}; rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)


N<span style="color: #666666">=20</span>
L <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>,L,N<span style="color: #666666">+1</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;RHS for deflection of beam&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>],<span style="color: #666666">-</span>alpha2<span style="color: #666666">*</span>cos(z[<span style="color: #666666">0</span>]),sin(z[<span style="color: #666666">0</span>])]
    <span style="color: #008000; font-weight: bold">return</span> zout 

solvers <span style="color: #666666">=</span> [euler, heun, rk4] <span style="color: #408080; font-style: italic">#list of solvers</span>
solver<span style="color: #666666">=</span>solvers[<span style="color: #666666">2</span>] <span style="color: #408080; font-style: italic"># select specific solver</span>

alpha2 <span style="color: #666666">=</span> <span style="color: #666666">5.0</span> 
beta<span style="color: #666666">=0.0</span> <span style="color: #408080; font-style: italic"># Boundary value at y = L</span>

N_guess <span style="color: #666666">=</span> <span style="color: #666666">30</span>
s_guesses<span style="color: #666666">=</span>np<span style="color: #666666">.</span>linspace(<span style="color: #666666">1</span>,<span style="color: #666666">5</span>,N_guess)

z0<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #666666">3</span>)

phi <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> s_guess <span style="color: #AA22FF; font-weight: bold">in</span> s_guesses:
    z0[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> s_guess
    z <span style="color: #666666">=</span> solver(f,z0,y)
    phi<span style="color: #666666">.</span>append(z[<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>] <span style="color: #666666">-</span> beta)

legends<span style="color: #666666">=</span>[] <span style="color: #408080; font-style: italic"># empty list to append legends as plots are generated</span>
plot(s_guesses,phi)

<span style="color: #408080; font-style: italic"># Add the labels</span>
legend(legends,loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>,frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>) <span style="color: #408080; font-style: italic"># Add the legends</span>
title(<span style="color: #BA2121">&#39;alpha2 = &#39;</span> <span style="color: #666666">+</span> <span style="color: #008000">str</span>(alpha2))
ylabel(<span style="color: #BA2121">&#39;phi&#39;</span>)
xlabel(<span style="color: #BA2121">&#39;s&#39;</span>)
grid(b<span style="color: #666666">=</span><span style="color: #008000">True</span>, which<span style="color: #666666">=</span><span style="color: #BA2121">&#39;both&#39;</span>)
show()
</pre></div>
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 22:  Plot av funksjonen \( \phi(s) \) for \( \alpha^2 =5 \) for identifikasjon av nullpunkt <div id="fig:211"></div> </p></center>
<p><img src="fig-ch2/fig11.png" align="bottom" width=400></p>
</center>

<p>
Vi ser av figuren at vi har et nullpunkt \( s^*\approx3.05 \). Merk at vi vil få forskjellige
nullpunkt når \( \alpha \)  forandres. Figure <a href="#fig:212">23</a> viser endenedbøyningen \( \delta \)  og horisontallengden \( l_h \) som funksjon 
av \( \alpha^2 \). Figuren er beregnet med Python-programmet \( beam\_deflect\_shoot \).

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter2/src-ch2/beam_deflect_shoot.py;ODEschemes.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter2/src-ch2/ODEschemes.py;</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">ODEschemes</span> <span style="color: #008000; font-weight: bold">import</span> euler, heun, rk4
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> cos, sin
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #408080; font-style: italic"># change some default values to make plots more readable </span>
LNWDT<span style="color: #666666">=3</span>; FNT<span style="color: #666666">=11</span>
rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT
font <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;size&#39;</span> : <span style="color: #666666">16</span>}; rc(<span style="color: #BA2121">&#39;font&#39;</span>, <span style="color: #666666">**</span>font)


N<span style="color: #666666">=20</span>
L <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>,L,N<span style="color: #666666">+1</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">dsfunction</span>(phi0,phi1,s0,s1):
    <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">abs</span>(phi1<span style="color: #666666">-</span>phi0)<span style="color: #666666">&gt;0.0</span>):   
        <span style="color: #008000; font-weight: bold">return</span>    <span style="color: #666666">-</span>phi1 <span style="color: #666666">*</span>(s1 <span style="color: #666666">-</span> s0)<span style="color: #666666">/</span><span style="color: #008000">float</span>(phi1 <span style="color: #666666">-</span> phi0)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.0</span>


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(z, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;RHS for deflection of beam&quot;&quot;&quot;</span>
    zout <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(z)
    zout[:] <span style="color: #666666">=</span> [z[<span style="color: #666666">1</span>],<span style="color: #666666">-</span>alpha2<span style="color: #666666">*</span>cos(z[<span style="color: #666666">0</span>]),sin(z[<span style="color: #666666">0</span>])]
    <span style="color: #008000; font-weight: bold">return</span> zout 

alpha2 <span style="color: #666666">=</span> <span style="color: #666666">5.0</span> 
beta<span style="color: #666666">=0.0</span> <span style="color: #408080; font-style: italic"># Boundary value at y = L</span>

solvers <span style="color: #666666">=</span> [euler, heun, rk4] <span style="color: #408080; font-style: italic">#list of solvers</span>
solver<span style="color: #666666">=</span>solvers[<span style="color: #666666">2</span>] <span style="color: #408080; font-style: italic"># select specific solver</span>

<span style="color: #408080; font-style: italic"># Guessed values</span>
s<span style="color: #666666">=</span>[<span style="color: #666666">2.5</span>, <span style="color: #666666">5.0</span>]

z0<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #666666">3</span>)

z0[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> s[<span style="color: #666666">0</span>]
z <span style="color: #666666">=</span> solver(f,z0,y)
phi0 <span style="color: #666666">=</span> z[<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>] <span style="color: #666666">-</span> beta

nmax<span style="color: #666666">=10</span>
eps <span style="color: #666666">=</span> <span style="color: #666666">1.0e-10</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(nmax):
    z0[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> s[<span style="color: #666666">1</span>]
    z <span style="color: #666666">=</span> solver(f,z0,y)
    phi1 <span style="color: #666666">=</span> z[<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>] <span style="color: #666666">-</span> beta
    ds <span style="color: #666666">=</span> dsfunction(phi0,phi1,s[<span style="color: #666666">0</span>],s[<span style="color: #666666">1</span>])
    s[<span style="color: #666666">0</span>]  <span style="color: #666666">=</span> s[<span style="color: #666666">1</span>]
    s[<span style="color: #666666">1</span>] <span style="color: #666666">+=</span>  ds
    phi0 <span style="color: #666666">=</span> phi1
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;n = {}  s1 = {} and ds = {}&#39;</span><span style="color: #666666">.</span>format(n,s[<span style="color: #666666">1</span>],ds)
    
    <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">abs</span>(ds)<span style="color: #666666">&lt;=</span>eps):
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Solution converged for eps = {} and s1 ={} and ds = {}. </span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span><span style="color: #666666">.</span>format(eps,s[<span style="color: #666666">1</span>],ds)
        <span style="color: #008000; font-weight: bold">break</span>

legends<span style="color: #666666">=</span>[] <span style="color: #408080; font-style: italic"># empty list to append legends as plots are generated</span>

plot(y,z[:,<span style="color: #666666">0</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;theta&#39;</span>)

plot(y,z[:,<span style="color: #666666">1</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;dtheta/dl&#39;</span>)

plot(y,z[:,<span style="color: #666666">2</span>])
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;deflection y&#39;</span>)



<span style="color: #408080; font-style: italic"># Add the labels</span>
legend(legends,loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>,frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>) <span style="color: #408080; font-style: italic"># Add the legends</span>
ylabel(<span style="color: #BA2121">&#39;theta theta&#39;</span>)
xlabel(<span style="color: #BA2121">&#39;y/L&#39;</span>)
<span style="color: #408080; font-style: italic">#grid(b=True, which=&#39;both&#39;, axis=&#39;both&#39;,linestyle=&#39;-&#39;)</span>
grid(b<span style="color: #666666">=</span><span style="color: #008000">True</span>, which<span style="color: #666666">=</span><span style="color: #BA2121">&#39;both&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;0.65&#39;</span>,linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;-&#39;</span>)

show()
</pre></div>
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 23:  Bjelke med stor nedbøying (\( \delta \)) og endring i horisontal lengde (\( l_h \)) <div id="fig:212"></div> </p></center>
<p><img src="fig-ch2/fig12.png" align="bottom" width=400></p>
</center>

<p>
<!-- !split -->

<h1 id="ch2:sec3">Litt om likedannhetsløsninger</h1>

<p>
Den endimensjonale, ikke-stasjonære varmeledningsligningen er gitt ved:

$$
\begin{equation}
\frac{\partial T}{\partial \tau}=\alpha \frac{\partial^2 T}{\partial X^2} 
\label{eq:2301}
\end{equation}
$$

<p>
der \( \tau \) er tiden, \( T=T(X,\tau) \)   og \( \alpha \)  den termiske diffusiviteten. (Se appendiks B i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a> for 
utledning)

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 24:  <div id="fig:213"></div> </p></center>
<p><img src="fig-ch2/fig13.png" align="bottom" width=300,></p>
</center>

<p>
Figure <a href="#fig:213">24</a> viser en stav med halvuendelig utstrekning der \( 0\leq X < \infty \). Opprinnelig har staven en temperatur \( T_s \), men ved tiden \( \tau=0 \)  
forandres  temperaturen på enden \( X=0 \)  til \( T_0 \)   og holdes deretter konstant. Vi ønsker å beregne temperaturfordelingen i staven som funksjon av 
tiden \( \tau \).

<p>
Problemet kan beskrives matematisk på følgende måte:

<p>
Initialbetingelse:

$$
\begin{equation}
T(X,\tau)=T_s,\ \tau < 0
\label{eq:2302a}
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{equation}
T(0,\tau)=T_0,\ T(\infty,\tau)=T_s
\label{eq:2302b}
\end{equation}
$$

<p>
<br />

<p>
La oss skalere \eqref{eq:2301} ved å innføre følgende dimensjonsløse variable:

$$
\begin{equation}
u=\frac{T-T_0}{T_s-T_0},\ x=\frac{X}{L},\ t=\frac{\tau \cdot \alpha}{L^2}
\label{eq:2303}
\end{equation}
$$

<p>
der  \( L \)  er en karakteristisk lengde. 
\eqref{eq:2303} innsatt i \eqref{eq:2301} gir følgende ligning:

$$
\begin{equation}
\frac{\partial u}{\partial t}=\frac{\partial^2 u}{\partial x^2},\ 0 < x < \infty
\label{eq:2304}
\end{equation}
$$

<p>
Initialbetingelse:

$$
\begin{equation}
u(x,t)=1,\ t < 0
\label{eq:2305a}
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{equation}
u(0,t)=0,\ u(\infty,t)=1
\label{eq:2305b}
\end{equation}
$$

<p>
<br />

<p>
Det spesielle valget av \( t \) i \eqref{eq:2303} er gjort for å fjerne koeffisienten foran det siste leddet i ligningen. Vi har dermed fått redusert antall 
variable. Det finnes mange  analytiske løsninger av  diffusjonsligningen på formen gitt i \eqref{eq:2304}. Disse løsningene kan derfor brukes på en hel 
rekke problemer fra forskjellige anvendelsesområder. Den dimensjonsløse tiden gitt i \eqref{eq:2303} er en dimensjonsløs gruppe som kalles Fourier-tallet 
og skrives vanligvis Fo. Vi vil nå forsøke å transformere \eqref{eq:2304} og \eqref{eq:2305a} fra en partiell til en ordinær differensialligning.

<p>
Setter:

$$
\begin{equation}
\bar{x}=a\cdot x \ \text{og} \ \bar{t}=b\cdot t
\label{eq:2306}
\end{equation}
$$

<p>
der \( a \) og \( b \) er positive konstanter.

<p>
\eqref{eq:2306} innført i \eqref{eq:2304} gir følgende ligning:

$$
\begin{equation}
\frac{\partial u}{\partial \bar{t}}=\frac{a^2}{b}\frac{\partial^2u}{\partial \bar{x}^2}
\label{eq:2307}
\end{equation}
$$

<p>
Velger \( b=a^2 \)  slik at \eqref{eq:2307} og \eqref{eq:2304} er identiske med samme randbetingelser:

$$
\begin{equation}
u(x,t)=u(\bar{x},\bar{t})=u(ax,a^2t),\ \text{med} \ b=a^2
\label{eq:2308}
\end{equation}
$$

<p>
Dersom \eqref{eq:2308} skal være uavhengig av \( a > 0 \), må \( u(x,t) \) skrives på formen

$$
\begin{equation}
u(x,t)=f\left( \frac{x}{\sqrt{t}}\right),\ g\left( \frac{x^2}{t}\right),\ \text{osv.} 
\label{eq:2309}
\end{equation}
$$

<p>
Velger det første alternativet:

$$
\begin{equation}
u(x,t)=f\left( \frac{x}{\sqrt{t}}\right)
\label{eq:23010}
\end{equation}
$$

<p>
Innfører følgelig en ny variabel \( \eta \) definert ved:

$$
\begin{equation}
\eta=\frac{x}{2 \sqrt{t}}
\label{eq:23011}
\end{equation}
$$

<p>
der faktoren \( 2 \) er innført bare for å få et penere sluttresultat.

<p>
Transformasjonen gitt i  \eqref{eq:23011} reduserer den opprinnelige ligningen fra å være avhengig både av \( x \) og \( t \)  til bare å avhenge av en variabel
\( \eta \). Som funksjon av \( \eta \), vil ett og samme \( u \)-profil gi løsningen for alle  \( x \) og \( t \). \( u(\eta) \)  kalles derfor en likedannhetsløsning og 
\eqref{eq:23011} en likedannhets-transformasjon. (Engelsk: similarity transformation). Transformasjonen i  \eqref{eq:23011} kalles ofte 
Boltzmann-transformasjonen.

<p>
Problemet som opprinnelig ble beskrevet av en partiell differensialligning, beskrives nå av en ordinær differensialligning.

<p>
Har da fått følgende variable:

$$
\begin{equation}
t=\frac{\tau\cdot\alpha}{L^2},\ \eta=\frac{x}{2 \sqrt{t}}=\frac{X}{2 \sqrt{\tau\alpha}}
\label{eq:23012}
\end{equation}
$$

<p>
La oss nå løse  \eqref{eq:2304} analytisk.

<p>
Innfører

$$
\begin{equation}
u=f(\eta)
\label{eq:23013a}
\end{equation}
$$

<p>
med randbetingelsene:

$$
\begin{equation}
f(0)=0,\ f(\infty)=1
\label{eq:23013b}
\end{equation}
$$

<p>
<br />

$$
\begin{align*}
&\frac{\partial u}{\partial t}=\frac{\partial u}{\partial\eta}\left( \frac{\partial n}{\partial t}\right)=f'(\eta)\cdot\left( -\frac{y}{4t\sqrt{t}}\right)=-f'(\eta)\frac{\eta}{2t} \\ 
&\frac{\partial u}{\partial x}=\frac{\partial u}{\partial\eta}\left( \frac{\partial\eta}{\partial x}\right)=f'(\eta)\frac{1}{2\sqrt{t}},\ \frac{\partial^2u}{\partial x^2}=\frac{\partial}{\partial x}\left( f'(\eta)\frac{1}{2\sqrt{t}}\right)=f''(\eta)\frac{1}{4t}
\end{align*}
$$

<p>
Innsatt for \( \dfrac{\partial u}{\partial t} \) og \( \dfrac{\partial^2u}{\partial x^2} \) i \eqref{eq:2304}:

$$
\begin{equation}
f''(\eta)\frac{1}{4t}+f'(\eta)\frac{\eta}{2t}=0 \to f''(\eta)+2\eta f'(\eta)=0
\label{eq:23014}
\end{equation}
$$

<p>
\eqref{eq:23014} kan løses ved direkte integrasjon:

$$
\begin{equation*}
\frac{f''(\eta)}{f'(\eta)}=-2\eta\to \ln f'(\eta)=-\eta^2+\ln C_1
\end{equation*}
$$

<p>
Som gir

$$
\begin{equation*}
f'(\eta)=C_1e^{-\eta^2}
\end{equation*}
$$

<p>
Ny integrasjon:

$$
\begin{equation*}
f(\eta)=C_1 \int_0^\eta e^{-t^2}dt
\end{equation*}
$$

<p>
hvor vi har benyttet randbetingelsen \( f(0)=0 \)  fra \eqref{eq:23013b}.

<p>
Fra integraltabell:

$$
\begin{equation*}
\int_0^x e^{-t^2}dt=\frac{\sqrt{\pi}}{2} \text{erf(x)}
\end{equation*}
$$

<p>
der feilfunksjonen erf(x) er definert ved:

$$
\begin{equation}
\frac{2}{\sqrt{\pi}}\int_0^x e^{-t^2}dt
\label{eq:23015}
\end{equation}
$$

<p>
Dette gir:

$$
\begin{equation}
f(\eta)=C_1\frac{\sqrt{\pi}}{2}\text{erf}(\eta )
\label{eq:23016}
\end{equation}
$$

<p>
\( \text{erf(x)} \to1 \) for \( x\to\infty \)   gir: \( C_1=\dfrac{2}{\sqrt{\pi}} \)    og videre innsatt i  \eqref{eq:23016}:

$$
\begin{equation}
u(x,t)=\text{erf} (\eta)=\text{erf} \left(\frac{x}{2\sqrt{t}}\right)
\label{eq:23017}
\end{equation}
$$

<p>
Dersom vi ønsker \( u(x,t) \) uttrykt i de opprinnelige variable, får vi fra \eqref{eq:2303}:

$$
\begin{equation}
\frac{T(X,\tau)-T_0}{T_s-T_0}=\text{erf} \left(\frac{X}{2\sqrt{\tau\cdot\alpha}}\right)
\label{eq:23018}
\end{equation}
$$

<p>
Noen tabellverdier  for \( \text{erf} (x) \) er vist under:

<p>

<div class="row">
  <div class="col-xs-6">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( x \)</td> <td align="center">\( \text{erf}(x) \)</td> <td align="center">\( x \)</td> <td align="center">\( \text{erf} (x) \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   0.00       </td> <td align="center">   0.00000                </td> <td align="center">   1.00       </td> <td align="center">   0.84270                 </td> </tr>
<tr><td align="center">   0.20       </td> <td align="center">   0.22270                </td> <td align="center">   1.20       </td> <td align="center">   0.91031                 </td> </tr>
<tr><td align="center">   0.40       </td> <td align="center">   0.42839                </td> <td align="center">   1.40       </td> <td align="center">   0.95229                 </td> </tr>
<tr><td align="center">   0.60       </td> <td align="center">   0.60386                </td> <td align="center">   1.60       </td> <td align="center">   0.97635                 </td> </tr>
<tr><td align="center">   0.80       </td> <td align="center">   0.74210                </td> <td align="center">   1.80       </td> <td align="center">   0.98909                 </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-6 -->
<p>
Figure <a href="#fig:214">25</a> nedenfor viser feilfunksjonen \( \text{erf}(x) \) samt den komplementære feilfunksjonen \( \text{erfc}(x) \) som er definert ved:

$$
\begin{equation}
\text{erfc}(x)=1-\text{erf}(x)=\frac{2}{\sqrt{\pi}}\int_x^\infty e^{-t^2}dt
\label{eq:23019}
\end{equation}
$$

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 25:  <div id="fig:214"></div> </p></center>
<p><img src="fig-ch2/fig14.png" align="bottom" width=400></p>
</center>

<p>
<!-- !split -->

<h2 id="ex:25">Example: Frysing i vannledning</h2>

<p>
Et tørt jordlag med opprinnelig temperatur \( 20 ^{\circ} C \),  blir i en kuldeperiode
utsatt for en overflatetemperatur på \( -15 ^{\circ} C \) i  30 døgn.
Hvor dypt må vi legge en vannledning for å unngå at den fryser ?
Den termiske diffusiviteten \( \alpha = 5 \cdot 10^{-4} \text{m}^2/ \text{time} \).

<p>
Med henvisning til \eqref{eq:2302a} blir \( T_0=-15 ^{\circ} C \) og \( T_s=20 ^{\circ} C \). 
\( \tau=30 \) døgn \( =720 \) timer. Vannet fryser ved  \( 0 ^{\circ} C \).

<p>
Fra \eqref{eq:2303}:

$$
\begin{equation*}
u=\frac{T-T_0}{T_s-T_0} =\frac{0-(-15)}{20-(-15)} =\frac{3}{7} =0.4286
\end{equation*}
$$

<p>
Fra tabellverdi for erf(x) og \eqref{eq:23017} finner vi \( \text{erf} (\eta)=0.4286\to \eta \approx 0.4 \)  som med  \eqref{eq:23012} gir:

$$
\begin{equation*}
X=0.4\cdot2\sqrt{\tau\cdot\alpha}=0.8\cdot\sqrt{720\cdot5\cdot10^{-4}}=0.48 \text{m} 
\end{equation*}
$$

<p>
Vi har regnet med konstant diffusivitet \( \alpha \), mens den kan variere i intervallet \( \alpha \in[3\cdot 10^{-4},\ 10^{-3}] \text{m}^2/ \text{time} \).
Dessuten vil jorda normalt ikke være tørr.

<h2 id="ex:26">Example: Stokes 1. problem</h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 26:  <div id="fig:215"></div> </p></center>
<p><img src="fig-ch2/fig15transp_stoke1.png" align="bottom" width=500></p>
</center>

<p>
Vi har en stillestående fluid ved \( \tau < 0  \)  . Ved tiden \( \tau=0 \)  får plata som er parallell med X-aksen, en konstant hastighet 
\( U=U_0 \) parallelt med X-aksen. Plata må betraktes som uendelig tynn med uendelig utstrekning i X-retning for en korrekt matematisk beskrivelse 
i dette tilfellet.  Navier-Stokes ligning i X-retning for inkompressibel strømning:

$$
\begin{equation*}
\frac{\partial U}{\partial\tau}+U \frac{\partial U}{\partial X}+V \frac{\partial U}{\partial Y}=-\frac{1}{\rho}\frac{\partial p}{\partial X}+ \nu\left(\frac{\partial^2 U}{\partial X^2}+\frac{\partial^2U}{\partial Y^2}\right)
\end{equation*}
$$

<p>
(Se utledning i appendiks B  i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>)

<p>
Antar at løsningen av dette problemet er uavhengig av \( X \), samt at \( V=0 \)  som betyr  at \( U=U(Y,\tau) \):

$$
\begin{equation}
\frac{\partial U}{\partial\tau}=\nu \frac{\partial^2U}{\partial Y^2},\ 0 < Y < \infty
\label{eq:23020}
\end{equation}
$$

<p>
Initialbetingelse:

$$
\begin{equation}
U(U,0)=0
\label{eq:23021a}
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{equation} \label{eq:23021b}
\left.\begin{matrix}
&U(0,\tau)=U_0 \ \text{(heftbet.)} \\ 
&U(\infty,\tau)=0
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Innfører  følgende dimensjonsløse variable:

$$
\begin{equation}
u=\frac{U}{U_0},\ y=\frac{Y}{L},\ t=\frac{\tau\cdot\nu}{L^2}
\label{eq:23022}
\end{equation}
$$

<p>
der \( U_0 \) og \( L \)  er henholdsvis en karakteristisk hastighet og lengde. \eqref{eq:23022} innsatt i \eqref{eq:23020} gir følgende ligning:

$$
\begin{equation}
\frac{\partial u}{\partial t}=\frac{\partial^2u}{\partial y^2},\ 0 < y < \infty
\label{eq:23023}
\end{equation}
$$

<p>
Initialbetingelse:

$$
\begin{equation}
u(y,0)=0
\label{eq:23024a}
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{equation} \label{eq:23024b}
\left.\begin{matrix}
&u(0,t)=1 \\ 
&u(\infty,t)=0
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Vi ser at vi har fått samme ligning og problem som i \eqref{eq:2304} og \eqref{eq:2305a}, bare med en ombytting av 0 og 1 i randbetingelsene. 
Løsningen av \eqref{eq:23023} og \eqref{eq:23024a} med randbetingelser \eqref{eq:23024b} blir:

$$
\begin{equation}
u(y,t)=1-\text{erf}(\eta)=\text{erfc}(\eta)=\text{erfc}\left( \frac{y}{2\sqrt{t}}\right)
\label{eq:23025}
\end{equation}
$$

<p>
eller uttrykt ved dimensjonelle variable:

$$
\begin{equation}
U(Y,\tau)=U_0\text{erfc} \left(\frac{Y}{2\sqrt{\tau\cdot\nu}}\right)
\label{eq:23026}
\end{equation}
$$

<p>
<!-- !split -->

<h2 id="ex:27">Example: Blasius-ligningen</h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 27:  <div id="fig:216"></div> </p></center>
<p><img src="fig-ch2/fig16transp_blasius.png" align="bottom" width=400></p>
</center>

<p>
En detaljert utledning er gitt i appendiks C, del C.2 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>. 
Gjengir noe av utledningen her for oversiktens skyld. For en stasjonær og inkompressibel grensesjikt-strømning, får vi fra lign. 
(C.1.10) i appendiks C i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>:

$$
\begin{equation}
\frac{\partial u}{\partial x}+\frac{\partial v}{\partial y}=0
\label{eq:23027}
\end{equation}
$$


$$
\begin{equation}
u \frac{\partial u}{\partial x}+v \frac{\partial u}{\partial y}=-\frac{1}{\rho}\frac{dp}{dx}+\nu\frac{\partial^2u}{\partial y^2}
\label{eq:23028}
\end{equation}
$$

<p>
Ser på det tilfellet at fristrømshastigheten \( U \) er konstant \( =U_0 \).
Bernoullis ligning (C.1.8) i appendiks C i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>
gir for dette tilfellet \( \frac{dp}{dx}=0 \).

<p>
\eqref{eq:23028} forenkler seg til:

$$
\begin{equation}
u \frac{\partial u}{\partial x}+v \frac{\partial u}{\partial y}=\nu\frac{\partial^2u}{\partial y^2}
\label{eq:23029}
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{align}
u(0)=0 \label{eq:23030a}\\ 
u\to U_0  \ & \text{for} \ y\to \delta
\label{eq:23030b}
\end{align}
$$

<p>
For å oppfylle kontinuitetsligningen \eqref{eq:23027}, innfører vi strømfunksjonen \( \psi(x,y) \)   definert ved:

$$
\begin{equation}
u=\frac{\partial\psi}{\partial y},\ v=-\frac{\partial \psi}{\partial x}
\label{eq:23031}
\end{equation}
$$

<p>
Vi definerer et Reynoldstall:

$$
\begin{equation}
Re_x=\frac{U_0x}{\nu}
\label{eq:23032}
\end{equation}
$$

<p>
Innfører følgende likedannhetsvariable for koordinat og strømfunksjon:

$$
\begin{equation}
\eta=\sqrt{ \frac{U_0}{2\nu x} }\cdot y \ \text{og} \ f(\eta)=\frac{\psi}{\sqrt{2U_o\nu x}}
\label{eq:23033}
\end{equation}
$$

<p>
Transformasjonen \eqref{eq:23033} gir Blasius-ligningen for strømfunksjonen \( f \):

$$
\begin{equation}
f'''(\eta)+ f(\eta)\cdot f''(\eta)=0
\label{eq:23034}
\end{equation}
$$

<p>
Notasjon: \( \frac{df}{d\eta}\equiv f'(\eta) \)   og tilsvarende for høyere deriverte. De fysikalske hastighetskomponentene er gitt ved:

$$
\begin{equation}
\frac{u}{U_0}=f'(\eta),\ \frac{v}{U_0}=\frac{\eta \cdot f'(\eta)-f(\eta)}{\sqrt{2Re_x}}
\label{eq:23035}
\end{equation}
$$

<p>
Heftbetingelsen \( u=0 \) for \( y=0 \)   blir nå \( f'(0)=0 \) da \( f'(\eta)=\frac{u}{U_0} \) fra \eqref{eq:23035}.

<p>
Uten suging eller blåsing gjennom randen \( \eta= 0 \), blir den andre heftbetingelsen \( v=0 \) for \( \eta=0 \). Fra \eqref{eq:23035} blir
denne betingelsen \( f(0)= 0 \). Betingelsen \( u\to U_0 \)  fra \eqref{eq:23030b}, blir nå \( f'(\eta)\to 1 \)  for \( \eta\to\infty \).
Randbetingelsene for ugjennomstrømmelig sjikt blir da:

$$
\begin{equation}
f(0)=f'(0)=0,\ f'(\eta_\infty)=1
\label{eq:23036}
\end{equation}
$$

<p>
Skjærspenningen:

$$
\begin{equation}
\tau_{xy}=\mu U_0\cdot f''(\eta)\sqrt{ \frac{U_0}{2\nu x}}
\label{eq:23037}
\end{equation}
$$

<p>
<br />

<p>
<b>Numerisk løsning </b>

<p>
Vi ønsker å løse \eqref{eq:23034} sammen med randbetingelsene i \eqref{eq:23036} ved bruk av skyteteknikk og skriver derfor ligningen 
som et sett av tre 1. ordens differensialligninger:

$$
\begin{align}
&f'=f_1 
\label{_auto24}\\ 
&f_1'=f_2 \label{eq:23038a}\\ 
&f_2'=-f\cdot f_2 
\label{_auto25}
\end{align}
$$

<p>
Randbetingelser: 

$$
\begin{equation} \label{eq:23038b}
\left.\begin{matrix}
&f(0)=f_1(0)=0 \\ 
&f_1(\eta_\infty)=1
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Setter  \( f''(0)=f_2(0)=s \)

<p>
\( s \), som i dette tilfellet er skjærspenningen ved veggen, må bestemmes slik at randbetingelsen \( f_1(\eta_\infty)=1 \) 
blir oppfylt. Dette siste kravet kan formuleres på følgende måte:

$$
\begin{equation}
\phi(s)=f_1(\eta_\infty;s)-1
\label{eq:23039}
\end{equation}
$$

<p>
med rett verdi \( s= s^* \) når \( \phi(s^*)=0 \)  
Vi velger å bruke sekantmetoden til nullpunktsbestemmelsen i \eqref{eq:23039}.

<p>
<br />
<b>Iterasjonsprosess</b>

<p>
Iterasjonsprosessen ved bruk av sekantmetoden, er gitt ved:

$$
\begin{equation}
s^{m+1}=s^m+\delta s,\ \delta s=-\phi(s^m)\cdot \left[\frac{s^m-s^{m-1}}{\phi(s^m)-\phi(s^{m-1})}\right],\ m=1,2.\dots
\label{eq:23040}
\end{equation}
$$

<p>
Antar at \( s^{m-1} \) og \( s^m \)  er kjent.

<ol>
 <li> Beregn \( \phi (s^{m-1}) \) og \( \phi (s^m) \)  ved å løse\eqref{eq:23038a}.</li>
 <li> Beregn  \( \delta s \) og \( s^{m+1} \)   fra \eqref{eq:23040}</li>
 <li> Sett</li>

<ul>
    <li> \( s^{m-1}\gets s^m \)</li>
    <li> \( s^m \gets s^{m+1} \)</li>
    <li> \( \phi (s^{m-1}) \gets \phi (s^m) \)</li>
</ul>

</ol>

Gjenta skritt 1–3 inntil konvergens er oppnådd.

<p>
I dette tilfellet er korrekt verdi \( s^*=0.46960... \)   slik at konvergenskriteriet tilslutt blir \( \delta s < \varepsilon \),  dvs. en absolutt test. 
Under prosessen kan vi ha  \( s > 1 \)  og da testes \( \left|\dfrac{\delta s}{s}\right| \), altså en relativ test.

<p>
La oss se litt nærmere på hvordan vi finner passende startverdier \( s^0 \) og \( s^1 \) for å komme igang med iterasjonsprosessen. Den vanligvis enkleste 
måten å få oversikt over nullpunktene for en funksjon på, er å framstille funksjonen grafisk. Figure <a href="#fig:217">28</a> viser \( \phi(s) \) der 
\( s\in[0.05,\ 0.8] \). Beregningen er gjort med Pythonprogrammet \( phi\_plot\_blasius\_shoot\_v2 \) . Av figuren ser vi at nullpunktet ligger 
i intervallet \( [0.45,\ 0.5] \). Vi ser også at vi har et stort spillerom ved valg av  \( s^0 \) og \( s^1 \).

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter2/src-ch2/phi_plot_blasius_shoot_v2.py;ODEschemes.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter2/src-ch2/ODEschemes.py;</span>


<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">ODEschemes</span> <span style="color: #008000; font-weight: bold">import</span> euler, heun, rk4
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #408080; font-style: italic"># Change some default values to make plots more readable on the screen</span>
LNWDT<span style="color: #666666">=3</span>; FNT<span style="color: #666666">=20</span>
matplotlib<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; matplotlib<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fblasius</span>(y, x):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;ODE-system for the Blasius-equation&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> [y[<span style="color: #666666">1</span>],y[<span style="color: #666666">2</span>], <span style="color: #666666">-</span>y[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>y[<span style="color: #666666">2</span>]]

solvers <span style="color: #666666">=</span> [euler, heun, rk4] <span style="color: #408080; font-style: italic">#list of solvers</span>
solver<span style="color: #666666">=</span>solvers[<span style="color: #666666">2</span>] <span style="color: #408080; font-style: italic"># select specific solver</span>


<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, exp, <span style="color: #008000">abs</span>
xmin <span style="color: #666666">=</span> <span style="color: #666666">0</span>
xmax <span style="color: #666666">=</span> <span style="color: #666666">5.75</span>

N <span style="color: #666666">=</span> <span style="color: #666666">50</span>  <span style="color: #408080; font-style: italic"># no x-values</span>
x <span style="color: #666666">=</span> linspace(xmin, xmax, N<span style="color: #666666">+1</span>)

<span style="color: #408080; font-style: italic"># Guessed values</span>
<span style="color: #408080; font-style: italic">#s=[0.1,0.8]</span>
s_guesses<span style="color: #666666">=</span>np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0.01</span>,<span style="color: #666666">5.0</span>)

z0<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #666666">3</span>)

beta<span style="color: #666666">=1.0</span> <span style="color: #408080; font-style: italic">#Boundary value for eta=infty</span>

phi <span style="color: #666666">=</span> []
<span style="color: #008000; font-weight: bold">for</span> s_guess <span style="color: #AA22FF; font-weight: bold">in</span> s_guesses:
    z0[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> s_guess
    u <span style="color: #666666">=</span> solver(fblasius, z0, x)
    phi<span style="color: #666666">.</span>append(u[<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>] <span style="color: #666666">-</span> beta)

plot(s_guesses,phi)

title(<span style="color: #BA2121">&#39;Phi-function for the Blasius equation&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;phi&#39;</span>)
xlabel(<span style="color: #BA2121">&#39;s&#39;</span>)
grid(b<span style="color: #666666">=</span><span style="color: #008000">True</span>, which<span style="color: #666666">=</span><span style="color: #BA2121">&#39;both&#39;</span>)
show()
</pre></div>
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 28:  <div id="fig:217"></div> </p></center>
<p><img src="fig-ch2/fig17transp_blasiusphiplot.png" align="bottom" width=400></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 29:  <div id="fig:218"></div> </p></center>
<p><img src="fig-ch2/fig18.png" align="bottom" width=400></p>
</center>

<p>
<!-- Figuerne er fortsatt fra Matlabprogrammet -->

<p>
Figure <a href="#fig:218">29</a> viser den dimensjonsløse u-hastigheten \( f'(\eta) \)   og den dimensjonsløse skjærspenningen \( f''(\eta) \)   som beregnet 
i tabellen på neste side. Den maksimale verdien av \( f''(\eta) \)   inntreffer for \( \eta=0 \)  , som igjen betyr at skjærspenningen er størst ved veggen. 
Legg merke til at \( f'''(0)=0 \)   som betyr at \( f''(\eta) \)  har vertikal tangent på veggen. Tabellen nedenfor er beregnet med programmet
\( blasius\_shoot\_v2 \):

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter2/src-ch2/blasius_shoot_v2.py;ODEschemes.py @ git@lrhgit/tkt4140/allfiles/digital_compendium/chapter2/src-ch2/ODEschemes.py;</span>

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">ODEschemes</span> <span style="color: #008000; font-weight: bold">import</span> euler, heun, rk4
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #408080; font-style: italic"># Change some default values to make plots more readable on the screen</span>
LNWDT<span style="color: #666666">=3</span>; FNT<span style="color: #666666">=20</span>
matplotlib<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; matplotlib<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">fblasius</span>(y, x):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;ODE-system for the Blasius-equation&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">return</span> [y[<span style="color: #666666">1</span>],y[<span style="color: #666666">2</span>], <span style="color: #666666">-</span>y[<span style="color: #666666">0</span>]<span style="color: #666666">*</span>y[<span style="color: #666666">2</span>]]


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">dsfunction</span>(phi0,phi1,s0,s1):
    <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">abs</span>(phi1<span style="color: #666666">-</span>phi0)<span style="color: #666666">&gt;0.0</span>):   
        <span style="color: #008000; font-weight: bold">return</span>    <span style="color: #666666">-</span>phi1 <span style="color: #666666">*</span>(s1 <span style="color: #666666">-</span> s0)<span style="color: #666666">/</span><span style="color: #008000">float</span>(phi1 <span style="color: #666666">-</span> phi0)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0.0</span>

solvers <span style="color: #666666">=</span> [euler, heun, rk4] <span style="color: #408080; font-style: italic">#list of solvers</span>
solver<span style="color: #666666">=</span>solvers[<span style="color: #666666">0</span>] <span style="color: #408080; font-style: italic"># select specific solver</span>


<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, exp, <span style="color: #008000">abs</span>
xmin <span style="color: #666666">=</span> <span style="color: #666666">0</span>
xmax <span style="color: #666666">=</span> <span style="color: #666666">5.750</span>

N <span style="color: #666666">=</span> <span style="color: #666666">400</span>  <span style="color: #408080; font-style: italic"># no x-values</span>
x <span style="color: #666666">=</span> linspace(xmin, xmax, N<span style="color: #666666">+1</span>)

<span style="color: #408080; font-style: italic"># Guessed values</span>
s<span style="color: #666666">=</span>[<span style="color: #666666">0.1</span>,<span style="color: #666666">0.8</span>]


z0<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(<span style="color: #666666">3</span>)
z0[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> s[<span style="color: #666666">0</span>]


beta<span style="color: #666666">=1.0</span> <span style="color: #408080; font-style: italic">#Boundary value for eta=infty</span>

<span style="color: #408080; font-style: italic">## Compute phi0</span>

u <span style="color: #666666">=</span> solver(fblasius, z0, x)
phi0 <span style="color: #666666">=</span> u[<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>] <span style="color: #666666">-</span> beta

nmax<span style="color: #666666">=10</span>
eps <span style="color: #666666">=</span> <span style="color: #666666">1.0e-3</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(nmax):
    z0[<span style="color: #666666">2</span>] <span style="color: #666666">=</span> s[<span style="color: #666666">1</span>]
    u <span style="color: #666666">=</span> solver(fblasius, z0, x)
    phi1 <span style="color: #666666">=</span> u[<span style="color: #666666">-1</span>,<span style="color: #666666">1</span>] <span style="color: #666666">-</span> beta
    ds <span style="color: #666666">=</span> dsfunction(phi0,phi1,s[<span style="color: #666666">0</span>],s[<span style="color: #666666">1</span>])
    s[<span style="color: #666666">0</span>]  <span style="color: #666666">=</span> s[<span style="color: #666666">1</span>]
    s[<span style="color: #666666">1</span>]  <span style="color: #666666">+=</span> ds
    phi0 <span style="color: #666666">=</span> phi1
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;n = {}  s1 = {} and ds = {}&#39;</span><span style="color: #666666">.</span>format(n,s[<span style="color: #666666">1</span>],ds)
    
    <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">abs</span>(ds)<span style="color: #666666">&lt;=</span>eps):
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Solution converged for eps = {} and s1 ={} and ds = {}. </span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span><span style="color: #666666">.</span>format(eps,s[<span style="color: #666666">1</span>],ds)
        <span style="color: #008000; font-weight: bold">break</span>


plot(u[:,<span style="color: #666666">1</span>],x,u[:,<span style="color: #666666">2</span>],x)
xlabel(<span style="color: #BA2121">&#39;u og u</span><span style="color: #BB6622; font-weight: bold">\&#39;</span><span style="color: #BA2121">&#39;</span>)
ylabel(<span style="color: #BA2121">&#39;eta&#39;</span>)


legends<span style="color: #666666">=</span>[]
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;velocity&#39;</span>)
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;wall shear stress&#39;</span>)
legend(legends,loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;best&#39;</span>,frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
title(<span style="color: #BA2121">&#39;Solution of the Blaisus eqn with &#39;</span><span style="color: #666666">+</span><span style="color: #008000">str</span>(solver<span style="color: #666666">.</span>func_name)<span style="color: #666666">+</span><span style="color: #BA2121">&#39;-shoot&#39;</span>)
show()
close() <span style="color: #408080; font-style: italic">#Close the window opened by show()</span>
</pre></div>
<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>itr.</b></td> <td align="center"><b>   s    </b></td> <td align="center"><b>        ds        </b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   1       </td> <td align="center">   0.471625    </td> <td align="center">   - 2.837e-002          </td> </tr>
<tr><td align="center">   2       </td> <td align="center">   0.469580    </td> <td align="center">   - 2.046e-003          </td> </tr>
<tr><td align="center">   3       </td> <td align="center">   0.469601    </td> <td align="center">   \( ~ \) 2.146e-005    </td> </tr>
<tr><td align="center">   4       </td> <td align="center">   0.469601    </td> <td align="center">   - 1.540e-008          </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-3 -->
<p>

<div class="row">
  <div class="col-xs-4">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( \eta \)</td> <td align="center"><b>   f    </b></td> <td align="center"><b>   f'   </b></td> <td align="center"><b>     f"     </b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   0.00          </td> <td align="center">   0.000000    </td> <td align="center">   0.000000    </td> <td align="center">   4.69601e-001    </td> </tr>
<tr><td align="center">   0.25          </td> <td align="center">   0.014673    </td> <td align="center">   0.117364    </td> <td align="center">   4.69027e-001    </td> </tr>
<tr><td align="center">   0.50          </td> <td align="center">   0.058643    </td> <td align="center">   0.234228    </td> <td align="center">   4.65032e-001    </td> </tr>
<tr><td align="center">   0.75          </td> <td align="center">   0.131642    </td> <td align="center">   0.349324    </td> <td align="center">   4.54373e-001    </td> </tr>
<tr><td align="center">   1.00          </td> <td align="center">   0.232991    </td> <td align="center">   0.460634    </td> <td align="center">   4.34380e-001    </td> </tr>
<tr><td align="center">   1.25          </td> <td align="center">   0.361431    </td> <td align="center">   0.565601    </td> <td align="center">   4.03495e-001    </td> </tr>
<tr><td align="center">   1.50          </td> <td align="center">   0.515032    </td> <td align="center">   0.661476    </td> <td align="center">   3.61805e-001    </td> </tr>
<tr><td align="center">   1.75          </td> <td align="center">   0.691201    </td> <td align="center">   0.745765    </td> <td align="center">   3.11302e-001    </td> </tr>
<tr><td align="center">   2.00          </td> <td align="center">   0.886798    </td> <td align="center">   0.816697    </td> <td align="center">   2.55671e-001    </td> </tr>
<tr><td align="center">   2.25          </td> <td align="center">   1.098374    </td> <td align="center">   0.873559    </td> <td align="center">   1.99544e-001    </td> </tr>
<tr><td align="center">   2.50          </td> <td align="center">   1.322442    </td> <td align="center">   0.916810    </td> <td align="center">   1.47476e-001    </td> </tr>
<tr><td align="center">   2.75          </td> <td align="center">   1.555766    </td> <td align="center">   0.947928    </td> <td align="center">   1.02930e-001    </td> </tr>
<tr><td align="center">   3.00          </td> <td align="center">   1.795573    </td> <td align="center">   0.969057    </td> <td align="center">   6.77108e-002    </td> </tr>
<tr><td align="center">   3.25          </td> <td align="center">   2.039661    </td> <td align="center">   0.982573    </td> <td align="center">   4.19262e-002    </td> </tr>
<tr><td align="center">   3.50          </td> <td align="center">   2.286412    </td> <td align="center">   0.990711    </td> <td align="center">   2.44148e-002    </td> </tr>
<tr><td align="center">   3.75          </td> <td align="center">   2.534723    </td> <td align="center">   0.995319    </td> <td align="center">   1.33643e-002    </td> </tr>
<tr><td align="center">   4.00          </td> <td align="center">   2.783894    </td> <td align="center">   0.997773    </td> <td align="center">   6.87412e-003    </td> </tr>
<tr><td align="center">   4.25          </td> <td align="center">   3.033509    </td> <td align="center">   0.999000    </td> <td align="center">   3.32201e-003    </td> </tr>
<tr><td align="center">   4.50          </td> <td align="center">   3.283340    </td> <td align="center">   0.999577    </td> <td align="center">   1.50841e-003    </td> </tr>
<tr><td align="center">   4.75          </td> <td align="center">   3.533271    </td> <td align="center">   0.999832    </td> <td align="center">   6.43473e-004    </td> </tr>
<tr><td align="center">   5.00          </td> <td align="center">   3.783244    </td> <td align="center">   0.999938    </td> <td align="center">   2.57831e-004    </td> </tr>
<tr><td align="center">   5.25          </td> <td align="center">   4.033235    </td> <td align="center">   0.999980    </td> <td align="center">   9.70546e-005    </td> </tr>
<tr><td align="center">   5.50          </td> <td align="center">   4.283232    </td> <td align="center">   0.999995    </td> <td align="center">   3.43646e-005    </td> </tr>
<tr><td align="center">   5.75          </td> <td align="center">   4.533231    </td> <td align="center">   1.000000    </td> <td align="center">   1.15317e-005    </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-4 -->
<p>
<!-- !split -->

<h2 id="ex:28">Example:Falkner-Skan ligningen</h2>

<p>
Blasius ligning er egentlig et spesialtilfelle av en mer generell ligning som kalles Falkner-Skan ligningen. Falkner-Skan tranformasjonen (1930) 
overfører grensesjiktligningen til en likedannhetsform gitt ved:

$$
\begin{equation}
f'''+ff''+\beta\cdot[1-(f')^2]=0
\label{eq:23041}
\end{equation}
$$

<p>
når fristrømshastigheten \( U(x) \) er gitt ved:

$$
\begin{equation}
U(x)=U_0x^m,\ m= \text{konstant}
\label{eq:23042}
\end{equation}
$$

<p>
\eqref{eq:23041} kalles også kilestrømsligningen fordi parameteren \( \beta \)  har den geometriske betydningen som vist i Figure <a href="#fig:219">30</a>:

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 30:  <div id="fig:219"></div> </p></center>
<p><img src="fig-ch2/fig19.png" align="bottom" width=400></p>
</center>

<p>
Vi ser at halve kilevinkelen er \( \beta\cdot \frac{\pi}{2} \). For \( \beta=0 \), får vi følgelig en flat plate, og \eqref{eq:23041}
blir da Blasius ligning.

<p>
En detaljert utledning er gitt i appendiks C, del C.3 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>.
Vi gjengir noe av utledningen  for oversiktens skyld.

<p>
Sammenheng mellom \( m \) og \( \beta \): \( \beta=\frac{2m}{m+1} \) og \( m=\frac{\beta}{2-\beta} \) Vi ser at \( \beta=0 \)  gir \( U(x)=U_0 \).

<p>
Falkner-Skan transformasjonen er gitt ved:

$$
\begin{equation}
\eta=\sqrt{ \frac{U}{(2-\beta)\nu x} }\cdot y,\ f(\eta)=\frac{\psi}{\sqrt{(2-\beta)U\nu x}}
\label{eq:23043}
\end{equation}
$$

<p>
Dersom vi velger de samme randbetingelsene som i eksempel (<a href="#ex:27">Example: Blasius-ligningen</a>), får vi:

<p>
F-S - ligningen:

$$
\begin{equation}
f'''+ff''+\beta\cdot [1-(f')^2]=0
\label{eq:23044a}
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{equation} \label{eq:23044b}
\left.\begin{matrix}
&f(0)=f'(0)=0 \\ 
&f'(\eta_\infty)=1
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Vi løser ligningen på samme måte som Blasius  ligning ved å skrive \eqref{eq:23044a} som et sett av 1. ordens differensialligninger:

$$
\begin{align}
&f'=f_1 
\label{_auto26}\\ 
&f_1'=f_2 \label{eq:23045a} \\ 
&f_2'=-[ff_2+\beta(1-f_1^2)]
\label{_auto27}
\end{align}
$$

<p>
Randbetingelser: 

$$
\begin{equation} \label{eq:23045b}
\left.\begin{matrix}
&f(0)=f_1(0)=0 \\ 
&f_1(\eta_\infty)=1
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Med  \( f''(0)=f_2(0)=s \), får vi:

$$
\begin{equation}
\phi(s)=f_1(\eta_\infty;s)-1
\label{eq:23046}
\end{equation}
$$

<p>
med korrekt verdi \( s^* \) når \( \phi(s^*)=0 \)

<p>
Flere detaljer om løsningsprosessen er gitt i appendiks C, del C.3 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>.

<p>
<b>Bestemmelse av startverdier.</b>

<p>
Vi bruker sekantmetoden for å finne nullpunktet i \eqref{eq:23046} og trenger derfor to startverdier \( s^0 \) og \( s^1 \)  for å starte iterasjonsprosessen. 
Velger tilfellet med \( \beta=1 \)  som er strømning mot en flat plate, dvs.: en stagnasjonsstrøm, se Figure <a href="#fig:220">31</a>. 
Dette tilfellet kalles også en Hiemenz-strømning.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 31:  <div id="fig:220"></div> </p></center>
<p><img src="fig-ch2/fig20transp_hiemenz.png" align="bottom" width=400></p>
</center>

<p>
<br />

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 32:  <div id="fig:221"></div> </p></center>
<p><img src="fig-ch2/fig21transp_falknerphiplot.png" align="bottom" width=400></p>
</center>

<p>
\( \phi(s) \)  er  tegnet i Figure <a href="#fig:221">32</a>. 
Beregningen er utført med bruk av <b>ode45</b>. 
<!-- begin inline comment -->
<font color="red">(<b>Marie 4</b>: Matlab-funksjon)</font>
<!-- end inline comment -->

<p>
Det korrekte nullpunktet er \( s^*=1.23259 \)  som er den entydige løsningen av F-S-ligningen for \( \eta\to\infty \)  med \( \beta=1 \). Dersom vi ser på 
kurven for \( \eta_\infty=5.0 \), finner vi et nullpunkt rundt \( s=0.85 \)  og et rundt \( s=1.23 \)  der det siste er det korrekte. Årsaken er at 
F-S-ligningen har to løsninger for endelige verdier av \( \eta_\infty \)  der det venstre nullpunktet beveger seg mens det andre som er det korrekte 
for \( \eta\to\infty \), ligger fast. Begge nullpunktene gir korrekte løsninger av diff.ligningen, men det venstre nullpunktet gir en løsning som fører 
til avløsning og tilbake-strømning, noe som er ufysikalsk i dette tilfellet. Legg merke til at avstanden mellom nullpunktene minsker med økende verdi 
av \( \eta_\infty \), og med \( \eta\to\infty \) vil de to grenene falle sammen.

<p>
Dersom vi bruker en løser med konstant skrittlengde, f.eks <b>RK4</b>, og samtidig velger en forholdsvis stor skrittlengde, f. eks. \( \Delta\eta=0.2 \), vil 
vi få en rekke andre nullpunkt. Disse nullpunktene gir løsning av differanseligningen, men er ikke løsning av differensialligningen. 
Ved å la \( \Delta\eta\to0 \), vil disse nullpunktene forsvinne også for store \( \eta_\infty \)-verdier.

<p>
Figure <a href="#fig:222">33</a> og Figure <a href="#fig:223">34</a> viser noen resultater fra Matlab-programmet <b>fsksec</b>. 
<!-- begin inline comment -->
<font color="red">(<b>Marie 5</b>: Matlab-program)</font>
<!-- end inline comment -->

for ulike verdier av \( \beta \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 33:  <div id="fig:222"></div> </p></center>
<p><img src="fig-ch2/fig22.png" align="bottom" width=350></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 34:  <div id="fig:223"></div> </p></center>
<p><img src="fig-ch2/fig23.png" align="bottom" width=350></p>
</center>

<p>
For \( \beta=\beta_{sep}=-0.19883768\dots \)  forsvinner skjærspenningen ved veggen. Dette indikerer begynnende tilbakestrømning og separasjon, 
se Figure <a href="#fig:224">35</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 35:  <div id="fig:224"></div> </p></center>
<p><img src="fig-ch2/fig24transp_falknersep.png" align="bottom" width=400></p>
</center>

<p>
Det finnes løsninger av F-S-ligningen for \( \beta \)-verdier  som ligger utenfor det området vi fysisk kan knytte til en kilestrøm. For mer 
informasjon om disse løsningene, henvises til Evans <a href="#evans68laminar">[8]</a>, White <a href="#white91viscous">[9]</a>, og Schlichting <a href="#schlichting78boundary">[10]</a>.

<p>
Tilslutt bør det nevnes at det finnes en analytisk løsning av F-S-ligningen. Vi tenker oss at det er plassert et sluk i \( x=0 \)  med styrke \( K \)  
parallelt med platekanten. I dette tilfellet blir \( U(x)=-\dfrac{K}{x} \)  og \( \eta=\dfrac{y}{x}\sqrt{ \dfrac{K}{\nu} } \).

<p>
Ligningen blir nå:

$$
\begin{equation}
f'''(\eta)-\left(f'(\eta)\right)^2+1=0
\label{eq:23047a}
\end{equation}
$$

<p>
med de vanlige randbetingelsene 

$$
\begin{align}
&f(0)=f'(0)=0 \label{eq:23047b}\\ 
&f'(\eta_\infty)=1
\label{_auto28}
\end{align}
$$

<p>
Løsningen kan da skrives:

$$
\begin{align}
f(\eta)&=\eta+2\sqrt{3}-3\sqrt{2}\cdot\tanh(z) \label{eq:23048a} \\ 
f'(\eta)&=3\tanh^2(z)-2 \label{eq:23048b}\\ 
f''(\eta)&=3\sqrt{2}\cdot\tanh(z)\cdot[1-\tanh^2(z)] \label{eq:23048c}
\end{align}
$$

<p>
Spesielt har vi:

$$
\begin{equation*}
f''(0)=\frac{2}{\sqrt{3}}=1.1547\dots
\end{equation*}
$$

<p>
Merk at en funksjon \( f(\eta)=\eta+a-3\sqrt{2}\cdot\tanh(\eta/\sqrt{2}+b) \)   tilfredstiller \eqref{eq:23047a}  for vilkårlige verdier av \( a \) 
og \( b \) med \( f'(\infty)=1 \).

<p>
<!-- !split -->

<h1 id="ch2:sec4">Skyting med to startbetingelser</h1>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 36:  <div id="fig:225"></div> </p></center>
<p><img src="fig-ch2/fig25.png" align="bottom" width=400></p>
</center>

<h2 id="kap:241">Lineære ligninger</h2>

<p>
Vi vil nå utvide teknikken som vi brukte i avsnitt (<a href="#section:linear">Linear equations</a>) til to ukjente start-betingelser. I dette tilfellet må vi tippe to startbetingelser 
\( r \) og \( s \) med  tilhørende funksjoner \( \phi \) og \( \psi \). Dette er vist grafisk i Figure <a href="#fig:225">36</a>. Da ligningen som skal løses er lineær, 
danner \( \phi \) og$\psi$  to plan og kan derfor skrives på formen:

$$
\begin{equation} \label{eq:2411}
\left.\begin{matrix}
&\phi=A\cdot s+B\cdot r +C  \\ 
&\psi=D\cdot s+E\cdot r+F 
\end{matrix}\right.\ 
\end{equation}
$$

<p>
der \( A,B,C,\cdots,F \) er konstanter som må bestemmes. De rette verdiene \( r^* \) og \( s^* \) finnes fra  \( \phi(r^*,s^*)=0 \) og \( \psi(r^*,s^*)=0 \). (Se figuren)
Vi har seks konstanter som bestemmes fra ligningene:

$$
\begin{align}
&\phi^0=A\cdot s^0+B\cdot r^0+C 
\label{_auto29}\\ 
&\phi^1=A\cdot s^1+B\cdot r^1+C \label{eq:2412a} \\ 
&\phi^{(2)}=A\cdot s^{(2)}+B\cdot r^{(2)}+C 
\label{_auto30}\\ 
\label{_auto31}
\end{align}
$$

<p>
<br />

$$
\begin{align}
&\psi^0=D\cdot s^0+E\cdot r^0+F 
\label{_auto32}\\ 
&\psi^1=D\cdot s^1+E\cdot r^1+F \label{eq:2412b} \\ 
&\psi^{(2)}=D\cdot s^{(2)}+E\cdot r^{(2)}+F 
\label{_auto33}\\ 
\label{_auto34}
\end{align}
$$

<p>
der \( s^0,\ s^1,\ s^{(2)},\ r^0,\ r^1 \) og \( r^{(2)} \) er verdier som vi har tippet for initialbetingelsene.For å forenkle slutt-resultatet, 
velger vi følgende verdier:

$$
\begin{align}
&\text{1)}\ \               s^0=0,\ r^0=0 
\label{_auto35}\\ 
&\text{2)}\ \               s^1=0,\ r^1=1 \label{eq:2413} \\ 
&\text{3)}\ \               s^{(2)}=1,\ r^{(2)}=0
\label{_auto36}
\end{align}
$$

<p>
Vi får da følgende uttrykk for konstantene:

$$
\begin{equation} \label{eq:2414}
\left.\begin{matrix}
&C=\phi^0,\ B=\phi^1-\phi^0,\ A=\phi^{(2)}-\phi^0 \\ 
&F=\psi^0,\  E=\psi^1-\psi^0,\ D=\psi^{(2)}-\psi^0
\end{matrix}\right.\ 
\end{equation}
$$

<p>
<br />

<p>
De korrekte verdiene \( r^* \) og \( s^* \) finnes fra \( \phi(r^*,\ s^*)=0 \) og \( \psi(r^*,\ s^*)=0 \) som
her blir \( A\cdot s^*+B\cdot r^*+C=D\cdot s^*+E\cdot r^*+C=0 \) med følgende løsning:

$$
\begin{equation*}
s^*=\frac{E\cdot C-B\cdot F}{D\cdot B-A\cdot E},\ r^*=\frac{A\cdot F-D\cdot C}{D\cdot B-A\cdot E}
\end{equation*}
$$

<p>
som innsatt for \( A,B,C,\dots,F \) gir:

$$
\begin{equation} \label{eq:2415}
\left.\begin{matrix}
&s^*=\frac{\psi^1\cdot\phi^0-\phi^1\cdot\psi^0}{(\psi^{(2)}-\psi^0)\cdot(\phi^1-\phi^0)-(\phi^{(2)}-\phi^0)\cdot(\psi^1-\psi^0)} \\ 
\\ 
&r^*=\frac{\phi^{(2)}\cdot\psi^0-\psi^{(2)}\cdot\phi^0}{(\psi^{(2)}-\psi^0)\cdot(\phi^1-\phi^0)-(\phi^{(2)}-\phi^0)\cdot(\psi^1-\psi^0)}
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Fremgangsmåten blir da som følger:

<p>
Vi løser ligningsystemet for de tre settene av verdier for \( r \) og \( s \) gitt i \eqref{eq:2413} og finner derved de tilhørende verdiene av \( \phi \) 
og \( \psi \). De korrekte verdiene \( r^* \) og \( s^* \) finnes da fra \eqref{eq:2415}). Vi skal bruke denne prosedyren i eksempel (<a href="#ex:29">Example: Sylindrisk tank med væske</a>)

<h2 id="ex:29">Example: Sylindrisk tank med væske</h2>

<p>
<b>DEL 1: Konstant veggtykkelse</b>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 37:  <div id="fig:226"></div> </p></center>
<p><img src="fig-ch2/fig26.png" align="bottom" scale=0.9></p>
</center>

<p>
Figure <a href="#fig:226">37</a> viser en sylindrisk tank fylt med en væske til en høyde \( H \). \( W \) er radiell forskyvning. På detaljen til venstre er 
\( V \) skjærkraft pr. lengdeenhet og \( M \) moment pr. lengdeenhet. Pilene angir positiv retning.

<p>
Differensialligningen for forskyvningen \( W \)  er gitt ved:

$$
\begin{equation}
\frac{d^4W}{dX^4}+B\cdot W=-\gamma \frac{H-X}{D}
\label{eq:2416}
\end{equation}
$$

<p>
der \( B=\dfrac{12(1-\nu^2)}{R^2t^2},\ D=\dfrac{Et^3}{12(1-\nu^2)},\ \gamma=\rho g \)

<p>
Her er \( \nu \) Poissons tall, \( E \) elastisitetsmodelen og \( \rho \)  væskas tetthet.

<p>
Innfører dimensjonsløse størrelser:

$$
\begin{equation}
x=\frac{X}{H}\ \text{og}\ w=\frac{E}{\gamma Ht}\cdot \left(\frac{t}{R}\right)^2\cdot W
\label{eq:2417}
\end{equation}
$$

<p>
som innsatt i \eqref{eq:2416} gir følgende differensialligning:

$$
\begin{equation}
\frac{d^4w}{dx^4}+4\beta^4\cdot w=-4\beta^4(1-x) 
\label{eq:2418a}
\end{equation}
$$

<p>
der

$$
\begin{equation}
\beta^4=\frac{3(1-\nu^2)H^4}{R^2t^2}
\label{eq:2418b}
\end{equation}
$$

<p>
<b>Randverdier.</b>

<p>
For \( x= 0 \):

$$
\begin{equation*}
W=0,\ \frac{dW}{dX}=0\ \text{(Fast innspent)}
\end{equation*}
$$

<p>
Skjærkraft og moment \( =0 \)  for \( X=H \) som gir:

$$
\begin{equation*}
M=-D \frac{d^2W}{dX^2}=0,\ V=-D \frac{d^3W}{dX^3}=0
\end{equation*}
$$

<p>
Randverdiene uttrykt ved dimensjonsløse størrelser blir da:

$$
\begin{equation} \label{eq:2419}
\left.\begin{matrix}
&\text{For}\ x=0: \ \   w=0,\ \frac{dw}{dx}=0 \\ 
&\text{For}\ x=1: \ \   \frac{d^2w}{dx^2}=0,\ \frac{d^3w}{dx^3}=0
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Dimensjonsløst moment  \( m(x)=-\dfrac{d^2w}{dx^2} \)  og dimensjonsløs skjærkraft  \( v(x)=-\dfrac{d^3w}{dx^3} \). Se appendiks D for flere detaljer.          %APPREF

<p>
Velger en en tank av betong med følgende dimensjoner:

$$
\begin{equation} \label{eq:24110}
\left.\begin{matrix}
&R=8.5m,\ H=7.95m,\  t=0.35m \\ 
&\gamma=9810N/m^3\text{(vann)},\  \nu=0.2,\ E=2\cdot 10^4\text{MPa}
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Med disse data blir  \( \beta=6.0044 \).

<p>
<br />

<p>
<b>Numerisk beregning</b>

<p>
Setter \( w=y_1,\ w'=y_1'=y_2,\ w''=y_2'=y_3,\ w'''=y_3'=y_4 \)   og skriver  \eqref{eq:2416} som et system av fire 1. ordens 
differensialligninger:

$$
\begin{equation} \label{eq:24111a}
\left.\begin{matrix}
&y_1'=y_2 \\ 
&y_2'=y_3 \\ 
&y_3'=y_4 \\ 
&y_4'=-4\beta^4(y+1-x)
\end{matrix}\right.\ 
\end{equation}
$$

<p>
med følgende randbetingelser:

$$
\begin{equation}
y_1(0)=0,\ y_2(0)=0,\ y_3(1)=0,\ y_4(1)=0
\label{eq:24111b}
\end{equation}
$$

<p>
Skal bestemme \( s=w''(0)=y_3(0) \) og \( r=w'''(0)=y_4(0) \)  slik at \( y_3(1) \) og \( y_4(1)=0 \). Setter følgelig \( \phi(r,s)=y_3(1;r,s) \) og 
\( \psi(r,s)=y_4(1;r,s) \). De korrekte verdiene \( r^* \) og \( s^* \) gir da \( \phi(r^*,s^*)=0 \). Løser følgelig \eqref{eq:24111a} tre ganger 
med \( y_1(0) \) og \( y_2(0)=0 \)   mens verdiene for \( r \) og \( s \) velges fra \eqref{eq:2413}. De korrekte verdiene \( r^* \) og \( s^* \) beregnes 
deretter fra \eqref{eq:2415}.

<p>
Utsnitt av programmet <b>tank1</b>  samt utskrift er vist nedenfor. 
<!-- begin inline comment -->
<font color="red">(<b>Marie 5</b>: Matlab-program)</font>
<!-- end inline comment -->

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">       x         w             dw/dx           m(x)            v(x)

     0.000   0.00000e+000   0.00000e+000    6.00946e+001  -7.93776e+002 
     0.100  -1.89049e-001  -2.86464e+000    4.85241e+000  -3.36907e+002 
     0.200  -4.57346e-001  -2.19767e+000   -1.36887e+001  -6.60901e+001 
     0.300  -6.03796e-001  -7.32255e-001   -1.38468e+001   4.15724e+001 
     0.400  -6.16145e-001   3.93069e-001   -8.41051e+000   5.74987e+001 
     0.500  -5.43811e-001   9.70524e-001   -3.44813e+000   3.94237e+001 
     0.600  -4.35148e-001   1.15559e+000   -6.10973e-001   1.81108e+001 
     0.700  -3.18861e-001   1.15307e+000    4.27833e-001   4.09131e+000 
     0.800  -2.06030e-001   1.10306e+000    4.68862e-001  -2.15847e+000 
     0.900  -9.76194e-002   1.07014e+000    1.76515e-001  -2.96401e+000 
     1.000   8.92555e-003   1.06379e+000    1.20446e-004   6.10070e-004
</pre></div>
<p>
<br />

<p>
Vi ser at vi har god overenstemmelse når vi sammenligner med den analytiske løsningen i tabell 1 i appendiks D i 
<a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>.
Figure <a href="#fig:227">fig:227</a> nedenfor viser forløpet av det dimensjonsløse momentet samt skjærkrafta.

<p>
<!-- FIGURE:[fig-ch2/fig27transp_momentshear.png, scale=0.9] <div id="fig:227"></div> -->

<p>
\eqref{eq:2418a} er av typen der den høyeste deriverte er multiplisert med et lite tall \( \varepsilon \) 
der \( \varepsilon=\frac{1}{4\beta^4} \) i vårt tilfelle. Kalles gjerne en singulær ligning dersom vi tillater at \( \beta\to\infty \). 
Dette gjenspeiler seg i den analytiske løsningen i lign. (D.1.6) og (D.1.8), del D.1, i appendiks D i 
<a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a> der vi har ledd av typen \( e^{\beta x}\sin\beta x \) og \( e^{\beta x}\cos\beta x \).

<p>
Dette betyr at skytelengden i praksis er lik \( \beta \). Det vil da bli mer og mer vanskelig å treffe randen \( x=1 \)  med  økende 
\( \beta \)-verdier. For store \( \beta \)-verdier vil deformasjonen konsentrere seg  rundt \( x=0 \)  slik at det kanskje ikke er nødvendig å skyte 
helt til \( x=1 \), men kan greie oss med en mindre verdi.

<p>
Nedenfor har vi beregnet innspenningsmomentet \( m_0=-\dfrac{\partial^2m}{\partial x^2}\bigg|_{x=0} \)  og skjærkrafta 
\( v_0=-\dfrac{\partial^2v}{\partial x^2}\bigg|_{x=0} \) som funksjon av skytelengden. Merk at  \( m_0=-s^* \) og \( v_0=-r^* \).

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>Skytelengde</b></td> <td align="center">\( m_0 \)</td> <td align="center">\( -v_0 \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   1.0            </td> <td align="center">   60.098       </td> <td align="center">   793.809       </td> </tr>
<tr><td align="center">   0.9            </td> <td align="center">   60.093       </td> <td align="center">   793.715       </td> </tr>
<tr><td align="center">   0.8            </td> <td align="center">   60.099       </td> <td align="center">   793.670       </td> </tr>
<tr><td align="center">   0.7            </td> <td align="center">   60.079       </td> <td align="center">   793.598       </td> </tr>
<tr><td align="center">   0.6            </td> <td align="center">   59.816       </td> <td align="center">   791.835       </td> </tr>
<tr><td align="center">   0.5            </td> <td align="center">   58.879       </td> <td align="center">   781.541       </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-3 -->
<p>
<br />

<p>
<b>DEL 2: Lineært variabel veggtykkelse</b>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 38:  <div id="fig:228"></div> </p></center>
<p><img src="fig-ch2/fig28.png" align="bottom" scale=0.9></p>
</center>

<p>
Her varierer veggtykkelsen lineært fra \( t_0 \)  nederst til \( t_1 \)   øverst.

<p>
Med \( \alpha=\dfrac{t_0-t_1}{t_0} \)  kan veggtykkelsen \( t \) skrives:

$$
\begin{equation}
t=\left(1-\alpha \frac{X}{H}\right)\cdot t_0,\ 0\leq X\leq H
\label{eq:24112}
\end{equation}
$$

<p>
Differensialligningen for forskyvningen \( W \)  er nå gitt ved:

$$
\begin{equation}
\frac{d^2}{dX^2}\left(D \frac{d^2W}{dX^2}\right)+E \frac{tW}{R^2}=-\gamma(H-X)
\label{eq:24113}
\end{equation}
$$

<p>
der \( D=\dfrac{Et^3}{12(1-\nu^2)},\ \gamma=\rho g \)

<p>
Konstantene har samme betydning som i del 1. (Se appendiks D i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a> for flere detaljer).

<p>
<br />

<p>
<b>Dimensjonsløs form</b>

$$
\begin{equation}
x=\frac{X}{H},\ w=\frac{E}{\gamma Ht_0}\left(\frac{t_0}{R}\right)^2\cdot W,\ \beta^4=\frac{3(1-\nu^2)}{R^2t_0^2}\cdot H^4 
\label{eq:24114}
\end{equation}
$$

<p>
\eqref{eq:24114} innsatt i \eqref{eq:24113}:

$$
\begin{equation}
\frac{d^2}{dx^2}\left[ (1-\alpha x)^3\frac{d^2w}{dx^2}\right] +4\beta^4(1-\alpha x)\cdot w=-4\beta^4(1-x)
\label{eq:24115}
\end{equation}
$$

<p>
Utderivert:

$$
\begin{equation}
\frac{d^4w(x)}{dx^4}-\frac{6\alpha}{(1-\alpha x)}\frac{d^5w(x)}{dx^5}+\frac{6\alpha^2}{(1-\alpha x)^2}\frac{d^2w(x)}{dx^2}+\frac{4\beta^4}{(1-\alpha x)^2}w(x)=-\frac{4\beta^4(1-x)}{(1-\alpha x)^5}                                                  
\label{eq:24116}
\end{equation}
$$

<p>
Dette systemet kan også løses analytisk, se appendiks D, del D.2 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>, men matematikken er mer komplisert 
fordi løsningen blir uttrykt meden spesiell type Besselfunksjoner som kalles Kelvinfunksjoner. Den numeriske fremgangsmåten er derimot uforandret.

<p>
Velger samme tank som i del 1 med tillegg for varierende veggtykkelse:

$$
\begin{equation} \label{eq:24117}
\left.\begin{matrix}
&R=8.5m,\ H=7.95m,\  t_0=0.35m ,\ t_1=0.1m \\ 
&\gamma=9810N/m^3\text{(vann)},\  \nu=0.2,\ E=2\cdot 10^4\text{MPa}
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Her blir \( \alpha=\frac{t_0-t_1}{t_0}=\frac{5}{7} \)  og som tidligere blir \( \beta=6.0044 \).

<p>
<br />

<p>
<b>Numerisk beregning</b>

<p>
Setter \( w=y_1,\ w'=y_1'=y_2,\ w''=y_2'=y_3,\ w'''=y_3'=y_4,\ z=1-\alpha x \)   og
skriver  \eqref{eq:24112} som et system av fire 1. ordens differensialligninger:

$$
\begin{equation} \label{eq:24118a}
\left.\begin{matrix}
&y_1'=y_2 \\ 
&y_2'=y_3 \\ 
&y_3'=y_4 \\ 
&y_4'=\frac{6\alpha}{z}y_4-\frac{6\alpha^2}{z^2}y_3-\frac{4\beta^4}{z^2}y_1-\frac{4\beta^4(1-x)}{z^3}
\end{matrix}\right.\ 
\end{equation}
$$

<p>
med følgende randbetingelser:

$$
\begin{equation}
y_1(0)=0,\ y_2(0)=0,\ y_3(1)=0,\ y_4(1)=0
\label{eq:24118b}
\end{equation}
$$

<p>
Fremgangsmåten blir som for del 1, bortsett fra at vi nå har parameteren \( \alpha \) i tillegg til \( \beta \). Programmet <b>tank2</b>  
blir derfor nesten identisk med <b>tank1</b>.
Hovedforskjellen er funksjonen <b>fcntank2</b>  for diff. ligningen. 
<!-- begin inline comment -->
<font color="red">(<b>Marie 7</b>: Matlab)</font>
<!-- end inline comment -->

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">       x         w             dw/dx           m(x)            v(x)

     0.000   0.00000e+000   0.00000e+000    6.23338e+001  -7.73773e+002 
     0.100  -2.15376e-001  -3.45545e+000    9.04151e+000  -3.18887e+002 
     0.200  -5.66553e-001  -3.16644e+000   -8.14798e+000  -5.86193e+001 
     0.300  -8.05113e-001  -1.53673e+000   -8.34542e+000   3.32725e+001 
     0.400  -8.79417e-001  -3.87614e-002   -4.36688e+000   3.81223e+001 
     0.500  -8.34707e-001   8.24809e-001   -1.47715e+000   1.90313e+001 
     0.600  -7.31823e-001   1.17417e+000   -3.81333e-001   4.52213e+000 
     0.700  -6.05528e-001   1.35136e+000   -2.49403e-001  -5.41818e-001 
     0.800  -4.57651e-001   1.63752e+000   -3.00683e-001   8.66313e-002 
     0.900  -2.72819e-001   2.06404e+000   -1.83081e-001   2.16427e+000
     1.000  -5.26758e-002   2.26301e+000    3.87892e-005  -1.76069e-006 
</pre></div>
<p>
<br />

<p>
Vi finner god overenstemmelse ved å sammenligne med den analytiske løsningen i tabell 7, del D.2 i appendiks D 
i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>.

<p>
<!-- !split -->

<h2 id="kap:242">Eksempel på ikke-lineære ligninger</h2>

<p>
<!-- FIGURE:[fig-ch2/fig29.png, width=400 frac=1.0]  <div id="fig:229"></div> -->

<p>
Figure <a href="#fig:229">fig:229</a> viser et fluidsjikt med initiell hastighet \( U_1 \)   som strømmer over et annet sjikt med initiell hastighet 
\( U_2 \). Da sjiktene må ha samme hastighet og skjærspenning langs den felles grenseflata, oppstår det et skjærsjikt som vist på figuren. 
For enkelhets skyld antar vi samme fluid i begge sjiktene. Antar dessuten at Blasius ligning beskriver skjærsjiktet.

<p>
For begge sjiktene:

$$
\begin{equation}
f'''(\eta)+f(\eta)\cdot f''(\eta)=0
\label{eq:2421a}
\end{equation}
$$

<p>
med randbetingelser:

$$
\begin{align}
& f(0)=0 \label{eq:2421b} \\ 
&f'(\eta_\infty)=1 \label{eq:2421c} \\ 
&f'(-\eta_\infty)=\frac{U_2}{U_1} \label{eq:2421d}
\end{align}
$$

<p>
Merk her at \( \eta\geq0 \)   for det øvre sjiktet og \( \eta\leq0 \)  for det nedre sjiktet. Vi har definert koordinaten \( \eta \)   og 
strømfunksjonen \( f(\eta) \)  på følgende måte:

$$
\begin{equation} \label{eq:2422}
\left.\begin{matrix}
&\eta=\sqrt{ \frac{U_1}{2\nu x} }\cdot y \\ 
&f'(\eta)=\frac{U(x,y)}{U_1}
\end{matrix}\right.\ 
\end{equation}
$$

<p>
(Sammenlign med lign. (C.2.7), appendiks C, del C.2 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>)

<p>
I dette tilfellet er både hastigheten \( f'(0) \)   og skjærspenningen \( f''(0) \)   ukjente, slik at vi må tippe to initialbetingelser 
når vi skal bruke skyteteknikk.

<p>
Får totalt følgende tre initialbetingelser:

$$
\begin{equation}
f(0)=0,\ f'(0)=r,\ f''(0)=s
\label{eq:2423}
\end{equation}
$$

<p>
De to ukjente initialbetingelsene må velges slik at randbetingelsene \eqref{eq:2421c} og \eqref{eq:2421d} blir oppfylt. Vi skriver dette 
på følgende måte:

$$
\begin{equation}
\phi(\eta_\infty;r,s)=f'(\eta_\infty;r,s)-1=0 \ \text{for}\ s=s^*,\ r=r^*
\label{eq:2424}
\end{equation}
$$


$$
\begin{equation}
\psi(-\eta_\infty;r,s)=f'(-\eta_\infty;r,s)-\frac{U_2}{U_1}=0 \ \text{for}\ s=s^*,\ r=r^*
\label{eq:2425}
\end{equation}
$$

<p>
Istedenfor å bruke negative verdier for \( \eta \)   for det nedre sjiktet, velger vi å innføre koordinaten \( \zeta \)   der \( \zeta=-\eta \). 
Får da følgende system:

<p>
<br />
I. 
For det øvre sjiktet:

$$
\begin{equation}
f'''(\eta)+f(\eta)\cdot f''(\eta)=0
\label{eq:2426a}
\end{equation}
$$

<p>
med rand - og initialbetingelser:

$$
\begin{align}
&f'(\eta_\infty)=1 \label{eq:2426b} \\ 
&f(0)=0,\ f'(0)=r,\ f''(0)=s \label{eq:2426c} \\ 
&\phi(\eta_\infty;r,s)=f'(\eta_\infty;r,s)-1=0 \label{eq:2426d}
\end{align}
$$

<p>
<br />
II. 
For det nedre sjiktet:

$$
\begin{equation}
f'''(\zeta)-f(\zeta)\cdot f''(\zeta)=0
\label{eq:2427a}
\end{equation}
$$

<p>
med rand - og initialbetingelser:

$$
\begin{align}
&f'(\zeta_\infty)=-\frac{U_2}{U_1} \label{eq:2427b} \\ 
&f(0)=0,\ f'(0)=-r,\ f''(0)=s \label{eq:2427c} \\ 
&\psi(\zeta_\infty;r,s)=f'(\zeta_\infty;r,s)+\frac{U_2}{U_1}=0 \label{eq:2427d}
\end{align}
$$

<p>
Merk at derivasjon er m. h. p. koordinaten \( \zeta \)  i det nedre sjiktet.

<p>
Da \( \zeta=-\eta \), får vi for eksempel:

$$
\begin{equation*}
\frac{df(\zeta)}{d\zeta}=\frac{df(\eta)}{d\eta}\cdot \frac{d\eta}{d\zeta}=\frac{df(\eta)}{d\eta}\cdot(-1)=-\frac{df(\eta)}{d\eta}
\end{equation*}
$$

<p>
Oppgava blir da å løse \eqref{eq:2426a}, \eqref{eq:2426c} og \eqref{eq:2426d} simultant med \eqref{eq:2427a}, \eqref{eq:2427c} og 
\eqref{eq:2427d}. Dette betyr at vi må finne verdier av \( r \) og \( s \) slik at \eqref{eq:2426d} og \eqref{eq:2427d} er tilfredstilt. Dette 
må gjøres for alle aktuelle verdier av \( \dfrac{U_2}{U_1} \)  der \( \dfrac{U_2}{U_1}  \in[0,1] \).

<p>
Vi har da det gamle problemet med å finne gode nok startverdier for \( r \) og \( s \) når vi skal beregne nullpunktene av  \eqref{eq:2426d} og  
\eqref{eq:2427d}. Vi går fram som tidligere ved å beregne \( \phi(\eta_\infty;r,s) \) og \( \psi(\zeta_\infty;r,s) \)  for passende verdier 
av \( \eta_\infty,\ \zeta_\infty,\ r \) og \( s \) og deretter tegne funksjonene. La oss se nærmere på framgangsmåten. %<doc>%</doc>

<p>
<!-- FIGURE:[fig-ch2/fig30.png, width=400] <div id="fig:230"></div> -->

<p>
Vi skal finne de verdiene av \( r \) og \( s \) som er nullpunkter både i \eqref{eq:2426d} og \eqref{eq:2427d}. Fra Figure <a href="#fig:230">fig:230</a> ser vi 
at dette er punktet \( (r^*,s^*) \). Velger verdier for \( \eta_\infty \) og \( \zeta_\infty \)  slik at \( \phi \) og \( \psi \)  bare er funksjoner 
av \( r \) og \( s \):

$$
\begin{equation} \label{eq:2428}
\left.\begin{matrix}
&\phi(r^*,s^*)=0 \\ 
&\psi(r^*,s^*)=0
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Velger så en verdi \( s=s_0 \), se Figure <a href="#fig:230">fig:230</a>. Setter deretter \( r=r_0 \)   og beregner verdiene av \( \phi \) og \( \psi \)  langs  linja \( s=s_0 \)  
med varierende \( r \). Med henvisning til figuren ovenfor, får vi fortløpende:

$$
\begin{equation*}
\psi(r_0,s_0)\cdot\psi(r_1,s_0) > 0,\ \psi(r_1,s_0)\cdot \psi(r_2,s_0) > 0,\ \psi(r_2,s_0)\cdot \psi(r_3,s_0) < 0
\end{equation*}
$$

<p>
Den negative verdien av \( \psi(r_2,s_0)\cdot \psi(r_3,s_0) \)  betyr at vi har en rot av \( \psi(r,s_0) \)  mellom \( r_2 \) og \( r_3 \). Denne rota 
som er merket med \( 1 \) på figuren, kan finnes med en endimensjonal nullpunktsløser siden \( \psi \)  nå bare er funksjon av \( r \). Ved å gå videre 
langs \( s=s_0 \), finner vi nullpunktet \( 2 \) av \( \phi \)  på samme måten. Deretter begynner vi på ny s-verdi med \( s_1=s_0+\Delta s \)  og finner 
nullpunktene langs  \( s_1 \)- linja. Tilslutt har vi beregnet alle nullpunktene merket med en ring på figuren. Dermed kan vi finne en god 
tilnærmelse \( (\bar{r},\bar{s}) \)  til det korrekte nullpunktet \( (r^*,s^*) \) . Med disse tilnæringsverdiene for nullpunktene, kan vi nå løse 
\eqref{eq:2428} ved for eks. å bruke en todimensjonal versjon av Newton-Raphsons metode, se avsnitt 14.2 i C&amp;K <a href="#cheney1999numerical">[7]</a>.
Figure <a href="#fig:230">fig:230</a> gjelder for en bestemt verdi av \( \alpha=\frac{U_2}{U_1} \)   slik at vi i prinsippet må gjenta søkeprosedyren for hver 
verdi av \( \alpha \). I praksis er dette sjelden nødvendig, da verdien av  \( (\bar{r},\bar{s}) \)   for en  $\alpha$–verdi vanligvis kan brukes 
til å finne \( (r^*,s^*) \)  for en nærliggende verdi av \( \alpha \). Prosedyren ovenfor gir følgende tabell for \( (r^*,s^*) \)  som funksjon av 
\( \frac{U_2}{U_1} \):

<p>

<div class="row">
  <div class="col-xs-4">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( \frac{U_2}{U_1} \)</td> <td align="center">\( r^* \)</td> <td align="center">\( s^* \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   0.0                      </td> <td align="center">   0.583776     </td> <td align="center">   0.284447     </td> </tr>
<tr><td align="center">   0.1                      </td> <td align="center">   0.613568     </td> <td align="center">   0.267522     </td> </tr>
<tr><td align="center">   0.2                      </td> <td align="center">   0.646947     </td> <td align="center">   0.247879     </td> </tr>
<tr><td align="center">   0.3                      </td> <td align="center">   0.683594     </td> <td align="center">   0.225504     </td> </tr>
<tr><td align="center">   0.4                      </td> <td align="center">   0.723101     </td> <td align="center">   0.200460     </td> </tr>
<tr><td align="center">   0.5                      </td> <td align="center">   0.765049     </td> <td align="center">   0.172847     </td> </tr>
<tr><td align="center">   0.6                      </td> <td align="center">   0.809060     </td> <td align="center">   0.142779     </td> </tr>
<tr><td align="center">   0.7                      </td> <td align="center">   0.854807     </td> <td align="center">   0.110363     </td> </tr>
<tr><td align="center">   0.8                      </td> <td align="center">   0.902021     </td> <td align="center">   0.075701     </td> </tr>
<tr><td align="center">   0.9                      </td> <td align="center">   0.950480     </td> <td align="center">   0.038886     </td> </tr>
<tr><td align="center">   1.0                      </td> <td align="center">   1.000000     </td> <td align="center">   0.000000     </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-4 -->
<p>
Med \( \alpha=\frac{U_2}{U_1} \)   finner vi følgende kurvetilpasninger for \( r^* \) og \( s^* \)   fra tabellen:

$$
\begin{equation} \label{eq:2429}
\left.\begin{matrix}
&r^*\approx\bar{r}=0.1076\cdot\alpha^2+0.3086\cdot\alpha+0.5838 \\ 
&s^*\approx\bar{s}=-0.1224\cdot\alpha^2-0.1620\cdot\alpha+0.2844
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Istedenfor denne litt omstendelige fremgangsmåten, kan du forsøke
programmet <b>fsolve</b> fra Matlabs Optimization Toolbox. 
<!-- begin inline comment -->
<font color="red">(<b>Marie 8</b>: Henviser til Matlab)</font>
<!-- end inline comment -->

<p>
<!-- !split -->

<center><h1 id="ch:3">Differansemetoder for ordinære differensialligninger</h1></center> <!-- chapter heading -->

<h1 id="ch3:sec1">Tridiagonale algebraiske ligningsystem</h1>

<p>
Differansemetoder anvendt på både ordinaere og partielle differensialligninger gir vanligvis algebraiske ligningsystem med utpreget 
bandstruktur. Ved 2. ordens differensialligninger består ofte koeffisientmatrisa for ligningsystemet av tre diagonaler: 
En hoveddiagonal med en diagonal på hver side av denne. En slik matrise kalles tridiagonal. Et linæert, algebraisk ligningsystem med 
tridiagonal koeffisientmatrise kan skrives på formen:

$$
\begin{equation} \label{eq:3101}
\begin{array}{l}
b_1 x_1 + c_1 x_2  =  d_1\\ 
\ \ \ \ \ \ \ \ \ \ \ \ \cdots \\ 
a_i x_{i-1} + b_i x_i +c_i x_{i+1}  = d_i\\ 
\ \ \ \ \ \ \ \ \ \ \ \ \cdots \\ 
a_N x_{N-1} + b_N x_N = d_N\\ 
i = 1,2,...N \ , a_1 = c_N = 0
\end{array}
\end{equation}
$$

<p>
eller på matriseform:

$$
\begin{equation} \label{eq:3102}
\begin{bmatrix}
b_1 & c_1   &       &       &       &       &         &         &  \\ 
a_2 & b_2   & c_2   &       &       &       &         &         &  \\ 
    & \cdot & \cdot & \cdot &       &       &         &         &  \\ 
    &       & \cdot & \cdot & \cdot &       &         &         &  \\ 
    &       &       & \cdot & \cdot & \cdot &         &         & \\ 
    &       &       &       &       &       & a_{N-1} & b_{N-1} &c_{N-1} \\ 
    &       &       &       &       &       &         & a_N     & b_N
\end{bmatrix}
\cdot
\begin{bmatrix}
x_1 \\ 
x_2 \\ 
\cdot \\ 
\cdot \\ 
\cdot \\ 
x_{N-1} \\ 
x_N
\end{bmatrix}
=
\begin{bmatrix}
d_1 \\ 
d_2 \\ 
\cdot \\ 
\cdot \\ 
\cdot \\ 
d_{N-1} \\ 
d_N
\end{bmatrix}
\end{equation}
$$

<p>
\eqref{eq:3101} kan løses ved Gauss-eliminasjon som for tridiagonale matriser blir en enkel algoritme, ofte kalt Thomas-algoritmen.En detaljert utledning 
er gitt i  appendiks I i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>.

<p>
Eliminering:

$$
\begin{equation} \label{eq:3103}
\begin{array}{l}
\text{Utfør for } j = 2,3\cdots,N \: \ q_j:=\frac{a_j}{b_{j-1}}\\ 
\text{Beregn:  } b_j:= b_j - q_j \cdot c_{j-1}, \quad d_j:= d_j - q_j \cdot d_{j-1}
\end{array}
\end{equation}
$$

<p>
Innsetting:

$$
\begin{equation*}
\begin{array}{l}
\text{Sett } x_N:=\frac{d_N}{b_N}\\ 
\text{Utfør for } j = N-1, N-2, \cdots,1 \: \ x_j: \frac{d_j - c_j \cdot x_{j+1}}{b_j}
\end{array}
\end{equation*}
$$

<p>
\eqref{eq:3103} er implementert i subprogrammet <b>tdma</b> som tilsvarer prosedyren <b>tri</b> i C&amp;K <a href="#cheney1999numerical">[7]</a> , avsnitt 6.3. Programmet
tdma er vist under: <div id="tdma"></div>

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">function x = tdma(a,b,c,d)
#  Solution of a tridiagonal matrix 
#  using the Thomas-algorithm.
#  No. of equations are given by the length
#  of the main diagonal b
n = length(b);
x = zeros(size(b));
#  === Elimination ===

for k = 2:n
   q = a(k)/b(k-1);
   b(k) = b(k) - c(k-1)*q;
   d(k) = d(k) - d(k-1)*q;
end
#  === Backsubstitution ===

q = d(n)/b(n);
x(n) = q;
for k = n-1:-1:1
   q = (d(k) - c(k)*q)/b(k);
   x(k) = q;
end
</pre></div>
<p>
Merk at (<a href="#tdma">tdma</a>) ikke bruker \( a(1) \) og \( c(n) \).

<p>
\eqref{eq:3103} er sikker numerisk stabil dersom følgende betingelser er oppfylt:

$$
\begin{equation} \label{eq:3104}
\begin{array}{l}
\mid b_1 \mid > \mid c_1 \mid > 0\\ 
\mid b_i \mid \ge \mid a_i \mid + \mid c_i \mid, a_i \cdot c_i \neq 0 \ , i = 2, 3, \cdots, N-1\\ 
\mid b_n \mid > \mid a_N\mid > 0
\end{array}
\end{equation}
$$

<p>
Matriser som oppfyller \eqref{eq:3104} , kalles diagonaldominante. Dersom vi bare har ulikhetstegn i \eqref{eq:3104}, betegnes dette som streng 
diagonaldominans. For diagonal-dominante matriser behøves ikke pivotering ved Gauss-eliminasjon.

<p>
Dette sparer tid samtidig som bandstrukturen beholdes. Bevis av\eqref{eq:3104} er gitt i appendiks I i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>.

<p>
Legg merke til at i matrisa \eqref{eq:3102}  har koeffisientene i hver linje samme indeks. Ligningsystemet i \eqref{eq:3101} kan også skrives:

$$
\begin{equation} \label{eq:3105}
\begin{array}{l}
b_1 x_1 + c_2 x_2  =  d_1\\ 
 \ \ \ \ \ \ \ \ \ \cdots \\ 
a_{i-1} x_{i-1} + b_i x_i + c_{i+1} x_{i+1}  = d_i\\ 
 \ \ \ \ \ \ \ \ \ \cdots \\ 
a_{N-1} x_{N-1} + b_N x_N = d_N\\\\ 
i = 1,2,...N \ , a_1 = c_N = 0
\end{array}
\end{equation}
$$

<p>
eller på matriseform:

$$
\begin{equation} \label{eq:3106}
\begin{bmatrix}
b_1 & c_2 & & & & & & & \\ 
a_1 & b_2 & c_3 & & & & & & \\ 
 & \cdot & \cdot & \cdot & & & & & \\ 
 & & \cdot & \cdot & \cdot & & & & \\ 
 & & & \cdot& \cdot & \cdot & & & \\ 
 & & & & & & a_{N-2} & b_{N-1} & c_{N} \\ 
 & & & & & & & a_{N-1} & b_N
\end{bmatrix}
\cdot
\begin{bmatrix}
x_1 \\ 
x_2 \\ 
\cdot \\ 
\cdot \\ 
\cdot \\ 
x_{N-1} \\ 
x_N
\end{bmatrix}
=
\begin{bmatrix}
d_1 \\ 
d_2 \\ 
\cdot \\ 
\cdot \\ 
\cdot \\ 
d_{N-1} \\ 
d_N
\end{bmatrix}
\end{equation}
$$

<p>
Legg merke til at i matrisa \eqref{eq:3106}  har koeffisientene i hver <em>kolonne</em> samme indeks.

<p>
Versjonen i \eqref{eq:3106} fås enkelt fra \eqref{eq:3102} ved å trekke 1 fra \( a \)-indeksene og addere 1 til \( c \)-indeksene. Matlab lagrer tridiagonale 
matriser på formen \eqref{eq:3106}.

<p>
(Se avsnittet <em>Glisne matriser</em> i Matlabelfsa ).

<p>
\eqref{eq:3106} er programmert i funksjonen <b>tridiag</b>.

<p>
Av gammel vane bruker vi vanligvis funksjonen <b>tdma</b> i kurset. Dersom betingelsene i \eqref{eq:3104} ikke er oppfylt, kan f.eks. <b>tripiv</b> brukes.  
(Se appendiks I i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>). I appendiks
A, del A.5, står det mer om løsningsnøyaktigheten for lineæreligningsystem, spesielt tridiagonale system.

<p>
<!-- !split -->

<h1 id="ch3:sec2">Varmeledning</h1>

<h2 id="ch3:sec21">Kjøleribbe med konstant tverrsnitt</h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 39:  <div id="fig:31"></div> </p></center>
<p><img src="fig-ch3/fig1.png" align="bottom" width=400></p>
</center>

<p>
Figure <a href="#fig:31">39</a> viser en sirkulærsylindrisk stav med lengde <em>L</em>, omgivelsestemperatur \( T_{\infty} \) og en konstant temperatur \( T_r \) for $ X = L$.

<p>
Andre data:  \( \bar{h} = 100 W/m^{2 \ \circ}C \), \( k = 200 W/m/^\circ C \)

<p>
Fra ligning  (B.0.22), appendiks B i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>:

$$
\begin{equation} \label{eq:3211}
\frac{d}{dX} \left[A(X) \cdot \frac{d(T - T_{\infty}}{dX} \right] = \dfrac{\bar{h}P}{k}(T-T_\infty)
\end{equation}
$$

<p>
For konstant tverrsnitt:

$$
\begin{equation} \label{eq:3212}
\frac{d^2}{dX^2}(T - T_{\infty}) = \frac{\bar{h}P}{kA}(T- T_{\infty})
\end{equation}
$$

<p>
Innfører dimensjonsløse variable:

$$
\begin{equation} \label{eq:3213}
x = \frac{X}{L} \ ,\ \theta = \frac{T - T_{\infty}}{T_r - T_{\infty}}\ ,\ \beta^2 = \frac{\bar{h}P}{kA}L^2
\end{equation}
$$

<p>
der <em>x</em> er en dimensjonsløs lengde (se figur B.5 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>) og \( \theta \)  en dimensjonsløs temperatur. Temperaturen 
\( T_r \) er en referansetemperatur. Parameteren \( \beta^2 \) kalles ofte Biot-tallet. ( Vanlig betegnelse for Biot-tallet er \( Bi \) der \( Bi=\beta^2 \) ).

<p>
Lign. \eqref{eq:3211} kan nå skrives:

$$
\begin{equation} \label{eq:3214}
\frac{d^2 \theta}{dx^2}-\beta^2\theta = 0
\end{equation}
$$

<p>
med analytisk løsning:

$$
\begin{equation} \label{eq:3215}
\theta(x) = A\sinh(\beta x)= - B\cosh(\beta x)
\end{equation}
$$

<p>
der konstantene A og B bestemmes fra randbetingelsene.

<p>
Ser på et tilfelle med følgende to sett av randbetingelser:

<p>
I)

$$
\begin{equation*}
T = T_{\infty} \text{ for } X = 0 \ , \ T = T_ r \text{ for } X = L
\end{equation*}
$$

<p>
II)

$$
\begin{equation*}
Q_x = 0 = \frac{dT}{dX} \text{ for } X = 0 \ , \ T = T_r \text{ for } X = L
\end{equation*}
$$

<p>
Tilfelle II betyr at staven er isolert for \( X = 0 \)

<p>
Randbetingelsene på dimensjonsløs form:

<p>
I)

$$
\begin{equation} \label{eq:3216a}
\theta = 0 \text{ for } x = 0 \ , \ \theta = 1 \text{ for } x = 1 
\end{equation}
$$

<p>
II)

$$
\begin{equation} \label{eq:3216b}
\frac{d \theta}{dx}=0 \text{ for } x = 0 \ , \ \theta = 1 \text{ for } x = 1
\end{equation}
$$

<p>
Randbetingelsene i \eqref{eq:3216a} og \eqref{eq:3216b}  gir følgende uttrykk for temperatur  og temperaturgradient:

<p>
I)

$$
\begin{equation} \label{eq:3217a}
\theta(x) = \frac{\sinh(\beta x)}{\sinh(\beta)} \ , \ \frac{d \theta}{dx} = \beta \cdot \frac{\cosh (\beta x)}{\sinh(\beta)}
\end{equation}
$$

<p>
II)

$$
\begin{equation} \label{eq:3217b}
\theta(x) = \frac{\cosh(\beta x)}{\cosh(\beta)} \ , \ \frac{d \theta}{dx} = \beta \cdot \frac{\sinh(\beta x)}{\cosh(\beta)}
\end{equation}
$$

<p>
For eksemplet ovenfor blir Biot-tallet:

$$
\begin{equation} \label{eq:3218}
\beta^2 = \frac{\bar{h}P}{kA} \cdot L^2 = \frac{2}{D} \cdot L^2 \ , \ L \text{ og } D \text{ i meter}
\end{equation}
$$

<p>
Men \( D = 0.02m \) og \( L = 0.2m \) blir f.eks. \( \beta^2 = 4 \). En fordobling av lengden gir en 4-dobling av Biot-tallet.

<p>
<br />

<p>
<b>Numerisk løsning</b>

<p>
Vi bruker sentraldifferanser for \( \dfrac{d^2 \theta}{dx^2} \), og med 
\( \dfrac{d^2 \theta}{dx^2}\bigg|_i \approx \dfrac{\theta_{i-1} - 2\theta_i + \theta_{i+1}}{h^2} \) får vi følgende differanseligning:

$$
\begin{equation} \label{eq:3219}
\theta_{i-1}-(2+\beta^2 h^2 ) \cdot \theta_i + \theta_{i+1} = 0
\end{equation}
$$

<p>
<b>Tilfelle 1</b> <div id="kt3211_1"></div>

<p>
Vi nummererer punktene som vist på Figure <a href="#fig:32a">40</a>:

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 40:  <div id="fig:32a"></div> </p></center>
<p><img src="fig-ch3/fig2.png" align="bottom" width=400></p>
</center>

<p>
x-koordinatene er her gitt ved: \( x_i = i \cdot h \) , \( i = 0,1,...,N+1 \) der \( h = \frac{1}{N+1} \).

<p>
Ligning \eqref{eq:3219} utskrevet for \( i=1 \):

$$
\begin{equation*}
\theta_0 - (2 + \beta^2h^2) \cdot \theta_1 + \theta_2 = 0 \to (2+\beta^2h^2)\cdot\theta_1 + \theta_2 = 0
\end{equation*}
$$

<p>
da \( \theta(0) = \theta_0 = 0 \)

<p>
Ligning \eqref{eq:3219} utskrevet for \( i = N \):

$$
\begin{equation*}
\theta_{N-1} - (2 + \beta^2h^2)\cdot\theta_N + \theta_{N+1} = 0
\end{equation*}
$$

<p>
som med \( \theta_{N+1} = 1 \) gir:

$$
\begin{equation*}
\theta_{N-1} - (2 + \beta^2h^2)\cdot\theta_N = -1
\end{equation*}
$$

<p>
Fullstendig ligningsett:

$$
\begin{align} 
i = 1:& \ \ -(2 + \beta^2h^2)\cdot \theta_1 + \theta_2 = 0 \nonumber \\ 
i = 2,3,...,N-1:& \ \ \theta_{i-1} - (2 + \beta^2h^2)\cdot \theta_i + \theta_{i+1} = 0label{eq:32110}\\ 
i = N:& \ \ \theta_{N-1} - (2 + \beta^2h^2)\cdot \theta_N = -1 \nonumber \\ 
\label{_auto37}
\end{align}
$$

<p>
I appendiks A, del A.5, eksempel A.15 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>, er dette systemet behandlet mer inngående.

<p>
Ved å sammenligne med \eqref{eq:3101}, får vi følgende sett med koeffisienter:

$$
\begin{align}
a_i = 1 \ , \ i = 2,3,...,N \label{eq:32111a}\\ 
b_i = -(2+ \beta^2h^2) \ , i = 1,2,...,N \label{eq:32111b}\\ 
c_i = 1 \ , \ i = 1,2,...,N-1 \label{eq:32111c}\\ 
d_i = 0 \ , \ i = 1,2,...,N-1 \ , \ d_N = -1 \label{eq:32111d}
\end{align}
$$

<p>
Programmet <b>ribbe1</b> nedenfor bruker koeffisientene i \eqref{eq:32111a} og løser systemet med bruk av <b>tdma</b> . Den analytiske løsningen er gitt i 
\eqref{eq:3217a}. Minner om at <b>tdma</b> ikke bruker \( a_1 \) og \( c_N \).

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sc</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.linalg</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse.linalg</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sinh

<span style="color: #408080; font-style: italic">#import matplotlib.pyplot as plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #408080; font-style: italic"># Change some default values to make plots more readable on the screen</span>
LNWDT<span style="color: #666666">=3</span>; FNT<span style="color: #666666">=20</span>
matplotlib<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; matplotlib<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT

<span style="color: #408080; font-style: italic"># Set simulation parameters</span>
beta <span style="color: #666666">=</span> <span style="color: #666666">5.0</span>
h <span style="color: #666666">=</span> <span style="color: #666666">0.001</span>               <span style="color: #408080; font-style: italic"># element size</span>
L <span style="color: #666666">=1.0</span>                  <span style="color: #408080; font-style: italic"># length of domain</span>
n <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(L<span style="color: #666666">/</span>h)) <span style="color: #666666">-1</span>  <span style="color: #408080; font-style: italic"># number of unknowns, assuming known boundary values</span>
x<span style="color: #666666">=</span>np<span style="color: #666666">.</span>arange(n<span style="color: #666666">+2</span>)<span style="color: #666666">*</span>h      <span style="color: #408080; font-style: italic"># x includes min and max at boundaries were bc are imposed.</span>


<span style="color: #408080; font-style: italic">#Define useful functions</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">tri_diag_setup</span>(a, b, c, k1<span style="color: #666666">=-1</span>, k2<span style="color: #666666">=0</span>, k3<span style="color: #666666">=1</span>):
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>diag(a, k1) <span style="color: #666666">+</span> np<span style="color: #666666">.</span>diag(b, k2) <span style="color: #666666">+</span> np<span style="color: #666666">.</span>diag(c, k3)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">theta_analytical</span>(beta,x):
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>sinh(beta<span style="color: #666666">*</span>x)<span style="color: #666666">/</span>np<span style="color: #666666">.</span>sinh(beta)

<span style="color: #408080; font-style: italic">#Create matrix for linalg solver</span>
a<span style="color: #666666">=</span>np<span style="color: #666666">.</span>ones(n<span style="color: #666666">-1</span>)
b<span style="color: #666666">=-</span>np<span style="color: #666666">.</span>ones(n)<span style="color: #666666">*</span>(<span style="color: #666666">2+</span>(beta<span style="color: #666666">*</span>h)<span style="color: #666666">**2</span>)
c<span style="color: #666666">=</span>a
A<span style="color: #666666">=</span>tri_diag_setup(a,b,c)

<span style="color: #408080; font-style: italic">#Create matrix for sparse solver</span>
diagonals<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros((<span style="color: #666666">3</span>,n))
diagonals[<span style="color: #666666">0</span>,:]<span style="color: #666666">=</span> <span style="color: #666666">1</span>                       <span style="color: #408080; font-style: italic">#all elts in first row is set to 1</span>
diagonals[<span style="color: #666666">1</span>,:]<span style="color: #666666">=</span> <span style="color: #666666">-</span>(<span style="color: #666666">2+</span>(beta<span style="color: #666666">*</span>h)<span style="color: #666666">**2</span>)  
diagonals[<span style="color: #666666">2</span>,:]<span style="color: #666666">=</span> <span style="color: #666666">1</span> 
A_sparse <span style="color: #666666">=</span> sc<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>spdiags(diagonals, [<span style="color: #666666">-1</span>,<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], n, n,format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csc&#39;</span>) <span style="color: #408080; font-style: italic">#sparse matrix instance</span>

<span style="color: #408080; font-style: italic">#Crete rhs array</span>
d<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(n)
d[n<span style="color: #666666">-1</span>]<span style="color: #666666">=-1</span>

<span style="color: #408080; font-style: italic">#Solve linear problems</span>
tic<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
theta <span style="color: #666666">=</span> sc<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A_sparse,d) <span style="color: #408080; font-style: italic">#theta=sc.linalg.solve_triangular(A,d)</span>
toc<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;sparse solver time:&#39;</span>,toc<span style="color: #666666">-</span>tic

tic<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
theta2<span style="color: #666666">=</span>sc<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A,d,)
toc<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;linalg solver time:&#39;</span>,toc<span style="color: #666666">-</span>tic

<span style="color: #408080; font-style: italic"># Plot solutions</span>
plot(x[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>],theta,x[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>],theta2,<span style="color: #BA2121">&#39;-.&#39;</span>,x,theta_analytical(beta,x),<span style="color: #BA2121">&#39;:&#39;</span>)
legend([<span style="color: #BA2121">&#39;sparse&#39;</span>,<span style="color: #BA2121">&#39;linalg&#39;</span>,<span style="color: #BA2121">&#39;analytical&#39;</span>])
show()
close()
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;done&#39;</span>
</pre></div>
<p>
Resultatene i tabell:

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="left"><b> x </b></td> <td align="left"><b>numerisk</b></td> <td align="left"><b>analytisk</b></td> <td align="left"><b>rel. feil</b></td> </tr>
</thead>
<tbody>
<tr><td align="left">   0.0    </td> <td align="left">   0.00000     </td> <td align="left">   0.00000      </td> <td align="left">                </td> </tr>
<tr><td align="left">   0.1    </td> <td align="left">   0.05561     </td> <td align="left">   0.05551      </td> <td align="left">   0.00176      </td> </tr>
<tr><td align="left">   0.2    </td> <td align="left">   0.11344     </td> <td align="left">   0.11325      </td> <td align="left">   0.00170      </td> </tr>
<tr><td align="left">   0.3    </td> <td align="left">   0.17582     </td> <td align="left">   0.17554      </td> <td align="left">   0.00159      </td> </tr>
<tr><td align="left">   0.4    </td> <td align="left">   0.24522     </td> <td align="left">   0.24487      </td> <td align="left">   0.00144      </td> </tr>
<tr><td align="left">   0.5    </td> <td align="left">   0.32444     </td> <td align="left">   0.32403      </td> <td align="left">   0.00126      </td> </tr>
<tr><td align="left">   0.6    </td> <td align="left">   0.41663     </td> <td align="left">   0.41619      </td> <td align="left">   0.00105      </td> </tr>
<tr><td align="left">   0.7    </td> <td align="left">   0.52548     </td> <td align="left">   0.52506      </td> <td align="left">   0.00082      </td> </tr>
<tr><td align="left">   0.8    </td> <td align="left">   0.65536     </td> <td align="left">   0.65499      </td> <td align="left">   0.00056      </td> </tr>
<tr><td align="left">   0.9    </td> <td align="left">   0.81145     </td> <td align="left">   0.81122      </td> <td align="left">   0.00029      </td> </tr>
<tr><td align="left">   1.0    </td> <td align="left">   1.00000     </td> <td align="left">   1.00000      </td> <td align="left">   0.00000      </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-3 -->
<p>
<b>Tilfelle 2.  Versjon 1</b> <div id="kt3212_1"></div>

<p>
Vi nummererer nå punktene som vist på fig. (<a href="#fig:32b">41</a>). Årsaken er at programmet <b>tdma</b> venter at den første ukjente har nummer 1, og her er det 
temperaturen i \( x = 0 \) som er den første ukjente, mens vi i tilfelle 1 hadde den første ukjente for  \( x = h \). (Det er egenltig ikke nødvendig å 
omnummerere)

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 41:  <div id="fig:32b"></div> </p></center>
<p><img src="fig-ch3/fig3.png" align="bottom" width=400></p>
</center>

<p>
x-koordinatene er nå gitt ved: \( x_i = (i -1) \cdot h, \ i = 1,2,...,N+1 \) der \( h = \frac{1}{N} \) Bruker her sentraldifferanser for \( \frac{d\theta}{dx} \) i 
forbindelse med randbetingelsen \( x = 0 \)

$$
\begin{equation} \label{eq:32112}
\frac{d\theta}{dx}\bigg|_i \approx \frac{\theta_{i+1}-\theta_{i-1}}{2h}
\end{equation}
$$

<p>
Da \( \frac{d\theta_1}{dx_1} = 0 \): \( \frac{\theta_2 - \theta_0}{2h}= 0 \to \theta_0 = \theta_2 \) som insatt i \eqref{eq:3219} gir:

$$
\begin{equation*}
-(2+\beta^2h^2)\cdot \theta_1 + 2\theta_2 = 0
\end{equation*}
$$

<p>
Dette er den første ligningen i settet og er den eneste som er forskjellig fra \eqref{eq:32110}. Istedenfor \eqref{eq:32111c} , får vi nå:

$$
\begin{equation} \label{eq:32113}
c_1 = 2, \ c_i = 1, \ i = 2,...N-1
\end{equation}
$$

<p>
<b>Tilfelle 2.  Versjon 2</b> <div id="kt3212_2"></div>

<p>
Istedenfor sentraldifferanser, bruker vi foroverdifferanser gitt ved lign. \eqref{eq:3219}  i kap. 1 for den deriverte:

$$
\begin{equation} \label{eq:32114}
\frac{d\theta}{dx}\bigg|_i \approx \frac{-3\theta_i + 4\theta_{i+1} - \theta_{i+2}}{2h}
\end{equation}
$$


$$
\begin{equation*}
\frac{d\theta}{dx}\bigg|_1 = \frac{-3\theta_1 + 4\theta_2 - \theta_3}{2h} = 0
\end{equation*}
$$

<p>
som videre gir: \( -3 \theta_1 + 4 \theta_2 - \theta_3 = 0 \to \theta_3 = 4\theta_2 - 3\theta_1 \)

<p>
Differanseligningen \eqref{eq:3219} utskrevet for \( i=2 \):

$$
\begin{equation*}
\theta_1 - (2+\beta^2h^2)\cdot \theta_2 + \theta_3 = 0
\end{equation*}
$$

<p>
innsatt for \( \theta_3 \):

$$
\begin{equation*}
\theta_1 - (2 + \beta^2h^2)\cdot \theta_2 + 4\theta_2 - 3\theta_1 = 0 \to
\end{equation*}
$$


$$
\begin{equation} \label{eq:32115}
2\theta_1 - (2 + \beta^2h^2)\cdot\theta_2 = 0
\end{equation}
$$

<p>
Dette er den første ligningen i settet og er den eneste som er forskjellig fra \eqref{eq:32110}. Istedenfor \eqref{eq:32111b} og \eqref{eq:32111c} , får 
vi nå:

$$
\begin{equation} \label{eq:32116a}
b_1 = 2\ , \ b_i = (2+\beta^2h^2) \ , \ i = 2,...,N
\end{equation}
$$


$$
\begin{equation} \label{eq:32116b}
c_1 = -(2-\beta^2 h^2) \ , \ c_i = 1 \ , \ i = 2,...,N-1
\end{equation}
$$

<p>
For oversiktens skyld skriver vi opp hele settet:

$$
\begin{align} \label{eq:32117}
i = 1:& \ \ 2\theta_1 -(2-\beta^2h^2)\cdot \theta_2 = 0 \nonumber \\ 
i = 2,3,...,N-1:& \ \ \theta_{i-1}-(2+\beta^2h^2)\cdot\theta_i + \theta_{i+1} = 0
\label{_auto38}\\ 
i = N:& \ \ \theta_{N-1} - (2+\beta^2h^2)\cdot \theta_N = -1 \nonumber
\end{align}
$$

<p>
Legg merke til at vi her måtte kombinere uttrykket for den deriverte med differanseligningen for å få en tridiagonal koeffisientmatrise.  Løser de to 
versjonene med \( \beta = 2 \) og \( h=0.1 \). Nedenfor er programmet <b>ribbe2</b> som løser tilfelle 2 med begge versjonene.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sc</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.linalg</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse.linalg</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> cosh

<span style="color: #408080; font-style: italic">#import matplotlib.pyplot as plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #408080; font-style: italic"># Change some default values to make plots more readable on the screen</span>
LNWDT<span style="color: #666666">=3</span>; FNT<span style="color: #666666">=20</span>
matplotlib<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; matplotlib<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT

<span style="color: #408080; font-style: italic"># Set simulation parameters</span>
beta <span style="color: #666666">=</span> <span style="color: #666666">3.0</span>
h <span style="color: #666666">=</span> <span style="color: #666666">0.001</span>               <span style="color: #408080; font-style: italic"># element size</span>
L <span style="color: #666666">=1.0</span>               <span style="color: #408080; font-style: italic"># length of domain</span>
n <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(L<span style="color: #666666">/</span>h))  <span style="color: #408080; font-style: italic"># # of unknowns, assuming known bndry values at outlet</span>
x<span style="color: #666666">=</span>np<span style="color: #666666">.</span>arange(n<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>h      <span style="color: #408080; font-style: italic"># x includes min and max at boundaries were bc are imposed.</span>


<span style="color: #408080; font-style: italic">#Define useful functions</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">tri_diag_setup</span>(a, b, c, k1<span style="color: #666666">=-1</span>, k2<span style="color: #666666">=0</span>, k3<span style="color: #666666">=1</span>):
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>diag(a, k1) <span style="color: #666666">+</span> np<span style="color: #666666">.</span>diag(b, k2) <span style="color: #666666">+</span> np<span style="color: #666666">.</span>diag(c, k3)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">theta_analytical</span>(beta,x):
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>cosh(beta<span style="color: #666666">*</span>x)<span style="color: #666666">/</span>np<span style="color: #666666">.</span>cosh(beta)

<span style="color: #408080; font-style: italic">#Create matrix for linalg solver</span>
a<span style="color: #666666">=</span>np<span style="color: #666666">.</span>ones(n<span style="color: #666666">-1</span>)                  <span style="color: #408080; font-style: italic"># sub-diagonal</span>
b<span style="color: #666666">=-</span>np<span style="color: #666666">.</span>ones(n)<span style="color: #666666">*</span>(<span style="color: #666666">2+</span>(beta<span style="color: #666666">*</span>h)<span style="color: #666666">**2</span>)   <span style="color: #408080; font-style: italic"># diagonal</span>
c<span style="color: #666666">=</span>np<span style="color: #666666">.</span>ones(n<span style="color: #666666">-1</span>)                  <span style="color: #408080; font-style: italic"># sub-diagonal</span>
<span style="color: #408080; font-style: italic">#c=a.copy()                      # super-diagl, copy as elts are modified later</span>
<span style="color: #408080; font-style: italic">#c=a</span>
<span style="color: #408080; font-style: italic"># particular diagonal values due to derivative bc</span>
version1<span style="color: #666666">=1</span>
<span style="color: #008000; font-weight: bold">if</span> (version1<span style="color: #666666">==1</span>):
    c[<span style="color: #666666">0</span>]<span style="color: #666666">=2.0</span>
<span style="color: #008000; font-weight: bold">else</span>:      
    b[<span style="color: #666666">0</span>]<span style="color: #666666">=2.0</span>
    c[<span style="color: #666666">0</span>]<span style="color: #666666">=-</span>(<span style="color: #666666">2-</span>(beta<span style="color: #666666">*</span>h)<span style="color: #666666">**2</span>)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;version 2&#39;</span> 
                     
A<span style="color: #666666">=</span>tri_diag_setup(a,b,c)

<span style="color: #408080; font-style: italic">#Create matrix for sparse solver</span>
diagonals<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros((<span style="color: #666666">3</span>,n))
diagonals[<span style="color: #666666">0</span>,:]<span style="color: #666666">=</span> <span style="color: #666666">1.0</span>               <span style="color: #408080; font-style: italic"># all elts in first row is set to 1</span>
diagonals[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>]<span style="color: #666666">=</span> <span style="color: #666666">1.0</span>               <span style="color: #408080; font-style: italic"># all elts in first row is set to 1</span>
diagonals[<span style="color: #666666">1</span>,:]<span style="color: #666666">=</span> <span style="color: #666666">-</span>(<span style="color: #666666">2+</span>(beta<span style="color: #666666">*</span>h)<span style="color: #666666">**2</span>)  
diagonals[<span style="color: #666666">2</span>,:]<span style="color: #666666">=</span> <span style="color: #666666">1.0</span> 
diagonals[<span style="color: #666666">2</span>,<span style="color: #666666">1</span>]<span style="color: #666666">=</span> <span style="color: #666666">2.0</span>               <span style="color: #408080; font-style: italic"># particular value due to derivative bc</span>
A_sparse <span style="color: #666666">=</span> sc<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>spdiags(diagonals, [<span style="color: #666666">-1</span>,<span style="color: #666666">0</span>,<span style="color: #666666">1</span>], n, n,format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csc&#39;</span>) <span style="color: #408080; font-style: italic">#sparse matrix instance</span>

<span style="color: #408080; font-style: italic">#Crete rhs array</span>
d<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros(n)
d[<span style="color: #666666">-1</span>]<span style="color: #666666">=-1</span>

<span style="color: #408080; font-style: italic">#Solve linear problems</span>
tic<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
theta <span style="color: #666666">=</span> sc<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A_sparse,d) <span style="color: #408080; font-style: italic">#theta=sc.linalg.solve_triangular(A,d)</span>
toc<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;sparse solver time:&#39;</span>,toc<span style="color: #666666">-</span>tic

tic<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
theta2<span style="color: #666666">=</span>sc<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A,d,)
toc<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;linalg solver time:&#39;</span>,toc<span style="color: #666666">-</span>tic

<span style="color: #408080; font-style: italic"># Plot solutions</span>
plot(x[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>],theta,x[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>],theta2,<span style="color: #BA2121">&#39;-.&#39;</span>,x,theta_analytical(beta,x),<span style="color: #BA2121">&#39;:&#39;</span>)
<span style="color: #408080; font-style: italic">#plot(x[0:-1],theta2,&#39;-.&#39;,x,theta_analytical(beta,x),&#39;:&#39;)</span>
legend([<span style="color: #BA2121">&#39;sparse&#39;</span>,<span style="color: #BA2121">&#39;linalg&#39;</span>,<span style="color: #BA2121">&#39;analytical&#39;</span>])
show()
close()
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;done&#39;</span>
</pre></div>
<p>
Den relative feilen er beregnet fra \( \varepsilon_{rel} = |(\theta_{num}-\theta_{analyt})/\theta_{analyt}|  \) . Resultatet av beregningen er gitt i 
tabellen under:
<!-- 3.2:\\ -->

<p>

<div class="row">
  <div class="col-xs-5">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="left"><b> x </b></td> <td align="left"><b>Analyt.</b></td> <td align="left"><b>Sentr.diff</b></td> <td align="left"><b>Rel. feil</b></td> <td align="left"><b>Forov.diff</b></td> <td align="left"><b>Rel. feil</b></td> </tr>
</thead>
<tbody>
<tr><td align="left">   0.0    </td> <td align="left">   0.26580    </td> <td align="left">   0.26665       </td> <td align="left">   0.00320      </td> <td align="left">   0.26613       </td> <td align="left">   0.00124      </td> </tr>
<tr><td align="left">   0.1    </td> <td align="left">   0.27114    </td> <td align="left">   0.27199       </td> <td align="left">   0.00314      </td> <td align="left">   0.27156       </td> <td align="left">   0.00158      </td> </tr>
<tr><td align="left">   0.2    </td> <td align="left">   0.28735    </td> <td align="left">   0.28820       </td> <td align="left">   0.00295      </td> <td align="left">   0.28786       </td> <td align="left">   0.00176      </td> </tr>
<tr><td align="left">   0.3    </td> <td align="left">   0.31510    </td> <td align="left">   0.31594       </td> <td align="left">   0.00267      </td> <td align="left">   0.31567       </td> <td align="left">   0.00180      </td> </tr>
<tr><td align="left">   0.4    </td> <td align="left">   0.35549    </td> <td align="left">   0.35632       </td> <td align="left">   0.00232      </td> <td align="left">   0.35610       </td> <td align="left">   0.00171      </td> </tr>
<tr><td align="left">   0.5    </td> <td align="left">   0.41015    </td> <td align="left">   0.41095       </td> <td align="left">   0.00194      </td> <td align="left">   0.41078       </td> <td align="left">   0.00153      </td> </tr>
<tr><td align="left">   0.6    </td> <td align="left">   0.48128    </td> <td align="left">   0.48202       </td> <td align="left">   0.00154      </td> <td align="left">   0.48189       </td> <td align="left">   0.00128      </td> </tr>
<tr><td align="left">   0.7    </td> <td align="left">   0.57171    </td> <td align="left">   0.57237       </td> <td align="left">   0.00114      </td> <td align="left">   0.57228       </td> <td align="left">   0.00098      </td> </tr>
<tr><td align="left">   0.8    </td> <td align="left">   0.68510    </td> <td align="left">   0.68561       </td> <td align="left">   0.00075      </td> <td align="left">   0.68555       </td> <td align="left">   0.00067      </td> </tr>
<tr><td align="left">   0.9    </td> <td align="left">   0.82597    </td> <td align="left">   0.82628       </td> <td align="left">   0.00037      </td> <td align="left">   0.82625       </td> <td align="left">   0.00034      </td> </tr>
<tr><td align="left">   1.0    </td> <td align="left">   1.00000    </td> <td align="left">   1.00000       </td> <td align="left">   0.00000      </td> <td align="left">   1.00000       </td> <td align="left">   0.00000      </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-5 -->
<p>
Vi ser at de to uttrykkene for den deriverte randbetingelsen gir omtrent samme nøyaktighet unntatt  nær \( x=0 \) , der foroverdifferansene er en del bedre. 
I avsnitt (<a href="#ch3:sec6">Deriverte randbetingelser</a>) ser vi nærmere på nøyaktigheten av deriverte randbetingelser.

<p>
Istedenfor nummereringen i fig. (<a href="#fig:32b">41</a>), kan vi bruke nummereringen i fig. (<a href="#fig:32a">40</a>) med \( x_i = i\cdot h \ , \ i=0,1,...,N+1 \)  der 
\( h=\frac{1}{N+1} \) slik at  vi med å sette  \( i=1 \)  i \eqref{eq:3219} får:

$$
\begin{equation*}
\theta_0 - (2+ \beta^2h^2) \cdot \theta_1 + \theta_2 = 0
\end{equation*}
$$

<p>
Randbetingelsen i \eqref{eq:32114} blir nå:

$$
\begin{equation*}
\frac{d\theta}{dx}\bigg|_0 = \frac{-3\theta_0 + 4 \theta_1 - \theta_2}{2h}=0
\end{equation*}
$$

<p>
som gir:

$$
\begin{equation} \label{eq:32118}
\theta_0 = 4(\theta_1 - \theta_2)/3
\end{equation}
$$

<p>
som innsatt ovenfor gir ligning nr. 1:

$$
\begin{equation} \label{eq:32119}
-(2 + 3\beta^2h^2) \cdot \theta_1 + 2\theta_2 = 0
\end{equation}
$$

<p>
Etter at systemet er løst, beregnes \( \theta_0 \) fra \eqref{eq:32118}. 
<!-- (se program <b>ribbe23</b>) -->

<p>
<!-- !split -->

<h2 id="ch3:sec22">Ribbe med variabelt tverrsnitt</h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 42:  <div id="fig:33a"></div> </p></center>
<p><img src="fig-ch3/fig4.png" align="bottom" width=400></p>
</center>

<p>
Figure <a href="#fig:33a">42</a> viser en trapesformet kjøleribbe med lengde L og bredde b. Tykkelsen variere fra d for \( X = 0 \) til D for \( X = L \) . Ribba har varmetap 
for \( X = 0 \) og har en gitt temperatur \( T_L \) for \( X=L \). Omgivelsestemperaturen er konstant lik \( T_{\infty} \) .

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 43:  <div id="fig:33b"></div> </p></center>
<p><img src="fig-ch3/fig5.png" align="bottom" ></p>
</center>

<p>
Figure <a href="#fig:33b">43</a> viser øvre halvpart av ribba. Av denne figuren finner vi følgende relasjon:

$$
\begin{equation*}
\tan(\phi) = \frac{D/2 - d/2}{L} = \frac{l/2-d/2}{X}
\end{equation*}
$$

<p>
som løst m.h.p. \( l \) gir:

$$
\begin{equation} \label{eq:32220}
l = d + \left(\frac{D-d}{L}\right)\cdot X = D \cdot \left[ \frac{d}{D}+\left(1-\frac{d}{D}\right)\cdot \frac{X}{L} \right]
\end{equation}
$$

<p>
Vi forutsetter at temperaturen varierer hovedsakelig  i X-retning slik at utledningen i appendiks B i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a> 
kan brukes. Antar derfor at D er liten, D \( \ll \) L samt \( 0 < \frac{d}{D} < 1 \) .

<p>
Fra appendiks B, lign. (B.0.22) i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>:

$$
\begin{equation} \label{eq:32221a}
\frac{d}{dX}\left[A(X)\cdot\frac{d(T-T_{\infty})}{dX}\right] = \frac{\bar{h}P(X) }{k}(T-T_{\infty})
\end{equation}
$$

<p>
randbetingelser:

$$
\begin{equation} \label{eq:32221b}
\frac{dT(0)}{dX}= \frac{\bar{h}_0}{k}[T(0)-T_{\infty}] \ , \ T(L) = T_L 
\end{equation}
$$

<p>
For trapestverrsnittet i fig. (<a href="#fig:33a">42</a>):

$$
\begin{equation*}
P(X) = 2(b+l) \approx 2b \text{ for } l \ll b \text{ og } A(X) = b\cdot l
\end{equation*}
$$

<p>
Innfører følgende dimensjonsløse størrelser:

<p>
<br />

<p>
Temperatur \( \theta = \dfrac{T-T_{\infty}}{T_L - T_{\infty}} \) , lengde \( x=\dfrac{X}{L} \) , \( \alpha = \dfrac{d}{D} \) , \( 0 < \alpha < 1  \) samt:

$$
\begin{equation} \label{eq:32222}
\text{Biot-tallene }\beta^2 = \frac{2\bar{h} \cdot L^2}{D\cdot k} \text{ og } \beta_0^2 = \dfrac{\bar{h}_0}{k}\cdot L
\end{equation}
$$

<p>
Med bruk av disse dimensjonsløse størrelsene kan \eqref{eq:32221a} skrives:

$$
\begin{equation} \label{eq:32223a}
\frac{d}{dx}\left[\{\alpha + (1-\alpha)\cdot x\}\frac{d\theta(x)}{dx}\right] - \beta^2\theta(x) = 0
\end{equation}
$$

<p>
med randbetingelser:

$$
\begin{equation} \label{eq:32223b}
\frac{d\theta}{dx}(0)=\beta_0^2 \cdot \theta(0) \ , \ \theta(1) = 1
\end{equation}
$$

<p>
Når \( d=0 \) som betyr \( \alpha = 0 \) , går trapesprofilet over til et trekantprofil.

<p>
Lign. \eqref{eq:32223a} blir nå:

$$
\begin{equation} \label{eq:32224a}
x\frac{d^2\theta}{dx^2}+\frac{d\theta}{dx} -\beta^2\theta(x) = 0
\end{equation}
$$

<p>
For \( x = 0 \):

$$
\begin{equation} \label{eq:32224b}
\frac{d\theta}{dx}(0)-\beta^2\theta(0) = 0
\end{equation}
$$

<p>
Den analytiske løsningen av \eqref{eq:32223a}  og \eqref{eq:32224a} er gitt i appendiks G, del G.5 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>.

<h2 id="ex:31">Example: Talleksempel for trapesprofilet</h2>

$$
\begin{equation} \label{eq:32225}
\begin{array}{l}
L=0.1m, \ D = 0.01m, \  d=0.005m,\ \bar{h} = 80W/m^2/^\circ C, \bar{h}_0 = \\ 
200 W/m^2/^\circ C,\text{og }k = 40W/m/^\circ C \text{ som gir } \beta^2 = 4.0 \ ,\ \alpha = \frac{1}{2} \text{ og }\beta_0^2 = 0.5
\end{array}
\end{equation}
$$

<p>
\eqref{eq:32223a} blir nå:

$$
\begin{equation} \label{eq:32226}
\frac{d}{dx}\left[ (1+x)\cdot \frac{d\theta}{dx}\right] - 8\cdot \theta(x) = 0
\end{equation}
$$

<p>
Et Matlab-program som beregner temperaturen \( \theta \) samt gradienten \( \theta \)' for den analytiske løsningen, der x  går fra 0 til 1 med skritt 
\( \Delta x = 0.1 \) , er gitt i appendiks G, del G.5 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a> .

<p>
Programmet gir følgende tabell:

<p>

<div class="row">
  <div class="col-xs-4">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="left"><b> x  </b></td> <td align="left">\( \theta \) (x)</td> <td align="left">\( \theta \)'(x)</td> </tr>
</thead>
<tbody>
<tr><td align="left">   0.00    </td> <td align="left">   0.18069             </td> <td align="left">   0.09034             </td> </tr>
<tr><td align="left">   0.10    </td> <td align="left">   0.19623             </td> <td align="left">   0.21842             </td> </tr>
<tr><td align="left">   0.20    </td> <td align="left">   0.22415             </td> <td align="left">   0.33967             </td> </tr>
<tr><td align="left">   0.30    </td> <td align="left">   0.26424             </td> <td align="left">   0.46318             </td> </tr>
<tr><td align="left">   0.40    </td> <td align="left">   0.31708             </td> <td align="left">   0.59556             </td> </tr>
<tr><td align="left">   0.50    </td> <td align="left">   0.38383             </td> <td align="left">   0.74211             </td> </tr>
<tr><td align="left">   0.60    </td> <td align="left">   0.46614             </td> <td align="left">   0.90754             </td> </tr>
<tr><td align="left">   0.70    </td> <td align="left">   0.56611             </td> <td align="left">   1.09629             </td> </tr>
<tr><td align="left">   0.80    </td> <td align="left">   0.68632             </td> <td align="left">   1.31291             </td> </tr>
<tr><td align="left">   0.90    </td> <td align="left">   0.82978             </td> <td align="left">   1.56211             </td> </tr>
<tr><td align="left">   1.00    </td> <td align="left">   1.00000             </td> <td align="left">   1.84901             </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-4 -->
<p>
<br />

<p>
<b>Numerisk løsning av homogent trapesprofil</b>

<p>
Vi vil nå løse lign. \eqref{eq:32226} numerisk med bruk av sentraldifferanser

$$
\begin{equation} \label{eq:32227a}
(1+x)\frac{d^2\theta}{dx^2}+\frac{d\theta}{dx}-8\cdot\theta(x)=0
\end{equation}
$$

<p>
med randbetingelser:

$$
\begin{equation} \label{eq:32227b}
\frac{d\theta}{dx}(0) = \beta_0^2 \cdot \theta(0) = \frac{\theta(0)}{2} \ , \ \theta(1) = 1
\end{equation}
$$

<p>
Fremgangsmåten blir som for tilfelle 2, versjon 2, avsnitt (<a href="#ch3:sec21">Kjøleribbe med konstant tverrsnitt</a>) med samme nummerering.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 44:  <div id="fig:36"></div> </p></center>
<p><img src="fig-ch3/fig6.png" align="bottom" width=400></p>
</center>

<p>
x-koordinatene er gitt ved: \( x_i = (i-1)\cdot h \) , \( i = 1,2,...,N+1 \) der \( h=\frac{1}{N} \) .

<p>
Diskretisering:

$$
\begin{equation*}
(1+x_i) \cdot \frac{\theta_{i+1} -2\theta_i + \theta_{i-1}}{h^2}+\frac{\theta_{i+1}-\theta_{i-1}}{2h}-8\theta_i = 0
\end{equation*}
$$

<p>
som ordnet blir:

$$
\begin{equation} \label{eq:32228a}
-(1-\gamma_i)\cdot \theta_{i-1} + 2 \cdot (1+8h \cdot \gamma_i) \cdot \theta_i - (1+\gamma_i)\cdot \theta_{i+1}=0
\end{equation}
$$


$$
\begin{equation} \label{eq:32228b}
\text{der } \gamma_i = \frac{h}{2(1+x_i)}=\frac{h}{2[1+(i-1)\cdot h]}\  , \  i=1,2,...,N+1
\end{equation}
$$

<p>
For randbetingelsen i \eqref{eq:32227b} får vi: \( \frac{\theta_2 - \theta_0 }{2h} = \frac{\theta_1}{2} \to \theta_0 = \theta_2 - \theta_1 \cdot h \) 
som innsatt i \eqref{eq:32228a} for \( i = 1 \) gir:

$$
\begin{equation} \label{eq:32229a}
[2+h \cdot (1+15\cdot \gamma_1)] \cdot \theta_1 - 2\theta_2 = 0
\end{equation}
$$

<p>
For \( i=N \):

$$
\begin{equation} \label{eq:32229b}
-(1-\gamma_N) \cdot \theta_{N-1} + 2 \cdot (1 + 8h \cdot \gamma_N)\cdot \theta_N = 1 + \gamma_N
\end{equation}
$$

<p>
For \( i = 2,3,...,N-1 \) bruker vi \eqref{eq:32228a}. Vi har da et tridiagonalt ligningsett som kan løses med Thomas-algoritmen . Tabellen nedenfor viser 
beregningene med to forskjellige verdier av h. Vi ser at feilen er 100 ganger mindre for \( h = 0.01 \) enn for \( h=0.1 \)  som betyr at feilen er av \( O(h^2) \) ; 
i overenstemmelse med teorien. Den relative feilen er beregnet fra \( |(\theta_{numerisk} - \theta_{analytisk})/\theta_{analytisk}| \)

<p>

<div class="row">
  <div class="col-xs-9">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="left">\( h=0.1 \)</td> <td align="left"><b> x </b></td> <td align="left">\( \theta(x) \)</td> <td align="left"><b>rel. feil</b></td> <td align="left">\( h=0.01 \)</td> <td align="left"><b> x </b></td> <td align="left">\( \theta(x) \)</td> <td align="left"><b>rel. feil</b></td> </tr>
</thead>
<tbody>
<tr><td align="left">                  </td> <td align="left">   0.0    </td> <td align="left">   0.18054            </td> <td align="left">   8.000E-4     </td> <td align="left">                   </td> <td align="left">   0.0    </td> <td align="left">   0.18069            </td> <td align="left">   4.866E-6     </td> </tr>
<tr><td align="left">                  </td> <td align="left">   0.1    </td> <td align="left">   0.19634            </td> <td align="left">   5.619E-4     </td> <td align="left">                   </td> <td align="left">   0.1    </td> <td align="left">   0.19623            </td> <td align="left">   1.010E-5     </td> </tr>
<tr><td align="left">                  </td> <td align="left">   0.2    </td> <td align="left">   0.22442            </td> <td align="left">   1.224E-3     </td> <td align="left">                   </td> <td align="left">   0.2    </td> <td align="left">   0.22415            </td> <td align="left">   1.669E-5     </td> </tr>
<tr><td align="left">                  </td> <td align="left">   0.3    </td> <td align="left">   0.26462            </td> <td align="left">   1.436E-3     </td> <td align="left">                   </td> <td align="left">   0.3    </td> <td align="left">   0.264259           </td> <td align="left">   1.703E-5     </td> </tr>
<tr><td align="left">                  </td> <td align="left">   0.4    </td> <td align="left">   0.31752            </td> <td align="left">   1.394E-3     </td> <td align="left">                   </td> <td align="left">   0.4    </td> <td align="left">   0.31709            </td> <td align="left">   1.325E-5     </td> </tr>
<tr><td align="left">                  </td> <td align="left">   0.5    </td> <td align="left">   0.38430            </td> <td align="left">   1.222E-3     </td> <td align="left">                   </td> <td align="left">   0.5    </td> <td align="left">   0.38383            </td> <td align="left">   9.861E-6     </td> </tr>
<tr><td align="left">                  </td> <td align="left">   0.6    </td> <td align="left">   0.46660            </td> <td align="left">   9.910E-4     </td> <td align="left">                   </td> <td align="left">   0.6    </td> <td align="left">   0.46614            </td> <td align="left">   6.393E-6     </td> </tr>
<tr><td align="left">                  </td> <td align="left">   0.7    </td> <td align="left">   0.56653            </td> <td align="left">   7.385E-4     </td> <td align="left">                   </td> <td align="left">   0.7    </td> <td align="left">   0.56611            </td> <td align="left">   2.737E-6     </td> </tr>
<tr><td align="left">                  </td> <td align="left">   0.8    </td> <td align="left">   0.68665            </td> <td align="left">   4.838E-4     </td> <td align="left">                   </td> <td align="left">   0.8    </td> <td align="left">   0.68632            </td> <td align="left">   4.342E-7     </td> </tr>
<tr><td align="left">                  </td> <td align="left">   0.9    </td> <td align="left">   0.82998            </td> <td align="left">   2.364E-4     </td> <td align="left">                   </td> <td align="left">   0.9    </td> <td align="left">   0.82978            </td> <td align="left">   1.508E-6     </td> </tr>
<tr><td align="left">                  </td> <td align="left">   1.0    </td> <td align="left">   1.00000            </td> <td align="left">   0            </td> <td align="left">                   </td> <td align="left">   1.0    </td> <td align="left">   1.00000            </td> <td align="left">   0            </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-9 -->
<p>
<b>Numerisk løsning av sammensatt trekantprofil</b>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 45:  <div id="fig:37"></div> </p></center>
<p><img src="fig-ch3/fig7.png" align="bottom" width=400></p>
</center>

<p>
Figure <a href="#fig:37">45</a> viser en trekantformet kjøleribbe sammensatt av en trekant (del a) og et trapes (del b) der del a og b er laget av forskjellige 
materialer. Hensikten med dette tilfellet er å vise hvordan vi kan behandle diskontinuiteter. Her er temperaturen kontinuerlig, mens temperaturgradienten 
er diskontinuerlig på grenseflata mellom de to delene p.g.a. forskjellige verdier for varmeledningstallene. Fra appendiks B i 
<a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>:

$$
\begin{equation*}
-dQ_x = P \cdot h \cdot [T(X)-T_{\infty}]\cdot dX  \text{ der } Q_x = -kA\frac{dT}{dX}
\end{equation*}
$$

<p>
For \( dX \to 0 \) får vi da \( dQ \to 0 \Rightarrow Q = konstant \) som betyr at på grenseflata mellom de to legemene gjelder følgende relasjon:

$$
\begin{equation} \label{eq:32230}
Q_a = Q_b \Rightarrow k_aA_a\left(\frac{dT}{dX}\right)_a = k_bA_b\left(\frac{dT}{dX}\right)_b
\end{equation}
$$

<p>
Da \( A_a = A_b \) på grenseflata, følger: \( \left( \dfrac{dT}{dX} \right) _b = \dfrac{k_a}{k_b} \left( \dfrac{dT}{dX} \right)_a \)  som på dimensjonsløs 
form (med bruk av \eqref{eq:32222} blir:

$$
\begin{equation} \label{eq:32231}
\left( \frac{d\theta}{dx}\right)_b = \frac{k_a}{k_b}\left( \frac{d\theta}{dX}\right)_a
\end{equation}
$$

<p>
Bruker følgende tallverdier:

$$
\begin{equation} \label{eq:32232}
\begin{array}{l}
L = 0.2m \ , \ D =0.02m \ , \ d=0.01m \ , \ \bar{h}_a = \bar{h}_b=80W/m^2/^\circ C\ ,\\ 
k_a = 160 W/m/^\circ C \text{ og }k_b = 40 W/m/^\circ C
\end{array}
\end{equation}
$$

<p>
Med disse tallverdiene blir \eqref{eq:32231}:

$$
\begin{equation} \label{eq:32233}
\left( \dfrac{d\theta}{dx}\right)_b = 4\cdot \left( \dfrac{d\theta}{dx}\right) _a
\end{equation}
$$

<p>
Differensialligning: 

$$
\begin{equation} \label{eq:32234a}
\frac{d}{dx}\left( \frac{x}{\beta^2}\frac{d\theta}{dx}\right) - \theta(x) = 0
\end{equation}
$$


$$
\begin{equation} \label{eq:32234b}
\beta^2 = \frac{2\bar{h}\cdot L^2}{D \cdot k} \text{ som gir } \beta^2_a = 2.0 \text{ og } \beta^2_b = 8.0
\end{equation}
$$

<p>
Ved å skrive \eqref{eq:32234a} på den viste formen, har vi oppnådd kontinuiteten i \eqref{eq:32230}

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 46:  <div id="fig:38"></div> </p></center>
<p><img src="fig-ch3/fig8.png" align="bottom" width=400></p>
</center>

<p>
Med henvisning til Figure <a href="#fig:38">46</a> bruker vi følgende nummerering:

$$
\begin{align} \label{eq:32235}
\begin{array}{l}
x_i = (i-1)\cdot h \ , \ i=1,2,...,N+1 \text{ der } h = \frac{1}{N}\\ 
M = \frac{N}{2}+1 \text{ der N er et partall og }x_M = 0.5
\end{array}
\label{_auto39}
\end{align}
$$

<p>
Med \( k = k_a \) for \( i = M \) får vi at \( \beta = \beta_a \) for \( i=1,2,...,M \) og \( \beta = \beta_b \) for \( i > M \). For \( i\not= M \) kan vi skrive \eqref{eq:32234a}

$$
\begin{equation} \label{eq:32236}
\frac{d}{dx}\left( x\frac{d\theta}{dx}\right) - \beta^2 \cdot \theta(x) = 0
\end{equation}
$$

<p>
Diskretiserer \eqref{eq:32236}) med bruk av \eqref{eq:12010a}) i kap. (<a href="#ch:1">Initial value problems for Ordinary Differential Equations</a>):

$$
\begin{equation*}
-x_{i- \frac{1}{2}} \cdot \theta_{i-1} + (x_{i+ \frac{1}{2}} + x_{i- \frac{1}{2}} + \beta^2 h^2) \cdot \theta_i - x_{i + \frac{1}{2}} \cdot \theta_{i+1} = 0
\end{equation*}
$$

<p>
Innsatt for \( x_{i- \frac{1}{2}} = (i - \frac{3}{2}) \cdot h \) og \( x_{i+ \frac{1}{2}} = (i - \frac{1}{2})\cdot h \) får vi:

$$
\begin{equation*}
\left(i - \frac{3}{2}\right) \cdot \theta_{i-1} + [2(i-1) + \beta^2h] \cdot \theta_i - \left(i- \frac{1}{2} \right) \cdot \theta_{i+1} = 0
\end{equation*}
$$

<p>
eller dividert med i:

$$
\begin{equation} \label{eq:32237}
\ - \left( 1-\frac{3}{2i} \right) \cdot \theta_{i-1} + \left[ 2 \cdot \left( 1 - \frac{1}{i} \right) + \frac{\beta^2h}{i} \right] \cdot \theta_i - \left(1 - \frac{1}{2i} \right) \cdot \theta_{i+1} = 0
\end{equation}
$$

<p>
\eqref{eq:32237} brukes for alle verdier av \( i = 2,3,...,N \) unntatt for \( i = M = N/2+1 \)

<p>
<b>For i \( = \) 1</b>

<p>
Fra \eqref{eq:32224b} får vi for randbetingelsen for \( x=0 \):

<p>
\( \dfrac{d\theta}{dx}(0)= \beta_a^2 \cdot \theta(0) \to \dfrac{-3 \theta_1 + 4 \theta_2 - \theta_3}{2h}= \beta_a^2 \cdot \theta_1 \) hvor vi har benyttet 
(<a href="#forward">forward</a>)

<p>
Dette gir:

$$
\begin{equation} \label{eq:32238}
\theta_3 = 4\theta_2 - (3 + 2h\beta_a^2) \cdot \theta_1
\end{equation}
$$

<p>
Skriver ut \eqref{eq:32237} for i \( = \) 2:

$$
\begin{equation*}
-\left(1- \frac{3}{4}\right) \cdot \theta_1 + \left[ 2\cdot \left(1 - \frac{1}{2}\right) + \frac{\beta_a^2h}{2}\right] \cdot \theta_2 - \left(1 - \frac{1}{4}\right) \cdot \theta_3
\end{equation*}
$$

<p>
som innsatt fra \eqref{eq:32234b} og \eqref{eq:32238} gir:

$$
\begin{equation} \label{eq:32239}
\left( 1 + \frac{3h}{2}\right) \cdot \theta_1 - \left( 1 - \frac{h}{2}\right) \cdot \theta_2 = 0
\end{equation}
$$

<p>
Dette er den første ligningen.

<p>
<b>For i \( = \) M. </b>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 47:  <div id="fig:39"></div> </p></center>
<p><img src="fig-ch3/fig9.png" align="bottom" ></p>
</center>

<p>
Her bruker vi ligningen på formen gitt i \eqref{eq:32234a}) som diskretisert med bruk av \eqref{eq:12010a}) fra kap. (<a href="#ch:1">Initial value problems for Ordinary Differential Equations</a>)  gir:

$$
\begin{align*}
\begin{array}{c}
\beta_{M- \frac{1}{2}}^2 = \beta_a^2 = 2.0 \ , \ \beta_{M+\frac{1}{2}}^2 = \beta_b^2 = 8.0\\ 
x_{M-\frac{1}{2}} = \dfrac{h}{2}(N-1)= \dfrac{(1-h)}{2} \ , \ x_{M+\frac{1}{2}} = \dfrac{h}{2}(N+1) = \dfrac{(1+h)}{2}
\end{array}
\end{align*}
$$

<p>
som gir:

$$
\begin{equation} \label{eq:32240}
-4 \cdot (1-h) \cdot \theta _{M-1} + [5-3h+16h^2]\cdot \theta_M - (1+h) \cdot \theta_{M+1} = 0
\end{equation}
$$

<p>
<b>For i</b> \( = \) <b>N</b> kan vi  bruke \eqref{eq:32237} med \( \beta^2 = \beta_b^2 = 8.0 \):

$$
\begin{equation} \label{eq:32241}
-\left(1-\frac{3h}{2}\right) \cdot \theta_{N-1} + 2 \cdot [(1-h)+4h^2] \cdot \theta_N = \left(1-\frac{h}{2}\right)
\end{equation}
$$

<p>
Ligning \eqref{eq:32239}–\eqref{eq:32241} er et lineært ligningsystem på tridiagonal form som kan løses med Thomasalgoritmen. I tillegg til temperaturen 
ønsker vi også å beregne temperaturgradienten \( \theta'(x) \) . For \( x=0 \) bruker vi \eqref{eq:32224b} og sprangverdien 
\( \frac{d\theta}{dx}(0.5+)\equiv \left( \frac{d\theta}{dx}\right)_b  \) finnes fra \eqref{eq:32233}. De andre verdiene beregnes med vanlige 
sentraldifferanser, med 2. ordens bakoverdifferanser for x \( = \) 0.5 og x \( = \) 1.0 . La oss se på bruken av differensial-ligningen som et alternativ.

<p>
Vi integrerer \eqref{eq:32236}:

$$
\begin{equation} \label{eq:32242}
\frac{d\theta_i}{dx}=\frac{\beta^2}{x_i} \int_{x_1}^{x_i} \theta(x)dx \ , \ i= 2,3,...,N+1
\end{equation}
$$

<p>
Integralet \( I = \int_{x_1}^{x_i}\theta(x)dx \)  beregnes f.eks ved bruk av trapesmetoden . Beregningen av \eqref{eq:32242} er vist i 
pseudokode nedenfor:

$$
\begin{align*}
\begin{array}{rrrlll}
                        &&\theta_1' &:=& \beta_a^2\cdot \theta_1\\ 
                        &&s&:=& 0\\ 
&&\text{Utfør for }      i&:=&2,...,N+1\\ 
                        &&x&:=&h\cdot(i-1)\\ 
                        &&s&:=&s+0.5h\cdot(\theta_i+\theta_{i-1})\\ 
\end{array}
\end{align*}
$$


$$
\begin{equation*}
\text{Dersom $(i\le M)$ sett }\theta_i ':= \frac{\beta_a^2\cdot s}{x} \text{ ellers }\theta_i':= \frac{\beta_b^2 \cdot s}{x}
\end{equation*}
$$

<p>
I tabellen på neste side har vi brukt \eqref{eq:32242} og trapesmetoden. I dette tilfellet er nøyaktigheten av de to metodene for beregning av 
\( \theta'(x) \)  temmelig sammenfallende da både \( \theta \) og \( \theta' \) er glatte funksjoner (bortsett fra x \( = \) 0.5), men generelt vil integrasjonsmetoden 
gjerne være mer nøyaktig dersom det er diskontinuiteter.

<p>
Løsning av lign. \eqref{eq:32234a} med \( h = 0.01 \)

<p>

<div class="row">
  <div class="col-xs-6">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="left"><b> x  </b></td> <td align="left">\( \theta(x) \)</td> <td align="left"><b>rel. feil</b></td> <td align="left">\( \theta'(x) \)</td> <td align="left"><b>rel. feil</b></td> </tr>
</thead>
<tbody>
<tr><td align="left">   0.00    </td> <td align="left">   0.08007            </td> <td align="left">   1.371E-4     </td> <td align="left">   0.16014             </td> <td align="left">   1.312E-4     </td> </tr>
<tr><td align="left">   0.10    </td> <td align="left">   0.09690            </td> <td align="left">   1.341E-4     </td> <td align="left">   0.17670             </td> <td align="left">   1.302E-4     </td> </tr>
<tr><td align="left">   0.20    </td> <td align="left">   0.11545            </td> <td align="left">   1.386E-4     </td> <td align="left">   0.19438             </td> <td align="left">   1.286E-4     </td> </tr>
<tr><td align="left">   0.30    </td> <td align="left">   0.13582            </td> <td align="left">   1.252E-4     </td> <td align="left">   0.21324             </td> <td align="left">   1.360E-4     </td> </tr>
<tr><td align="left">   0.40    </td> <td align="left">   0.15814            </td> <td align="left">   1.265E-4     </td> <td align="left">   0.23333             </td> <td align="left">   1.329E-4     </td> </tr>
<tr><td align="left">   0.45    </td> <td align="left">   0.17007            </td> <td align="left">   1.294E-4     </td> <td align="left">   0.24387             </td> <td align="left">   1.312E-4     </td> </tr>
<tr><td align="left">   0.5-    </td> <td align="left">   0.18253            </td> <td align="left">   1.260E-4     </td> <td align="left">   0.25472             </td> <td align="left">   1.021E-4     </td> </tr>
<tr><td align="left">   0.5+    </td> <td align="left">   0.18253            </td> <td align="left">   1.260E-4     </td> <td align="left">   1.01889             </td> <td align="left">   1.021E-4     </td> </tr>
<tr><td align="left">   0.55    </td> <td align="left">   0.23482            </td> <td align="left">   5.962E-5     </td> <td align="left">   1.07785             </td> <td align="left">   1.067E-4     </td> </tr>
<tr><td align="left">   0.60    </td> <td align="left">   0.29073            </td> <td align="left">   5.848E-5     </td> <td align="left">   1.16297             </td> <td align="left">   9.202E-5     </td> </tr>
<tr><td align="left">   0.70    </td> <td align="left">   0.41815            </td> <td align="left">   3.348E-5     </td> <td align="left">   1.39964             </td> <td align="left">   7.288E-5     </td> </tr>
<tr><td align="left">   0.80    </td> <td align="left">   0.57334            </td> <td align="left">   1.744E-5     </td> <td align="left">   1.71778             </td> <td align="left">   5.938E-5     </td> </tr>
<tr><td align="left">   0.90    </td> <td align="left">   0.76442            </td> <td align="left">   7.849E-6     </td> <td align="left">   2.11851             </td> <td align="left">   4.862E-5     </td> </tr>
<tr><td align="left">   1.00    </td> <td align="left">   1.00000            </td> <td align="left">   0.0          </td> <td align="left">   2.60867             </td> <td align="left">   1.526E-4     </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-6 -->
<p>
<!-- !split -->

<h1 id="ch3:sec3">To-punktsmetode. Varmeveksler.</h1>

<p>
Et system av \( p \) første ordens differensialligninger kan skrives:

$$
\begin{equation*}
y_i'(x) = f_i(x,y_1,y_2,...,y_p) \ , \ i = 1,2,...,p
\end{equation*}
$$

<p>
Dersom randverdiene er foreskrevet for \( x= a \) og \( x=b \) , kan vi skrive randverdiproblemet på vektorform:

$$
\begin{equation} \label{eq:3301a}
\textbf{y'}(x) = \textbf{f}(x,\textbf{y})
\end{equation}
$$


$$
\begin{equation} \label{eq:3301b}
\textbf{A}\cdot \textbf{y}(a) + \textbf{B} \cdot \textbf{y}(b) = \textbf{c}
\end{equation}
$$

<p>
der <b>A</b> og <b>B</b> er \( p \) x \( p \) - matriser.

<p>
<br />

<p>
Randbetingelsene må være lineære, dvs. elementene i <b>A</b> og <b>B</b>  er konstanter, dersom de skal kunne skrives på formen i 
\eqref{eq:3301b} Det eksisterer selvfølgelig mer generelle randbetingelser; f.eks: \( \textbf{g}(\textbf{y}(a), \textbf{y}(b)) = \) 0 , men 
\eqref{eq:3301b} dekker en lang rekke tilfeller.

<h2 id="ex:32">Example</h2>

<p>
Fra lign.\eqref{eq:3214} og \eqref{eq:3216a}:

$$
\begin{equation*}
\begin{array}{l}
\frac{d^2\theta}{dx^2}- \beta^2 \theta(x) = 0\\ 
\theta'(0) = 0 \ , \ \theta(1) = 1
\end{array}
\end{equation*}
$$

<p>
Med notasjonen i \eqref{eq:3301a} kan dette systemet skrives:

$$
\begin{equation*}
\begin{array}{l}
y_1' = y_2\\ 
y_2'=\beta^2y_1
\end{array}
\end{equation*}
$$


$$
\begin{equation*}
\begin{bmatrix}
0&1\\ 
0&0
\end{bmatrix}
\cdot
\begin{bmatrix}
y_1(0)\\ 
y_2(0)
\end{bmatrix}
+
\begin{bmatrix}
0&0\\ 
1&0
\end{bmatrix}
\cdot
\begin{bmatrix}
y_1(1)\\ 
y_2(1)
\end{bmatrix}
=
\begin{bmatrix}
0\\ 
1
\end{bmatrix}
\end{equation*}
$$

<p>
Vi diskretiserer \eqref{eq:3301a} med bruk av sentraldifferanser. Da \eqref{eq:3301a} er et sett av 1. ordens ligninger, velger vi å utvikle 
differanseutrykkene halveis mellom to punkt; i dette tilfellet rundt \( x_{j- \frac{1}{2}} \)  som vist på Figure <a href="#fig:310">48</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 48:  <div id="fig:310"></div> </p></center>
<p><img src="fig-ch3/fig10.png" align="bottom" width=400></p>
</center>

$$
\begin{equation} \label{eq:3302}
\frac{d\textbf{y}}{dx}\bigg|_{j-\frac{1}{2}}= \frac{\textbf{y}_j - \textbf{y}_{j-1}}{h} + O(h^2) \ , \ \textbf{y}_{j-\frac{1}{2}} = \frac{1}{2}(\textbf{y}_j+\textbf{y}_{j-1}) + O(h^2)
\end{equation}
$$

<p>
\eqref{eq:3302} brukt i \eqref{eq:3301a} gir:

$$
\begin{equation} \label{eq:3303a}
\frac{\textbf{y}_j - \textbf{y}_{j-1}}{h}-\textbf{f}\left( x_{j-\frac{1}{2}},\frac{\textbf{y}_j+\textbf{y}_{j-1}}{h}\right) = 0 \ , \ j=1,2,...,N
\end{equation}
$$

<p>
med randbetingelser:

$$
\begin{equation} \label{eq:3303b}
\textbf{A} \cdot \textbf{y}_0 + \textbf{B} \cdot \textbf{y}_N = \textbf{c}
\end{equation}
$$

<p>
Notasjon:

$$
\begin{equation} \label{eq:3303c}
x_j = a + j \cdot h, \ j= 0,1,...N \ , \ h = \frac{b-a}{N}
\end{equation}
$$

<p>
Med denne diskretiseringen kan det vises at følgende relasjon gjelder:

$$
\begin{equation} \label{eq:3304}
\textbf{y} (x_j) = \textbf{y}_j (h) + h^2 \textbf{e}(x_j) +O(h^4) \ , \ j=0,1,...,N
\end{equation}
$$

<p>
Her er \( \textbf{y}_j(h) \) de diskretiserte verdiene ved skrittlengden <em>h</em> og \( \textbf{e}(x_j) \)  er en funksjon som kan  
relateres til den gitte differensialligningen. (Bevis for de forskjellige teoremene kan finnes i Keller <a href="#forsythe77numerical">[11]</a>
, kapittel 3).

<!-- begin inline comment -->
<font color="red">(<b>Marie 9</b>: Nå står G. E. Forsythe som forfatter. Skal det egentlig være H. B. Keller?)</font>
<!-- end inline comment -->

<p>
På denne måten får vi bare to forskjellige indekser i hver ligning ; derav navnet to-punktsmetoden. Den vesentlige fordelen 
med denne metoden er normalt i forbindelse med randbetingelsene. En mindre bakdel er at vi selv for 2. ordens 
differensialligninger må bruke en generalisert versjon av Thomas-algoritmen, men disse generaliserte versjonene er også 
effektive. Utvider vi to-punktsmetoden til flere dimensjoner/tidsvariasjon, kalles metoden for en boksmetode. De mest kjente 
av disse er Kellers boksmetode i grensjikt-teori og Preismanns metode i kanalstrømning. (Wendroffs metode i avsnitt 
6.7 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a> er et spesialtilfelle av Preismanns metode). Vi skal  nå bruke (6.7.3) på et system av to ligninger 
der ligningene allerede i utgangspunktet er på formen gitt i (6.7.1).

<h2 id="___sec48">Example: Varmeveksler </h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 49:  <div id="fig:311"></div> </p></center>
<p><img src="fig-ch3/fig11_transp.png" align="bottom" width=400></p>
</center>

<p>
Figure <a href="#fig:311">49</a> viser en varmeveksler som er modellert som to rør. I det ytre røret foregår strømningen fra venstre mot 
høyre med konstant hastighet \( \textit{w}_y \) og i det indre røret har vi en strømning med konstant hastighet \( \textit{w}_i \). 
Vi har likestrøm når \( \textit{w}_i \) er rettet mot høyre mens vi har motstrøm når \( \textit{w}_i \) er rettet mot venstre. 
Temperaturen i  det ytre og det indre røret betegnes henholdsvis \( T_y \) og \( T_i \). Vi regner det ytre røret så godt isolert at 
et eventuelt varmetap til omgivelsene kan neglisjeres.

<p>
Noen betegnelser: (Indeks <em>i</em> henviser til det indre røret)

$$
\begin{equation} \label{eq:3305}
\begin{array}{lllll}
&\text{Rørlengde:}&                             &L                                              &[m]\\ 
&\text{Lengdekoordinat:}&                       &X\                                             &[m]\\ 
&\text{Rørdiameter:}&                           &d_i\                                           &[m]\\ 
&\text{Areal av rørtverrsnitt:}&                        &A_i = \pi \cdot d_i^2 / 4                      &[m^2]\\ 
&\text{Omkrets av indre rør:}&                  &P = \pi \cdot d_i                              &[m]\\ 
&\text{Tetthet av medium:}&                     &\rho_i                                         &[kg/m^3]\\ 
&\text{Massestrøm:}&                            &\dot m_i = \rho_iA_iw_i                        &[kg/s]\\        
&\text{Totalt varmeovergangstall:}&             &\bar{h}                                        &[W/m^2/^\circ C]\\ 
&\text{Egenvarme:}&                             &c_i                                            &[J/kg/^\circ C]\\ 
&\text{Varmestrøm:}&                            &\dot{Q}_i = \dot m_ic_iT_i     &[W]
\end{array}
\end{equation}
$$

<p>
For de indekserte størrelsene \eqref{eq:3305} har vi tilsvarende med indeks <em>y</em> for det ytre røret. \( \dot Q_{yi} \) er 
varmestrømmen til det indre røret fra det ytre:

<p>
Med henvisning til Figure <a href="#fig:312">50</a>:

$$
\begin{equation} \label{eq:3306}
\dot Q_{yi} = \bar{h}P \cdot dX[T_y(X)-T_i(X)]
\end{equation}
$$

<p>
Varmebalansen for det indre røret:

$$
\begin{equation} \label{eq:3307}
\begin{array}{l}
\dot Q_i = \dot Q_i + d \dot Q_i - \dot Q_{yi} \text{ som gir:}\\ 
d \dot Q_i = \dot Q_{yi} = -d \dot Q_y
\end{array}
\end{equation}
$$

<p>
hvor vi har benyttet oss av at vi ikke har noe varmetap til omgivelsene.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 50:  <div id="fig:312"></div> </p></center>
<p><img src="fig-ch3/fig12_transp.png" align="bottom" width=500></p>
</center>

<p>
\eqref{eq:3305} - \eqref{eq:3307} gir:

$$
\begin{equation} \label{eq:3308}
\dot m_ic_idT_i(X) = \bar{h}P \cdot dX[T_y(X)-T_i(X)] = -\dot m_yc_ydT_y(X)
\end{equation}
$$

<p>
Fra \eqref{eq:3308} får vi følgende ligninger:

$$
\begin{equation} \label{eq:3309a}
dT_y(X) = - \frac{\bar{h}P}{\dot m_yc_y}[T_y(X)-T_i(X)]\cdot dX
\end{equation}
$$


$$
\begin{equation} \label{eq:3309b}
dT_i(X) = \frac{\bar{h}P}{\dot m_ic_i}[T_y(X)-T_i(X)]\cdot dX
\end{equation}
$$

<p>
Vi innfører nå dimensjonsløse størrelser. Lar \( T_{ir} \) og \( T_{yr} \) være referansetemperaturer som kan gis passende verdier i 
konkrete tilfeller. De dimensjons-løse temperaturene i ytre og indre rør betegnes nå henholdsvis <em>u</em> og <em>v</em> .

$$
\begin{equation} \label{eq:33010a}
\text{Temperatur ytre rør: } u = \frac{T_y-T_{yr}}{T_{ir}-T_{yr}}
\end{equation}
$$


$$
\begin{equation} \label{eq:33010b}
\text{Temperatur indre rør: } v = \frac{T_i - T_{yr}}{T_{ir} - T_{yr}}
\end{equation}
$$


$$
\begin{equation} \label{eq:33010c}
\text{Lengde: } x = \frac{X}{L}
\end{equation}
$$


$$
\begin{equation} \label{eq:33010d}
\begin{array}{lll}
&&\alpha_y = \dfrac{\bar{h}PL}{\dot m_yc_y}=\dfrac{\bar{h}PL}{\rho_yA_yw_yc_y}\\ 
&\text{Koeffisienter: }&\\ 
&&\alpha_i = \dfrac{\bar{h}PL}{\dot m_ic_i}=\dfrac{\bar{h}PL}{\rho_iA_iw_ic_i}
\end{array}
\end{equation}
$$

<p>
\eqref{eq:33010a} innsatt i \eqref{eq:3309a} gir følgende system:

$$
\begin{equation} \label{eq:33011a}
\text{Ytre rør: } \frac{du}{dx}=-\alpha_y(u-v)
\end{equation}
$$


$$
\begin{equation} \label{eq:33011b}
\text{Indre rør: } \frac{dv}{dx}=\pm \alpha_i(u-v)
\end{equation}
$$

<p>
Vi har skrevet \( \pm \) foran leddet på høyre side i \eqref{eq:33011b} der pluss-tegnet gjelder 
for strømningsretningen som vist på Figure <a href="#fig:312">50</a>, mens negativt fortegn gjelder når \( w_i \)  skifter retning (motstrøm). 
Det er underforstått at <em>u</em> og <em>v</em> er funksjoner av <em>x</em> slik at vi slipper å skrive \( u(x) \) og \( v(x) \).

<p>
<br />

<p>
<b>Analytisk løsning</b>

<p>
Dersom vi kjenner temperaturen for en gitt x-verdi både i det ytre og indre røret, kan vi løse \eqref{eq:33011a} analytisk.

<p>
Ved subtraksjon:

$$
\begin{equation*}
-\frac{d}{dx}(u-v) = (\alpha_y \pm \alpha_i)\cdot(u-v)
\end{equation*}
$$

<p>
Innfører temperaturdifferansen

$$
\begin{equation} \label{eq:33012}
\theta = u-v
\end{equation}
$$

<p>
slik at vi får ligningen \( -\frac{d\theta}{dx} = ( \alpha_y \pm \alpha_i)\cdot\theta \) med løsning:

$$
\begin{equation} \label{eq:33013}
\theta(x) = \theta_0 \cdot e^{-(\alpha_y \pm \alpha_i)\cdot x} \ , \ \text{der } \theta_0 = \theta(0)
\end{equation}
$$

<p>
Får da følgende løsning for <em>u</em> og <em>v</em>:

$$
\begin{equation} \label{eq:33014a}
u(x) = u_0 - \theta_0 \cdot \left[\frac{\alpha_y }{\alpha_y \pm \alpha_i }\right] \cdot \left[1-e^{-(\alpha_y \pm \alpha_i) \cdot x}\right]
\end{equation}
$$


$$
\begin{equation} \label{eq:33014b}
v(x) = v_0 +\theta_0 \cdot \left[\frac{\alpha_i }{\alpha_y \pm \alpha_i }\right] \cdot \left[1-e^{-(\alpha_y \pm \alpha_i) \cdot x}\right]
\end{equation}
$$

<p>
Her er \( u_0 = u(0) \) og \( v_0 = v(0) \) . Dersom f. eks. \( u(0) \) og \( v(1) \) er gitt, har vi et tilfelle med splitta randbetingelser 
som må løses numerisk.

<p>
<b>Tilfelle med splitta randbetingelser.</b>

<p>
For et tilfelle med motstrøm blir \eqref{eq:33011a}:

$$
\begin{equation} \label{eq:33015a}
\frac{du}{dx}=-\alpha_y(u-v)
\end{equation}
$$


$$
\begin{equation} \label{eq:33015b}
\frac{dv}{dx}=-\alpha_i(u-v)
\end{equation}
$$

<p>
Innløpstemperaturen for det ytre røret \( = T_y(0) \) og utløpstemperaturen \( =T_y(L) \) . Tilsvarende betegnelser for det indre 
røret er \( T_i(0) \) og \( T_i(L) \) . Velger nå referansetemperaturene i \eqref{eq:33010a} for dette tilfellet:

$$
\begin{equation*}
\begin{array}{l}
T_{yr} = T_y(0) \text{ og } T_{ir}=T_i(L)
\end{array}
\end{equation*}
$$

<p>
slik at \eqref{eq:33010a} nå blir:

$$
\begin{equation} \label{eq:33016a}
\text{Temperatur ytre rør: } u=\frac{T_y - T_y(0)}{T_i(L)-T_y(0)}
\end{equation}
$$


$$
\begin{equation} \label{eq:33016b}
\text{Temperatur indre rør: } v=\frac{T_i - T_y(0)}{T_i(L)-T_y(0)}
\end{equation}
$$

<p>
Dette valget av referansetemperaturer gir følgende randbetingelser:

$$
\begin{equation} \label{eq:33017}
u(0) = 0 \ , \ v(1) = 1
\end{equation}
$$

<p>
\eqref{eq:33015a} innsatt i \eqref{eq:3303a}:

$$
\begin{equation*}
\frac{u_j-u_{j-1}}{h}= -\alpha_y \cdot \left[ \frac{1}{2} (u_j + u_{j-1})-\left(\frac{1}{2}(v_j+v_{j-1})\right)\right] 
\end{equation*}
$$


$$
\begin{equation*}
\frac{v_j-v_{j-1}}{h}= -\alpha_i \cdot \left[ \frac{1}{2} (u_j + u_{j-1})-\left(\frac{1}{2}(v_j+v_{j-1})\right)\right] 
\end{equation*}
$$

<p>
som ordnet gir følgende ligningsystem:

$$
\begin{equation} \label{eq:33018a}
(h \cdot \alpha_y -2) \cdot u_{j-1} + (2+h \cdot \alpha_y) \cdot u_j - h \cdot \alpha_y \cdot v_{j-1} - h \cdot \alpha_y \cdot v_f = 0
\end{equation}
$$


$$
\begin{equation} \label{eq:33018b}
h \cdot \alpha_i \cdot u_{j-1} + h \cdot \alpha_i \cdot u_j - (h \cdot \alpha_i + 2) \cdot v_{j-1} + (2 - h \cdot \alpha_i) \cdot v_j = 0
\end{equation}
$$

<p>
\eqref{eq:33018a} er et spesialtilfelle av det mer generelle systemet

$$
\begin{equation} \label{eq:33019}
\begin{array}{l}
a_j^{(1)}u_{j-1} + \alpha_j^{(2)}v_{j-1}+b_j^{(1)}u_j + b_j^{(2)}v_j+ c_j^{(1)}u_{j+1} + c_j^{(2)}v_{j+1} = d_j^{(1)}\\ 
a_j^{(3)}u_{j-1} + a_j^{(4)}v_{j-1} + b_j^{(3)}u_j + b_j^{(4)}v_j + c_j^{(3)}u_{j+1} + c_j^{(4)}v_{j+1} = d_j^{(2)}
\end{array}
\end{equation}
$$

<p>
Systemet i \eqref{eq:33019} kalles et bi-tridiagonalt ligningsystem. Algoritmen for løsning av dette systemet kalles ofte 
Douglas-algoritmen. (Se appendiks I i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>)

<p>
Nedenfor har vi skrevet ut \eqref{eq:33019} på matriseform.

$$
\begin{equation*}
\begin{smallmatrix}
\begin{bmatrix}
\begin{bmatrix}
c_1^{(1)} & c_1^{(2)}\\ 
c_1^{(3)} & c_1^{(4)}
\end{bmatrix}
&
\begin{bmatrix}
b_1^{(1)} & b_1^{(2)}\\ 
b_1^{(3)} & b_1^{(4)}
\end{bmatrix}
& & & & \\\\ 
\begin{bmatrix}
a_2^{(1)} & a_2^{(2)}\\ 
a_2^{(3)} & a_2^{(4)}
\end{bmatrix}
&
\begin{bmatrix}
b_2^{(1)} & b_2^{(2)}\\ 
b_2^{(3)} & b_2^{(4)}
\end{bmatrix}
&
\begin{bmatrix}
c_2^{(1)} & c_2^{(2)}\\ 
c_2^{(3)} & c_2^{(4)}
\end{bmatrix}
& & & \\ 
& \cdot & \cdot & & & \\ 
& \cdot & \cdot & & & \\ 
& \cdot & \cdot & & & \\ 
& & 
\begin{bmatrix}
a_j^{(1)} & a_j^{(2)}\\ 
a_j^{(3)} & a_j^{(4)}
\end{bmatrix}
&
\begin{bmatrix}
b_j^{(1)} & b_j^{(2)}\\ 
b_j^{(3)} & b_j^{(4)}
\end{bmatrix}
&
\begin{bmatrix}
c_j^{(1)} & c_j^{(2)}\\ 
c_j^{(3)} & c_j^{(4)}
\end{bmatrix}
&\\ 
& & &\cdot & \cdot &\\ 
& & &\cdot & \cdot &\\ 
& & &\cdot & \cdot &\\ 
& & & &
\begin{bmatrix}
a_N^{(1)} & a_N^{(2)}\\ 
a_N^{(3)} & a_N^{(4)}
\end{bmatrix}
&
\begin{bmatrix}
b_N^{(1)} & b_N^{(2)}\\ 
b_N^{(3)} & b_N^{(4)}
\end{bmatrix}
\end{bmatrix}
\cdot
\begin{bmatrix}
\begin{bmatrix}
u_1\\ 
u_1
\end{bmatrix}\\\\ 
\begin{bmatrix}
u_2\\ 
u_2
\end{bmatrix}\\ 
\cdot\\ 
\cdot\\ 
\cdot\\ 
\begin{bmatrix}
u_j\\ 
        u_j
        \end{bmatrix}\\ 
        \cdot\\ 
        \cdot\\ 
        \cdot\\ 
        \begin{bmatrix}
        u_N\\ 
        u_N
        \end{bmatrix}
\end{bmatrix}
=
\begin{bmatrix}
        \begin{bmatrix}
        d_1^{(1)}\\ 
        d_1^{(2)}
        \end{bmatrix}\\\\ 
        \begin{bmatrix}
        d_2^{(1)}\\ 
        d_2^{(2)}
        \end{bmatrix}\\ 
        \cdot\\ 
        \cdot\\ 
        \cdot\\ 
        \begin{bmatrix}
        d_j^{(1)}\\ 
        d_j^{(2)}
        \end{bmatrix}\\ 
        \cdot\\ 
        \cdot\\ 
        \cdot\\ 
        \begin{bmatrix}
        d_N^{(1)}\\ 
        d_N^{(2)}
        \end{bmatrix}
\end{bmatrix}
\end{smallmatrix}
\end{equation*}
$$

<p>
Vi ser at vi har fått en tridiagonal koeffisientmatrise der hvert element i matrisa er en \( 2 \) x \( 2 \) - matrise. En slik matrise 
kalles blokk-tridiagonal der hvert element er en blokk. Vi får ofte blokk-tridiagonale matriser når vi diskretiserer system 
av første ordens ordinære og partielle ligninger. Hadde vi f.eks. brukt 3 rør, ville hver blokk vært en \( 3 \) x \( 3 \) - matrise.

<p>
Den tridiagonale strukturen blir enda tydeligere når vi setter navn på blokkene:

$$
\begin{equation*}
\textbf{a}_j =
\begin{bmatrix}
a_j^{(1)} & a_j^{(2)}\\ 
a_j^{(3)} & a_j^{(4)}
\end{bmatrix} \ , \ \textbf{b}_j =
\begin{bmatrix}
b_j^{(1)} & b_j^{(2)}\\ 
b_j^{(3)} & b_j^{(4)}
 \end{bmatrix} \ , \ \textbf{c}_j =
\begin{bmatrix}
c_j^{(1)} & c_j^{(2)}\\ 
c_j^{(3)} & c_j^{(4)}
\end{bmatrix}
\end{equation*}
$$


$$
\begin{equation*}
\textbf{x}_j = 
\begin{bmatrix}
u_j\\ 
v_j
\end{bmatrix} \ , \ \textbf{d}_j =                                                                                                                 \begin{bmatrix}
d_j^{(1)}\\ 
d_j^{(2)}
\end{bmatrix} \ ,j=1,2,...,N
\end{equation*}
$$

<p>
slik at systemet ovenfor kan skrives:

$$
\begin{equation} \label{eq:33020}
\begin{bmatrix}
\textbf{b}_1 & \textbf{c}_1 & & & &\\ 
\textbf{a}_2 & \textbf{b}_2 & \textbf{c}_2 & & &\\ 
& \cdot & \cdot & & &\\ 
& \cdot & \cdot & & &\\ 
& \cdot & \cdot & & &\\ 
& & \textbf{a}_j & \textbf{b}_j & \textbf{c}_j &\\ 
& & & \cdot & \cdot &\\ 
& & & \cdot & \cdot &\\ 
& & & \cdot & \cdot &\\ 
& & & & \textbf{a}_N & \textbf{b}_N
\end{bmatrix}
\cdot
\begin{bmatrix}
\textbf{x}_1\\ 
\textbf{x}_2\\ 
\cdot\\ 
\cdot\\ 
\cdot\\ 
\textbf{x}_j\\ 
\cdot\\ 
\cdot\\ 
\cdot\\ 
\textbf{x}_N
\end{bmatrix}
=
\begin{bmatrix}
\textbf{d}_1\\ 
\textbf{d}_2\\ 
\cdot\\ 
\cdot\\ 
\cdot\\ 
\textbf{d}_j\\ 
\cdot\\ 
\cdot\\ 
\cdot\\ 
\textbf{d}_N
\end{bmatrix}
\end{equation}
$$

<p>
Å løse dette systemet med Douglas-algoritmen, er det samme som å bruke Thomas-algoritmen når man tar hensyn til at elementene er matriser og vektorer.

<p>
<b>Indeksering.</b>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 51:  <div id="fig:314"></div> </p></center>
<p><img src="fig-ch3/fig13.png" align="bottom" ></p>
</center>

<p>
Randbetingelser:  \( u_0 = 0 \) , \( u_N = 1 \) .

<p>
Algoritmen krever at den første ukjente har indeks 1 og den siste indeks N. Som figuren ovenfor viser, stemmer dette for det ytre røret, men ikke for det 
indre der \( v_0 \) er den første ukjente.

<p>
Vi forandrer indeksene som vist nedenfor:

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 52:  <div id="fig:313"></div> </p></center>
<p><img src="fig-ch3/fig14.png" align="bottom" width=400></p>
</center>

<p>
Får da følgende indeksering:

<p>
For u:

$$
\begin{equation} \label{eq:33021a}
 u_j \ , \ j=0,1,...,N \ , \ u_0 = 0 \text{ fra randbetingelsen}
\end{equation}
$$

<p>
For v:

$$
\begin{equation} \label{eq:33021b}
v_j \ , \ j=1,2,...,N+1 \ , \ v_{N+1} = 1 \text{ fra randbetingelsen}
\end{equation}
$$

<p>
Med den nye indekseringen i \eqref{eq:33021b},  blir systemet i \eqref{eq:33018a} nå:

$$
\begin{equation} \label{eq:33022a}
(h \cdot \alpha_y - 2) \cdot u_{j-1} + (2+h \cdot \alpha_y) \cdot u_j- h\cdot \alpha_y \cdot v_j - h \cdot \alpha_y \cdot v_{j+1} = 0
\end{equation}
$$


$$
\begin{equation} \label{eq:33022b}
h\cdot \alpha_i \cdot u_{j-1} + h\cdot \alpha_i \cdot u_j - (h\cdot \alpha_i +2)\cdot v_j + (2-h\cdot \alpha_i) \cdot v_{j+1} = 0
\end{equation}
$$

<p>
Utskrevet for \( j=1 \):

$$
\begin{equation*}
\begin{array}{rcl}
(2+h\cdot \alpha_y)\cdot u_1 -h\cdot \alpha_y \cdot v_1 - h\cdot \alpha_y \cdot v_2 &= 0\\ 
h\cdot \alpha_i \cdot u_1 - (h\cdot \alpha_i + 2)\cdot v_1 + (2-h\cdot \alpha_i) \cdot v_2 &= 0
\end{array}
\end{equation*}
$$

<p>
hvor vi har benyttet \( u_0 = 0 \) fra randbetingelsen.

<p>
Utskrevet for \( j = N \):

$$
\begin{equation*}
\begin{array}{rcl}
(h \cdot \alpha_y - 2 )\cdot u_{N-1} + (2 +h \cdot \alpha_y)\cdot u_N - h \cdot \alpha_y \cdot v_N &= h \cdot \alpha_y\\ 
h\cdot \alpha_i \cdot u_{N-1} + h\cdot \alpha_i \cdot u_N - (h \cdot \alpha_i + 2) \cdot v_N &= h \cdot \alpha_i -2
\end{array}
\end{equation*}
$$

<p>
hvor vi har brukt \( v_{N+1} = 1 \) fra randbetingelsen. Ved å sammenligne vårt system ovenfor med basissystemet i \eqref{eq:33019}, får vi følgende 
koeffisienter for bruk i Douglas-algoritmen:

$$
\begin{equation} \label{eq:33023}
\begin{array}{rlllllrllrll}
\alpha_j^{(1)}  &= h\cdot \alpha_y - 2\ ,& \ \alpha_j^{(2)}     &= 0 \                  ,&\ b_j^{(1)}   &=2+ h\cdot \alpha_y \  ,& \  b_j^{(2)}     &=-h\cdot \alpha_y\\ 
c_j^{(1)}       &= 0                    ,& \ c_j^{(2)}          &= -h\cdot \alpha_y \   ,&\ d_j^{(1)}   &=0 \                   ,& \ j              &=1,2,...,N-1\\ 
\alpha_j^{(3)}  &=  h\cdot \alpha_i \   ,& \ \alpha_j^{(4)}     &= 0 \                  ,&\  b_j^{(3)}  &= h \cdot \alpha_i \   ,& \  b_j^{(4)}     &= -(h \cdot \alpha_i +2)\\ 
c_j^{(3)}       &= 0 \                  ,& \ c_j^{(4)}          &= 2-h\cdot \alpha_i \  ,&\ d_j^{(2)}   &= 0 \                  ,& \ j              &= 1,2,...,N-1
\end{array}
\end{equation}
$$

<p>
hvor \( \alpha_1^{(1)} \) og \( \alpha_1^{(2)} \)  ikke brukes.

<p>
For \( j=N \) blir utrykkene som i \eqref{eq:33023} bortsett fra \( d_N^{(1)} = h\cdot \alpha_y \) og  \( d_N^{(2)} = h\cdot \alpha_i -2 \) . \( c_N^{(2)} \) og 
\( c_N^{(4)} \) brukes ikke. Et eksempel med \( N=6 \) er gitt vist nedenfor.

$$
\begin{equation} \label{eq:33024}
\begin{bmatrix}
b_{1}^{(1)}    & b_{1}^{(2)}     & 0             & c_{1}^{(2)}     &              &               &                       &               &                &               &               &               \\ 
b_{1}^{(3)}    & b_{1}^{(4)}     & 0             & c_{1}^{(4)}     & 0            &               &                       &               &                &               &               &               \\ 
a_{2}^{(1)}    & 0               & b_{2}^{(1)}   & b_{2}^{(2)}     & 0            & c_{2}^{(2)}   &                       &               &                &               &               &               \\ 
a_{2}^{(3)}    & 0               & b_{2}^{(3)}   & b_{2}^{(4)}     & 0            & c_{2}^{(4)}   & 0                     &               &                &               &               &               \\ 
               & 0               & a_{3}^{(1)}   & 0               & b_{3}^{(1)}  & b_{3}^{(2)}   & 0                     & c_3^{(2)}     &                &               &               &               \\ 
               &                 & a_{3}^{(3)}   & 0               & b_{3}^{(3)}  & b_{3}^{(4)}   & 0                     & c_3^{(4)}     & 0              &               &               &               \\ 
               &                 &               & 0               & a_{4}^{(1)}  & 0             & b_{4}^{(1)}           & b_4^{(2)}     & 0              & c_4^{(2)}     &               &               \\ 
               &                 &               &                 & a_{4}^{(3)}  & 0             & b_{4}^{(3)}           & b_4^{(4)}     & 0              & c_4^{(4)}     & 0             &               \\ 
               &                 &               &                 &              & 0             & a_{5}^{(1)}           & 0             & b_5^{(1)}      & b_5^{(2)}     & 0             & c_5^{(2)}     \\ 
               &                 &               &                 &              &               & a_{5}^{(3)}           & 0             & b_5^{(3)}      & b_5^{(4)}     & 0             & c_5^{(4)}     \\ 
               &                 &               &                 &              &               &                       & 0             & a_6^{(1)}      & 0             & b_6^{(1)}     & b_6^{(2)}     \\ 
               &                 &               &                 &              &               &                       & 0             & a_6^{(3)}      & 0             & b_6^{(3)}     & b_6^{(4)}
\end{bmatrix}
\cdot
\begin{bmatrix}
u_1\\ 
v_1\\ 
u_2\\ 
v_2\\ 
u_3\\ 
v_3\\ 
u_4\\ 
v_4\\ 
u_5\\ 
v_5\\ 
u_6\\ 
v_6\\ 
\end{bmatrix}
=
\begin{bmatrix}
0\\ 
0\\ 
0\\ 
0\\ 
0\\ 
0\\ 
0\\ 
0\\ 
0\\ 
0\\ 
0\\ 
d_6^{(1)}\\ 
d_6^{(2)}\\ 
\end{bmatrix}
\end{equation}
$$

<p>
Sammenlignet med det generellle systemet ser vi at fire av halv-diagonalene forsvinner i vårt tilfelle: \( a_j^{(2)} \) , \( a_j^{(4)} \) , \( c_j^{(1)} \), og 
\( c_j^{(3)} \) . Dersom det er behov for å spare denne plassen, kan vi skrive en spesiell versjon som ikke bruker disse vektorene. 
(Se Fortran-funksjonen <b>bitris</b> i appendiks I i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>som også finnes i Matlab-versjon)

<h2 id="___sec49">Example: Talleksempel </h2>

<p>
Vi skal avkjøle smøreoljen fra et gassturbinanlegg. Oljen har en temperatur på \( 100^\circ \) C. Til disposisjon har vi vann med temperatur på \( 30^\circ \) C. 
Andre data:

$$
\begin{equation*}
\begin{array}{llll}
&\text{Rørlengde: }                     &L         &=  61m\\ 
&\text{Rørdiameter: }                   &d         &= 0.025m\\ 
&\text{Omkrets av rør: }                &P         &= \pi \cdot d = 0.07854m\\ 
&\text{Massestrøm: }                    &\dot m_y  &= 0.1 \text{ og } \dot m_i = 0.23 kJ/s\\ 
&\text{Totalt varmeovergangstal: }      &\bar{h}   &= 40 W/m^2/^\circ C\\ 
&\text{Egenvarme: }                     & c_y      &= 2130 \text{ og } c_i = 4180 J/Kg/^\circ C
\end{array}
\end{equation*}
$$

Med disse data, får vi følgende verdier for koeffisientene \( \alpha_y \) og \( \alpha_i \):

$$
\begin{equation} \label{eq:33025a}
\alpha_y = \frac{\bar{h}PL}{\dot m_y c_y} \approx 0.9 \ , \ \alpha_i = \frac{\bar{h}PL}{\dot m_ic_i} \approx 0.2
\end{equation}
$$

<p>
Referansetemperaturene i \eqref{eq:3306} og \eqref{eq:33012}:

$$
\begin{equation} \label{eq:33025b}
T_{ir} = T_i(L) = 30^\circ C \ , \ T_{yr} = T_y(0) = 100^\circ C
\end{equation}
$$

<p>
som gir forbindelsen mellom dimensjonsløs og dimensjonelle temperaturer:

$$
\begin{equation} \label{eq:33026}
T_y(x) = 100 - 70 \cdot u(x) \ , \ T_i (x) = 100 - 70 \cdot v(x)
\end{equation}
$$

<p>
Legg merke til at vi bruker den dimensjonsløse koordinaten x i \eqref{eq:33026}.

<p>
Tabellen viser resultatene  ved å løse \eqref{eq:33024} med koeffisienter gitt i \eqref{eq:33023} ved bruk av bitris gitt i appendiks I i 
<a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>. Vi ser av tabellen at smøroljen blir avkjølt fra \( 100^\circ \) C til \( 60.4^\circ \) C, mens vannets temperatur 
stiger fra \( 30^\circ \) C til \( 38.8^\circ \) C. Temperaturforløpet i tabellen er vist  i Figure <a href="#fig:315">53</a>.

<p>
Selv om vi ikke har noen direkte analytisk løsning å sammenligne med, indikerer den små forskjellen mellom løsningene for h \( = \) 0.1 og h \( = \)  0.01 at 
tabellverdiene sannsynligvis er temmelig nøyaktige. En delvis bekreftelse kan fås ved å bruke den analytiske løsningen i \eqref{eq:33014a} som innsatt for 
tallverdiene for dette eksemplet blir:

$$
\begin{equation} \label{eq:33027}
\begin{array}{l}
u(x) = v_0 \frac{9}{7}[1-e^{-0.7\cdot x}]\\ 
v(x) = v_0[1 + \frac{2}{7}(1-e^{-0.7\cdot x})]
\end{array}
\end{equation}
$$

<p>

<div class="row">
  <div class="col-xs-12">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( h = 0.1 \)</td> <td align="center"><b> x </b></td> <td align="center">\( T_y(^\circ \) C)</td> <td align="center">\( T_i(^\circ \) C)</td> <td align="center">\( h=0.01 \)</td> <td align="center"><b> x </b></td> <td align="center">\( T_y(^\circ) C \)</td> <td align="center">\( T_i(^\circ  \) C)</td> </tr>
</thead>
<tbody>
<tr><td align="center">                    </td> <td align="center">   0.0    </td> <td align="center">   100.00000              </td> <td align="center">   38.80441               </td> <td align="center">                   </td> <td align="center">   0.0    </td> <td align="center">   100.00000              </td> <td align="center">   38.80226                </td> </tr>
<tr><td align="center">                    </td> <td align="center">   0.1    </td> <td align="center">   94.67864               </td> <td align="center">   37.62189               </td> <td align="center">                   </td> <td align="center">   0.1    </td> <td align="center">   94.68054               </td> <td align="center">   37.62016                </td> </tr>
<tr><td align="center">                    </td> <td align="center">   0.2    </td> <td align="center">   89.71719               </td> <td align="center">   36.51934               </td> <td align="center">                   </td> <td align="center">   0.2    </td> <td align="center">   89.72070               </td> <td align="center">   36.31798                </td> </tr>
<tr><td align="center">                    </td> <td align="center">   0.3    </td> <td align="center">   85.09129               </td> <td align="center">   35.49137               </td> <td align="center">                   </td> <td align="center">   0.3    </td> <td align="center">   85.09618               </td> <td align="center">   35.49031                </td> </tr>
<tr><td align="center">                    </td> <td align="center">   0.4    </td> <td align="center">   80.77825               </td> <td align="center">   34.53291               </td> <td align="center">                   </td> <td align="center">   0.4    </td> <td align="center">   80.78431               </td> <td align="center">   34.53211                </td> </tr>
<tr><td align="center">                    </td> <td align="center">   0.5    </td> <td align="center">   76.75692               </td> <td align="center">   33.63928               </td> <td align="center">                   </td> <td align="center">   0.5    </td> <td align="center">   76.76395               </td> <td align="center">   33.63870                </td> </tr>
<tr><td align="center">                    </td> <td align="center">   0.6    </td> <td align="center">   73.00756               </td> <td align="center">   32.80609               </td> <td align="center">                   </td> <td align="center">   0.6    </td> <td align="center">   73.01539               </td> <td align="center">   32.80569                </td> </tr>
<tr><td align="center">                    </td> <td align="center">   0.7    </td> <td align="center">   69.51178               </td> <td align="center">   32.02925               </td> <td align="center">                   </td> <td align="center">   0.7    </td> <td align="center">   69.52026               </td> <td align="center">   32.02899                </td> </tr>
<tr><td align="center">                    </td> <td align="center">   0.8    </td> <td align="center">   66.25243               </td> <td align="center">   31.30495               </td> <td align="center">                   </td> <td align="center">   0.8    </td> <td align="center">   66.26142               </td> <td align="center">   31.30480                </td> </tr>
<tr><td align="center">                    </td> <td align="center">   0.9    </td> <td align="center">   63.21352               </td> <td align="center">   30.62964               </td> <td align="center">                   </td> <td align="center">   0.9    </td> <td align="center">   63.22291               </td> <td align="center">   30.62958                </td> </tr>
<tr><td align="center">                    </td> <td align="center">   1.0    </td> <td align="center">   60.38014               </td> <td align="center">   30.00000               </td> <td align="center">                   </td> <td align="center">   1.0    </td> <td align="center">   60.38981               </td> <td align="center">   30.00000                </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-12 -->
<p>
Løsning av lign. \eqref{eq:33024}

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 53:  <div id="fig:315"></div> </p></center>
<p><img src="fig-ch3/fig15.png" align="bottom" width=400></p>
</center>

<p>

<!-- begin inline comment -->
<font color="red">(<b>Marie 10</b>: figuren har norske forklaringer.)</font>
<!-- end inline comment -->

<p>
Verdien av \( v_0 \equiv v(0) \) er ukjent og må beregnes numerisk. Ved å utføre beregningen for forskjellige verdier av <em>h</em>, får vi følgende tabell:

<p>

<div class="row">
  <div class="col-xs-1">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>  h  </b></td> <td align="center">\( v_0 \) </td> </tr>
</thead>
<tbody>
<tr><td align="center">   0.100    </td> <td align="center">   0.87422266    </td> </tr>
<tr><td align="center">   0.050    </td> <td align="center">   0.87424592    </td> </tr>
<tr><td align="center">   0.010    </td> <td align="center">   0.87425336    </td> </tr>
<tr><td align="center">   0.005    </td> <td align="center">   0.87425359    </td> </tr>
<tr><td align="center">   0.001    </td> <td align="center">   0.87425359    </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-1 -->
<p>
Dersom vi aksepterer \( v_0- \) verdien for \( h = 0.001 \) som den "rette", kan vi bruke denne i \eqref{eq:33027} og deretter sammenligne med tabellverdiene. 
Gjør vi det, finner vi at den relative feilen for \( h = 0.1 \) ligger i intervallet \( [10^{-4},\ 10^{-5}] \) mens den for h \( = \) 0.01 ligger i intervallet 
\( [10^{-6},\ 10^{-7}] \) . Dette viser at differanseskjemaet er av \( O(h^2) \), i overenstemmelse med teorien.

<p>
I kapittel 6 avsnitt 7 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a> behandler vi det ikke-stasjonære tilfellet av dette eksemplet.

<p>
<b>Bruk av Richardson ekstrapolering</b>

<p>
Denne teknikken som er velkjent ved Romberg-integrasjon, kan ofte brukes til å forbedre verdier som er funnet ved bruk av differanse-metoder. 
(Se avsnitt 4.3 i C&amp;K <a href="#cheney1999numerical">[7]</a> ). La oss anta at den korrekte verdien er <em>y</em>, mens vi har funnet en tilnærmelse \( y_1 \)  med bruk av 
skritt lengden \( h_1 \). Dessuten antar vi at forbindelsen mellom \( y \) og \( y_1 \) er gitt ved:

$$
\begin{equation} \label{eq:33028}
y_1 = y + A\cdot h_1^k + B \cdot h _1^{k+1}+\dots
\end{equation}
$$

<p>
der A og B er konstanter.

<p>
Dersom vi nå beregner to tilnærmelser \( y_1 \) og \( y_2 \) med to forskjellige verdier \( h_1 \) og \( h_2 \), får vi to ligninger av typen \eqref{eq:33028} og kan 
dermed eliminere A med følgende resultat:

$$
\begin{equation} \label{eq:33029}
\frac{h_2^k \cdot y_1 - h_1^k \cdot y_2}{h_2^k - h_1^k} = y + B\cdot \left( \frac{h_2^kh_1^{k+1}-h_1^kh_2^{k+1}}{h_2^k - h_1^k} \right)+\dots
\end{equation}
$$

<p>
\eqref{eq:33029} kan kalles \( h^k \)- ekstrapoleringsformelen. Spesielt for k \( = \) 2 og \( h_2 = \frac{1}{2}h_1 \)  får vi fra \eqref{eq:33029}:

$$
\begin{equation} \label{eq:33030}
y \approx y_2 + \frac{1}{3}(y_2-y_1)
\end{equation}
$$

<p>
med en feil \( \frac{1}{6}Bh_1^3+\dots  \)

<p>
I noen tilfeller er vi så heldige at B \( = \) 0. Da  blir feilen av \( O(h_1^4) \). Dette er nettopp tilfelle for to-punkts metoden. For denne metoden får vi 
fra \eqref{eq:3304} med \( h = h_1 \):

$$
\begin{equation} \label{eq:33031}
\textbf{y}(x_j) = \textbf{y}_j(h) + h^2\textbf{e}(x_j) + O(h^4)\ , \ j=0,1...,N
\end{equation}
$$

<p>
En tilstrekkelig betingelse for at \eqref{eq:33031} gjelder er at \eqref{eq:3301a} har kontinuerlig femte derivert på det aktuelle intervallet. 
(Se Keller <a href="#forsythe77numerical">[11]</a> ). Med vår notasjon blir \eqref{eq:33030}:

$$
\begin{equation} \label{eq:33032}
\textbf{y}(x_j) = \textbf{y}_j\left(\frac{h}{2}\right) + \frac{1}{3}\left[ \textbf{y}_j\ \left( \frac{h}{2}\right) - \textbf{y}_j(h)\right] + \textbf{O}(h^4)
\end{equation}
$$

<p>

<div class="row">
  <div class="col-xs-8">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( T_{ytre} \)</td> <td align="center"><b> x </b></td> <td align="center">\( h = 0.2 \)</td> <td align="center">\( h=0.1 \)</td> <td align="center"><b>Ekstrapol.</b></td> <td align="center">\( h=2\cdot10^3 \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">                     </td> <td align="center">   0.0    </td> <td align="center">   100.0000         </td> <td align="center">   100.00000      </td> <td align="center">   100.00000     </td> <td align="center">   100.00000             </td> </tr>
<tr><td align="center">                     </td> <td align="center">   0.1    </td> <td align="center">                    </td> <td align="center">   94.67864       </td> <td align="center">                 </td> <td align="center">                         </td> </tr>
<tr><td align="center">                     </td> <td align="center">   0.2    </td> <td align="center">   89.70651         </td> <td align="center">   89.71719       </td> <td align="center">   89.72075      </td> <td align="center">   89.72073              </td> </tr>
<tr><td align="center">                     </td> <td align="center">   0.3    </td> <td align="center">                    </td> <td align="center">   85.09129       </td> <td align="center">                 </td> <td align="center">                         </td> </tr>
<tr><td align="center">                     </td> <td align="center">   0.4    </td> <td align="center">   80.75984         </td> <td align="center">   80.77825       </td> <td align="center">   80.78439      </td> <td align="center">   80.78437              </td> </tr>
<tr><td align="center">                     </td> <td align="center">   0.5    </td> <td align="center">                    </td> <td align="center">   76.75692       </td> <td align="center">                 </td> <td align="center">                         </td> </tr>
<tr><td align="center">                     </td> <td align="center">   0.6    </td> <td align="center">   72.98376         </td> <td align="center">   73.00756       </td> <td align="center">   73.01549      </td> <td align="center">   73.01547              </td> </tr>
<tr><td align="center">                     </td> <td align="center">   0.7    </td> <td align="center">                    </td> <td align="center">   69.51178       </td> <td align="center">                 </td> <td align="center">                         </td> </tr>
<tr><td align="center">                     </td> <td align="center">   0.8    </td> <td align="center">   66.22511         </td> <td align="center">   66.25243       </td> <td align="center">   66.26154      </td> <td align="center">   66.26151              </td> </tr>
<tr><td align="center">                     </td> <td align="center">   0.9    </td> <td align="center">                    </td> <td align="center">   63.21352       </td> <td align="center">                 </td> <td align="center">                         </td> </tr>
<tr><td align="center">                     </td> <td align="center">   1.0    </td> <td align="center">   60.35076         </td> <td align="center">   60.38014       </td> <td align="center">   60.38993      </td> <td align="center">   60.38990              </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-8 -->
<p>
I tabellen ovenfor har vi beregnet temperaturen \( T_y \) i det ytre røret ; først med
h$=$0.2 , så med h$=$0.1 og deretter ekstrapolert verdiene etter formelen i \eqref{eq:33032}
I følge denne formelen skal vi da få verdier med nøyaktighet av  \( O(h^4) \) som i dette tilfellet blir \( O(0.2^4) = O(10^{-5}) \approx 2\cdot 10^{-3} \) 
som eksempel. I den siste kolonnen har vi utført beregningen med \( h=2\cdot 10^{-3}  \) med verdier som viser at teorien stemmer.

<p>
<!-- !split -->

<h1 id="ch3:sec4">Linearinsering av ikke-linære algebraiske ligninger</h1>

<p>
Som eksempel, bruker vi problemet i avsnitt (<a href="#ch3:sec22">Ribbe med variabelt tverrsnitt</a>):

$$
\begin{equation} \label{eq:3401}
\begin{array}{l}
y''(x) = \frac{3}{2}y^2\\ 
y(0) = 4 \ , \ y(1) = 1
\end{array}
\end{equation}
$$

<p>
der en av løsningene er gitt ved:

$$
\begin{equation} \label{eq:3402}
y = \frac{4}{(1+x)^2}
\end{equation}
$$

<p>
Vi diskretiserer\eqref{eq:3401} med bruk av sentraldifferanser for \( y''(x) \) :

$$
\begin{equation*}
\frac{y_{i+1}-2y_i+y_{i-1}}{h^2}= \frac{3}{2}y_i^2
\end{equation*}
$$

<p>
eller ordnet:

$$
\begin{equation} \label{eq:3403}
y_{i-1} - \left( 2+\frac{3}{2}h^2y_i\right)y_i + y_{i+1} = 0
\end{equation}
$$

<p>
med h = \( \Delta x \)

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 54:  <div id="fig:316"></div> </p></center>
<p><img src="fig-ch3/fig16.png" align="bottom" width=400></p>
</center>

<p>
Vi har delt intervallet \( [ 0, 1] \) i \( N + 1 \) deler der \( h=1/(N+1) \) og \( x_i = h\cdot i \) , \( i = 0,1,...,N+1 \). Da \( y_0 = 4 \) og \( y_{N+1}  = 1 \), 
blir \eqref{eq:3403}:

$$
\begin{equation} \label{eq:3404}
\begin{array}{rl}
-\left( 2+\frac{3}{2}h^2y_1 \right) y_1 + y_2 &= -4 \\ 
& \dots \\ 
y_{i-1} - \left(2+\frac{3}{2}h^2y_i\right) y_i+y_{i+1} &= 0 \\ 
& \dots \\ 
y_{N-1} - \left( 2 + \frac{3}{2}h^2y_N\right) y_N &= -1 \\ 
\text{der } i = 2,3,...N-1\\ 
\end{array}
\end{equation}
$$

<p>
Koeffisientmatrisa for \eqref{eq:3404} er tridiagonal, men systemet er ikke-lineært. (Et system av 2. grads ligninger). Vi har ikke formler som kan løse 
slike system, og settet må derfor lineariseres. La oss skal se nærmere på to metoder for å  utføre denne lineariseringen.

<h2 id="___sec51">Metoden med etterslep </h2>

<p>
Da ligningsystemet er ikke-lineært, må vi utføre en iterasjonsprosess. La \( y_i^{m+1} \) og \( y_i^m \) være løsningen av den diskretiserte ligningen 
\eqref{eq:3403} eller \eqref{eq:3404} for  henholdsvis iterasjon \( m+1 \) og \( m \) . Metoden med etterslep går ut på å erstatte  avhengige variable ved 
iterasjon \( m+1 \) med tilsvarende variable fra iterasjon \( m \) helt til vi bare har lineære ledd. I \eqref{eq:3403} og \eqref{eq:3404} er det  \( y^2 \)-leddet 
som forårsaker ikke-lineariteten og som derfor må lineariseres. Skriver ut \eqref{eq:3404}:

$$
\begin{equation} \label{eq:3415}
\begin{array}{rl}
-\left( 2 + \frac{3}{2}y_1^{m+1}h^2\right)y_1^{m+1} + y_2^{m+1} &= -4\\ 
y_{i-1}^{m+1} - \left( 2 + \frac{3}{2}y_i^{m+1}h^2\right)y_i^{m+1} + y_{i+1}^{m+1} &= 0\\ 
_{N-1}^{m+1} - \left( 2 + \frac{3}{2}y_N^{m+1}h^2\right) y_N^{m+1} &= -1
\end{array}
\end{equation}
$$

<p>
der \( i = 2,3,...N-1 \) , \( m = 0,1,2,... \)

<p>
Lineariseringen består nå i å erstatte \( \frac{3}{2}h^2y_1^{m+1} \) , \( \frac{3}{2}h^2y_i^{m+1} \) og \( \frac{3}{2}h^2y_N^{m+1} \) med \( \frac{3}{2}h^2y_1^m \) , 
\( \frac{3}{2}h^2y_i^m \) og \( \frac{3}{2}h^2y_N^m \) slik at vi får følgende lineære system:

$$
\begin{equation} \label{eq:3416}
\begin{array}{rl}
-\left( 2 + \frac{3}{2}y_1^{m}h^2\right)y_1^{m} + y_2^{m} &= -4 \\ 
y_{i-1}^{m} - \left( 2 + \frac{3}{2}y_i^{m}h^2\right)y_i^{m} + y_{i+1}^{m} &= 0 \\ 
_{N-1}^{m} - \left( 2 + \frac{3}{2}y_N^{m}h^2\right) y_N^{m} &= -1
\end{array}
\end{equation}
$$

<p>
der \( i = 2,3,...N-1 \) , \( m = 0,1,2,... \)

<p>
Vi har nå fått et lineært, tridiagonalt system som kan løses med Thomas-algoritmen. For å starte iterasjonsprosessen, må vi tippe verdier  for \( y_i^0 \) , 
\( i=1,2,...N \). Dersom vi ikke har spesielle opplysninger, kan vi f.eks. tippe \( y_i^0 = 0 \), \( i = 1,2,...N \). Gode startverdier vil generelt gi raskere 
konvergens.  Vi må også huske å teste for diagonal-dominans når vi bruker <b>tdma</b>. For \eqref{eq:3416} blir kravet:

$$
\begin{equation*}
\left| 2+\frac{3}{2}y_i^mh^2 \right| \ge 2 \ , \ i=1,2,...,N
\end{equation*}
$$

<p>
som er oppfylt dersom alle \( y_i^m > 0 \). Av Figure <a href="#fig:28">20</a> ser vi at dette kravet er oppfylt for den ene løsningen, men ikke for den andre. Når denne 
betingelsen ikke er oppfylt, kan det være fornuftig å bruke en løsningsrutine med pivotering, f.eks. <b>tripiv</b> istedenfor <b>tdma</b>. Når vi ikke vet hvoran 
iterasjonsprosessen vil foreløpe, er det lurt å bare bruke antall iterasjoner som et stoppkrav. Etter vi har fått innsikt i iterasjonsforløpet, kan vi 
legge til andre stoppkriterier. Endel eksempler er vist i avsnitt (<a href="#ch3:sec43">Eksempler på stoppkriterier</a>)

<p>
Matlabprogrammet <b>delay34</b> gir følgende resultat med \( h=0.05 \) :

<p>

<div class="row">
  <div class="col-xs-1">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>Itr.</b></td> <td align="center"><b>max. avvik</b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   1       </td> <td align="center">   1.000e+000    </td> </tr>
<tr><td align="center">   2       </td> <td align="center">   5.525e-001    </td> </tr>
<tr><td align="center">   3       </td> <td align="center">   1.104e-001    </td> </tr>
<tr><td align="center">   4       </td> <td align="center">   2.632e-002    </td> </tr>
<tr><td align="center">   5       </td> <td align="center">   5.892e-003    </td> </tr>
<tr><td align="center">   6       </td> <td align="center">   1.328e-003    </td> </tr>
<tr><td align="center">   7       </td> <td align="center">   2.980e-004    </td> </tr>
<tr><td align="center">   8       </td> <td align="center">   6.690e-005    </td> </tr>
<tr><td align="center">   9       </td> <td align="center">   1.502e-005    </td> </tr>
<tr><td align="center">   10      </td> <td align="center">   3.370e-006    </td> </tr>
<tr><td align="center">   11      </td> <td align="center">   7.562e-007    </td> </tr>
<tr><td align="center">   12      </td> <td align="center">   1.697e-007    </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-1 -->
<p>
Max. avvik betyr her det maksimale relative avviket. Løsningen av differanseligningen konvergerer langsomt mot  løsningen \( y_I = \dfrac{4}{(1+x)^2} \) som 
vist på (<a href="#fig:28">20</a>) i avsnitt (<a href="#ch2:sec2">Ikke-lineære ligninger</a>) . Den maksimale relative feilen i løsningen er \( \approx 5.6 \cdot 10^{-4}) \) som ikke kan minskes uten å minske skrittlengden 
<em>h</em>.

<p>
Fordelen med denne metoden er at lineariseringsprosessen er enkel. Bakdelen er at den konvergerer ofte langsomt, samt at vi gjerne må ha gode 
startverdier for å få konvergens. Når vi vet hvordan iterasjonen forløper, kan vi som nevnt ovenfor, legge inn et stoppkriterium basert på et 
iterasjonsavvik. Iterasjonsløkka kan nå f.eks. se ut som vist nedenfor:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">it = 0; itmax = 10 ; dymax = 1.0; RelTol = 1.0e-5;
d = 0 ; % høyre side  
d(1) =  - 4.0; d(n) = - 1.0; 
while (dymax &gt; RelTol) &amp; (it &lt; itmax) 
        it = it + 1;     b = -(2.0 + fac*ym); % hoveddiagonal    
        ym1 = tdma(a,b,c,d); % Løser ligningsystemet    
        dymax = max(abs((ym1-ym)./ym1));% Beregner relativ avvik    
        ym = ym1; % Oppdatering    fprintf(&#39; %10d     %12.3e \n&#39;,it,dymax);
end
</pre></div>
<p>
Legg merke til at for å starte iterasjonsløkka, må <em>dymax</em> være større enn <em>RelTol</em>

<h2 id="ch3:sec42">Newton-linearisering</h2>

<p>
Før vi setter opp den formelle utviklingen,  viser vi en variant som er enkel å bruke når ikke-linearitetene er rene produkt.

$$
\begin{equation} \label{eq:3427}
\text{Setter } y^{m+1}_i = y_i^m + \delta y_i
\end{equation}
$$

<p>
der \( \delta y_i \) er avviket (residuet) mellom \( y_i \) -verdiene for de to iterasjonene.
Ved bruk av \eqref{eq:3427} :

$$
\begin{equation} \label{eq:3428}
\begin{array}{rcl}
\left( y_i^{m+1} \right)^2 &= \left( y_i^m + \delta y_i \right)^2 = (y_i^m)^2 + 2y_i^m \cdot \delta y_i + (\delta y_i^m)^2\\ 
&\approx (y_i^m)^2 + 2 y_i^m \cdot \delta y_i = y_i^m(2y_i^{m+1}-y_i^m)
\end{array}
\end{equation}
$$

<p>
Lineariseringen består i å neglisjere \( (\delta y)^2 \) som liten i forhold til de andre leddene.

<p>
\eqref{eq:3428} innsatt i \eqref{eq:3404} gir følgende system:

$$
\begin{equation} \label{eq:3429}
\begin{array}{rcl}
-(2+3y_1^mh^2)y_1^{m+1} + y_2^{m+1} &= -\frac{3}{2}(y_i^mh)^2 -4\\\\ 
y_{i-1}^{m+1} - (2+3y_i^mh^2)y_i^{m+1} + y_{i+1}^{m+1}&= -\frac{3}{2}(y_i^mh)^2\\\\ 
y_{N-1}^{m+1}- (2+3y_N^mh^2)y_N^{m+1} &= -\frac{3}{2}(y_N^mh)^2 -1\\ 
\end{array}
\end{equation}
$$

<p>
der \( i = 2,3,...,N-1 \ , \ N-1 , m=m=0,1,2,... \)

<p>
Vi har igjen fått et lineært, tridiagonalt system som kan løses med Thomas-algoritmen. Velger samme startverdier som i foregående versjon. 
Matlabprogrammet <b>taylor34</b> gir følgende resultat med \( h=0.05 \) :

<p>

<div class="row">
  <div class="col-xs-1">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>Itr.</b></td> <td align="center"><b>max. avvik</b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   1       </td> <td align="center">   1.000e+000    </td> </tr>
<tr><td align="center">   2       </td> <td align="center">   3.765e-001    </td> </tr>
<tr><td align="center">   3       </td> <td align="center">   2.479e-002    </td> </tr>
<tr><td align="center">   4       </td> <td align="center">   9.174e-005    </td> </tr>
<tr><td align="center">   5       </td> <td align="center">   1.175e-009    </td> </tr>
<tr><td align="center">   6       </td> <td align="center">   2.405e-015    </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-1 -->
<p>
Vi ser at iterasjonsprosessen nå går mye raskere enn ved etterslep-metoden. Riktignok langsomt i starten, men fra tredje iterasjon har vi rask 
konvergens. Lineariseringen i \eqref{eq:3427} og \eqref{eq:3428} er egentlig en Taylorutvikling der vi  rekkeutvikler rundt iterasjon <em>m</em> og bare beholder 
de to første leddene. Kaller det ikke-lineære leddet som skal lineariseres for <em>F</em> og antar at <em>F</em> er funksjon av den avhengige variable <em>z</em>  i punktet 
<em>i</em> ved iterasjon \( m + 1 \) : Vi skal linearisere leddet \( F(z_i)\big|^{m+1}\equiv F(z_i)_{m+1} \) . Bruker den siste notasjonen i fortsettelsen.

<p>
Rekkeutvikling:

$$
\begin{equation} \label{eq:34210}
\begin{array}{c}
F(z_i)_{m+1} \approx F(z_i)_m + \delta z_i \left(\dfrac{\partial F}{dz_i}\right)_m\\ 
\text{der } \delta z_i = z_i^{m+1} - z_i^m
\end{array}
\end{equation}
$$

<p>
I  tilfellet ovenfor:

$$
\begin{equation*}
\delta z_i \to \delta y_i \ , \ z_i^{m+1} \to y_i^{m+1} \ , \ z_i^m \to y_i^m \ , \ F(y_i)_{m+1} = (y_i^{m+1})^2 \ , \ F(y_i)_m = (y_i^m)^2
\end{equation*}
$$

<p>
som innsatt i \eqref{eq:34210} gir: \( (y_i^{m+1})^2 \approx (y_i^m)^2 + 2y_i^m \cdot \delta y_i \)  som er identisk med \eqref{eq:3428} . Fremgangsmåten i 
\eqref{eq:34210} kalles ofte <em>Newton-linearisering</em>.

<p>
I mange tilfeller inngår flere indekser i det ikke-linære leddet. Anta f.eks at vi har et ledd der både \( z_i \) og \( z_{i+1} \) inngår. Vi bruker da 
Taylorutvikling for to variable:

$$
\begin{equation} \label{eq:34211}
\begin{array}{c}
F(z_i,z_{i+1})_{m+1} \approx F(z_i,z_{i+1})_m + \delta z_i \left(\dfrac{\partial F}{\partial z_i}\right)_m + \delta z_{i+1} \left( \dfrac{\partial F}{\partial z_{i+1}} \right)_m\\ \\ 
\text{der } \delta z_i = z_i^{m+1} - z_i^m \ , \ \delta z_{i+1} = z_{i+1}^{m+1} - z_{i+1}^m
\end{array}
\end{equation}
$$

<p>
Dersom både \( z_{i-1},z_i \) og \( z_{i+1} \)  inngår, får vi:

$$
\begin{equation} \label{eq:34212}
\begin{array}{l}
F(z_{i-1},z_i,z_{i+1})_{m+1} \approx F(z_{i-1},z_i,z_{i+1})_m\\\\ 
+ \delta z_{i-1} \left( \dfrac{\partial F}{\partial z_{i-1}}\right)_m + \delta z_{i} \left( \dfrac{\partial F}{\partial z_{i}}\right)_m + \delta z_{i+1} \left( \dfrac{\partial F}{\partial z_{i+1}}\right)_m\\\\ 
\text{der } \delta z_{i-1} = z_{i-1}^{m+1} - z_{i-1}^m \ , \ \delta z_{i} = z_{i}^{m+1} - z_{i}^m \ , \ \delta z_{i+1} = z_{i+1}^{m+1} - z_{i+1}^m
\end{array}
\end{equation}
$$

<p>
Tilsvarende for flere indekser.

<h2 id="ex:35">Example:</h2>

<p>
Gitt differensialligningen \( y''(x) + y(x)\sqrt{y(x)} = 0 \) som diskretisert med sentral-differanser blir:

$$
\begin{equation*} \label{ex:351}
y_{i+1}^{m+1} - 2y_i^{m+1} + y_{i-1}^{m+1} + h^2y_i^{m+1}\sqrt{y_i^{m+1}}= 0 \text{ ved iterasjon $m+1$.}
\end{equation*}
$$

<p>
Det er leddet \( y_i^{m+1} \cdot \sqrt{y_i^{m+1}} \) som er ikke-lineært og må lineariseres. I dette tilfellet har vi bare et indeks og vi bruker 
\eqref{eq:34210} med  \( z_i \to y_i \) og \( F(y_i) = y_i^{\frac{3}{2}} \) :

$$
\begin{equation*}
\begin{array}{c}
F(y_i)_{m+1} \approx F(y_i)_m + \delta y_i \left( \dfrac{\partial F}{\partial y_i}\right)_m = (y_i^m)^{\frac{3}{2}} + \delta y_i \cdot \frac{3}{2} \cdot (y_i^m)^{\frac{1}{2}} \text{ eller }\\\\ 
y_i^{m+1}\sqrt{y_i^{m+1}}\approx y_i^m\sqrt{y_i^m}+\frac{3}{2}\cdot \sqrt{y_i^m} \cdot \delta y_i \text{ der } \delta y_i = y_i^{m+1} - y_i^m
\end{array}
\end{equation*}
$$

<p>
Merk at uttrykket nå er lineært da \( y_i^{m+1} \)  bare inngår i 1. potens.

<p>
Innsatt i \eqref{ex:351} får vi følgende differanseligning:

$$
\begin{equation} \label{ex:352}
y_{i-1}^{m+1} +\left( \frac{3}{2} h^2 \sqrt{y_i^m}-2\right) y_i^{m+1} + y_{i+1}^{m+1} = \frac{h^2}{2}y_i^m\sqrt{y_i^m}
\end{equation}
$$

<h2 id="ex:36">Example:</h2>

<p>
\( y''(x) + \sin\left (y(x)\right) = 0 \) som diskretisert med sentral-differanser blir: 

$$
\begin{equation} \label{ex:361}
y_{i+1}^{m+1} - 2y_i^{m+1} + y_{i-1}^{m+1} + h^2 \sin \left( y_i^{m+1} \right) = 0
\end{equation}
$$

<p>
Det er leddet \( y_i^{m+1} \) som er ikke-lineært og må lineariseres. Vi har bare ett indeks og vi bruker \eqref{eq:34210} med  \( z_i \to y_i \) og \( F(y_i) = \sin (y_i) \):

$$
\begin{equation*}
\begin{array}{c}
F(y_i)_{m+1} \approx F(y_i)_m + \delta y_i \left( \dfrac{\partial F}{\partial y_i}\right)_m = \sin(y_i^m) + \delta y_i \cdot \cos(y_i^m) \text{ eller }\\\\ 
\sin(y_i^{m+1}) \approx \sin(y_i^m) + \cos(y_i^m) \cdot \delta y_i \text{ der } \delta y_i = y_i^{m+1} - y_i^m
\end{array}
\end{equation*}
$$

<p>
Innsatt i \eqref{ex:361} får vi følgende differanseligning:

$$
\begin{equation} \label{ex:362}
y_{i-1}^{m+1} + (h^2 \cos(y_i^m) - 2) y_i^{m+1} + y_{i+1}^{m+1} = h^2(y_i^m \cos(y_i^m) - \sin(y_i^m))
\end{equation}
$$

<h2 id="ex:37">Example:</h2>

<p>
Gitt differensialligningen \( y''(x) + y(x)\sqrt{y'(x)}= 0 \) som diskretisert med sentral-differanser blir:

$$
\begin{equation} \label{ex:371}
y_{i+1}^{m+1} -2y_i^{m+1} + y_{i-1}^{m+1} + \alpha \cdot y_i^{m+1}\sqrt{y_{i+1}^{m+1} - y_{i-1}^{m+1}} = 0 \ ,\text{ der $\alpha = h\sqrt{h/2}$} 
\end{equation}
$$

<p>
Det er leddet \( y_i^{m+1}\sqrt{y_{i+1}^{m+1} - y_{i-1}^{m+1}} \) som er ikke-lineært og må lineariseres. I dette tilfellet har vi tre indekser og vi 
bruker \eqref{eq:34212} med  \( z_{i-1} \to y_{i-1} \ , \ z_i \to y_i \) og \( z_{i+1} \to y_{i+1} \) samt \( F(y_{i-1},y_i,y_{i+1})_m = y_i \sqrt{y_{i+1}-y_{i-1}} \).  
Finner de enkelte leddene i \eqref{eq:34212} :

$$
\begin{equation*}
\begin{array}{l}
F(y_{i-1},y_i,y_{i+1})_m = y_i^m\sqrt{y_{i+1}^m- y_{i-1}^m}\ , \ \left( \frac{\partial F}{\partial y_{i-1}}\right)_m = - \frac{y_i^m}{2\sqrt{y_{i+1}^m - y_{i-1}^m}} \ ,\\\\ 
\left( \frac{\partial F}{\partial y_i}\right)_m = \sqrt{y_{i+1}^m - y_{i-1}^m} \text{ og tilslutt  } \left( \frac{\partial F}{\partial y_{i+1}}\right)_m = \frac{y_i^m}{2\sqrt{y_{i+1}^m - y_{i-1}^m}}
\end{array}
\end{equation*}
$$

<p>
Totalt:

$$
\begin{equation*}
\begin{array}{c}
y_i^{m+1} \sqrt{y_{i+1}^{m+1} - y_{i-1}^{m+1}} \approx y_i^m \sqrt{y_{i+1}^m - y_{i-1}^m} -  \frac{y_i^m}{2 \sqrt{y_{i+1}^m - y_{i-1}^m}} \delta y_{i-1}\\\\ 
+ \sqrt{y_{i+1}^m - y_{i-1}^m} \cdot \delta y_i + \frac{y_i^m}{2 \sqrt{y_{i+1}^m - y_{i-1}^m}} \delta y_{i+1}
\end{array}
\end{equation*}
$$

<p>
Merk at uttrykket nå er lineært da \( y_{i-1}^{m+1},y_i^{m+1} \) og \( y_{i+1}^{m+1} \)  bare inngår i 1. potens. Vi  setter dette inn i  \eqref{ex:371} som nå 
blir lineær:

$$
\begin{equation} \label{ex:372}
\begin{array}{c}
\left( 1 - \alpha\frac{y_i^m}{2g^m}\right) \cdot y_{i-1}^{m+1} - (2 - \alpha g^m)\cdot y_i^{m+1} + \left( 1 + \alpha\frac{y_i^m}{2g^m}\right) \cdot y_{i+1}^{m+1}\\\\ 
= \alpha\frac{y_i^m}{2g^m}(y_{i+1}^m-y_{i-1}^m)\\\\ 
\text{der } g^m = \sqrt{y_{i+1}^m-y_{i-1}^m}
\end{array}
\end{equation}
$$

<p>
I neste avsnitt  viser vi hvordan vi  kan operere direkte med delta-størrelsene \( \delta y_{i-1}^{m+1},\delta y_{i}^{m+1} \) og \( \delta y_{i+1}^{m+1} \)

<p>
Hvordan vil disse eksemplene bli dersom vi bruker metoden med etterslep? Lign. \eqref{ex:351}) i eksempel (<a href="#ex:35">Example:</a>) skrives: 
\( y_{i-1}^{m+1}+(h^2\sqrt{y_i^{m+1}}-2)\cdot y_i^{m+1}+y_{i-1}^{m+1} = 0 \)

<p>
Koeffisienten foran \( y_i^{m+1} \) -leddet inneholder \( \sqrt{y_i^{m+1}} \)  som blir erstattet med \( \sqrt{y_i^m} \) slik at ligningen blir: 
\( y_{i-1}^{m+1}+(h^2\sqrt{y_i^m}-2)\cdot y_i^{m+1}+y_{i-1}^{m+1} = 0 \)

<p>
I lign. ligning \eqref{ex:361}) i eksempel (<a href="#ex:36">Example:</a>) erstattes  med  slik at ligningen blir:

<p>
\( y_{i-1}^{m+1} - 2y_i^{m+1}+y_{i+1}^{m+1} = -h^2\sin(y_i^m)=0 \)

<p>
Lign. \eqref{ex:371})  i eksempel (<a href="#ex:37">Example:</a>) skrives:

<p>
\( y_{i-1}^{m+1} + (\alpha \cdot \sqrt{y_{i+1}^{m+1}-y_{i-1}^{m+1}} - 2) \cdot y_i^{m+1}+y_{i+1}^{m+1} = 0 \)

<p>
Koeffisienten foran \( y_i^{m+1} \) -leddet  inneholder \( \sqrt{y_{i+1}^{m+1}-y_{i-1}^{m+1}} \) som erstattes med \( \sqrt{y_{i+1}^m-y_{i-1}^m} \)  slik at 
ligningen blir:

$$
\begin{equation*}
y_{i-1}^{m+1} + (\alpha\cdot\sqrt{y_{i+1}^{m} - y_{i-1}^{m}}-2)\cdot y_i^{m+1} + y_{i+1}^{m+1} = 0
\end{equation*}
$$

<p>
Når vi bruker denne metoden, må vi først skrive systemet på en form som viser koeffisientene i ligning-systemet. Dersom koeffisientene inneholder 
avhengige variable ved iterasjon \( m +1 \), må disse erstattes med verdier fra iterasjon \( m \). Men dette er ofte det samme som å Taylor-utvikle 
koeffisientene rundt iterasjon \( m \) og bruke bare 1. ledd i utviklingen.

<p>
Vi kan derfor vente at metoden med etterslep generelt konvergerer langsommere enn når vi bruker to ledd av Taylor-utviklingen.  Metoden med etterslep 
brukes helst for partielle differanseligninger der f. eks. materialparametrene er funksjon av de avhengige variable, f.eks.  temperaturavhengige 
varmeledningstall.

<p>
<!-- !split  -->

<h2 id="ch3:sec43">Eksempler på stoppkriterier</h2>

<p>
Vi setter:

$$
\begin{equation} \label{eq:34313}
\begin{array}{c}
\delta y_i = y_i^{m+1} - y_i^m \ , \ i = 1,2,...,N \ , \ m = 0,1,...\\ 
\text{der N er antall beregningspunkt}
\end{array}
\end{equation}
$$

<p>
<b>1</b>. <b>Test for absolutte størrelser</b>. 

$$
\begin{equation} \label{eq:34314a} 
t_{a1} = \max(|\delta y_i|) < tol_a
\end{equation}
$$


$$
\begin{equation} \label{eq:34314b}
t_{a2} = \frac{1}{n}\sum_{i=1}^N |\delta y_i| < tol_a
\end{equation}
$$


$$
\begin{equation} \label{eq:34314c}
t_{a3} = \frac{1}{n}\sqrt{\sum_{i=1}^N(\delta y_i)^2} < tol_a
\end{equation}
$$

<p>
<b>2</b>. <b>Test for relative størrelser</b>.

$$
\begin{equation} \label{eq:34315a} 
t_{r1} = \max \left(\left| \frac{\delta y_i}{y_i^{m+1}}\right| \right) < tol_r \ , \ y_i^{m+1} \not= 0
\end{equation}
$$


$$
\begin{equation} \label{eq:34315b}
t_{r2}=\frac{\sum_{i=1}^N|\delta y_i|}{\sum_{i=1}^N\left|y_i^{m+1}\right|} < tol_r
\end{equation}
$$


$$
\begin{equation} \label{eq:34315c}
t_{r3} = \frac{\max(|\delta y_i|)}{\max(|y_i^{m+1}|)} < tol_r
\end{equation}
$$

<p>
Dersom de størrelsene vi beregner er av størrelsesorden 1, er det likegyldig om vi bruker en absolutt eller en relativ test. Vanligvis bruker vi en 
relativ test da denne samsvarer med uttrykket  "antall korrekte siffer". Dersom den størrelsen vi beregner er liten i hele sitt beregningsområde, bruker 
vi vanligvis en absolutt test.

<p>
La oss bruke testene ovenfor på problemet i avsnitt (<a href="#ch2:sec2">Ikke-lineære ligninger</a>) der vi skal beregne løsningen \( y_{II}) \) gitt på fig (<a href="#fig:28">20</a>)

<p>
Vi gjentar ligningen fra \eqref{eq:3401} :

$$
\begin{equation} \label{eq:34316a}
y''(x) = \frac{3}{2}y^2
\end{equation}
$$


$$
\begin{equation} \label{eq:34316b}
y(0) = 4 \ , \ y(1) = 1
\end{equation}
$$

<p>
Vi tipper et startprofil gitt ved parabelen \( y_s = 20(x-x^2) \) , \( 0 < x < 1 \) . Denne parabelen, samt løsningen \( y_{II} \) , er plottet i figuren nedenfor.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 55:  <div id="fig:317"></div> </p></center>
<p><img src="fig-ch3/fig17.png" align="bottom" width=500></p>
</center>

<p>
I dette tilfellet er det naturlig å bruke et relativt stoppkriterium da \( y_{II} \) ligger i intervallet \( [4, -10.68] \). Med ni iterasjoner får vi følgende 
tabell:

<p>

<div class="row">
  <div class="col-xs-6">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>Iter.nr.</b></td> <td align="center">      \( t_{r2} \)      </td> <td align="center">      \( t_{r3} \)      </td> </tr>
</thead>
<tbody>
<tr><td align="center">   1           </td> <td align="center">   \( 7.25\cdot 10^{-1} \)     </td> <td align="center">   \( 7.55\cdot 10^{-1} \)     </td> </tr>
<tr><td align="center">   2           </td> <td align="center">   \( 8.70\cdot 10^{-1} \)     </td> <td align="center">   \( 8.20\cdot 10^{-1} \)     </td> </tr>
<tr><td align="center">   3           </td> <td align="center">   \( 8.49\cdot 10^{-1} \)     </td> <td align="center">   \( 6.65\cdot 10^{-1} \)     </td> </tr>
<tr><td align="center">   4           </td> <td align="center">   \( 4.96\cdot 10^{-1} \)     </td> <td align="center">   \( 5.85\cdot 10^{-1} \)     </td> </tr>
<tr><td align="center">   5           </td> <td align="center">   \( 2.10\cdot 10^{-1} \)     </td> <td align="center">   \( 2.80\cdot 10^{-1} \)     </td> </tr>
<tr><td align="center">   6           </td> <td align="center">   \( 4.62\cdot 10^{-2} \)     </td> <td align="center">   \( 6.07\cdot 10^{-2} \)     </td> </tr>
<tr><td align="center">   7           </td> <td align="center">   \( 2.24\cdot 10^{-3} \)     </td> <td align="center">   \( 2.70\cdot 10^{-3} \)     </td> </tr>
<tr><td align="center">   8           </td> <td align="center">   \( 4.68\cdot 10^{-6} \)     </td> <td align="center">   \( 5.79\cdot 10^{-6} \)     </td> </tr>
<tr><td align="center">   9           </td> <td align="center">   \( 2.26\cdot 10^{-11} \)    </td> <td align="center">   \( 2.55\cdot 10^{-11} \)    </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-6 -->
<p>
Iterasjonsforløpet er typisk for Newton-iterasjon da startverdiene våre ligger et godt stykke fra de korrekte verdiene. For de seks første iterasjonene 
minker feilen langsomt, mens vi har rask konvergens for de siste tre iterasjonene. Vi ser også at det er liten forskjell mellom de to kriteriene i dette 
tilfellet.

<p>
Nedenfor vises listing av programmet <b>avvikr</b>.

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">clear
h = 0.025; % skrittlengde
ni = 1/h; % Antall intervall
#  h maa velges slik at ni er et heltall
n = ni-1; % Antall ligninger
fac = 3.0*h*h;
a = ones(n,1) ; % underdiagonal
c = a; % overdiagonal 
#  a og c blir ikke ødelagt under eliminasjons-prosessen og 
#  kan derfor legges utenfor iterasjonsløkka.
x = (h:h:1.0-h)&#39;;
ym = -20*x.*(1 - x); % Startverdier
b = zeros(n,1); d = b; dy = b; % allokering
fprintf(&#39;        Itr.       \n&#39;);
for it = 1:9 
   b = -(2.0 + fac*ym); % hoveddiagonal
   d = -(fac*0.5)*ym.^2 ; % høyre side 
   d(n) = d(n)- 1.0;
   d(1) = d(1) - 4.0;
   ym1 = tdma(a,b,c,d); % Løser ligningsystemet
   dy = abs(ym1 - ym);
   tr3 = max(dy)/max(abs(ym1));
   tr2 = sum(dy)/sum(abs(ym1));
   ym = ym1; % Oppdatering av y-verdier
   fprintf(&#39; %10d   %9.2e   %9.2e  \n&#39;,it,tr2, tr3);
end
</pre></div>
<p>
Programmet <b>avvika</b> som beregner de absolutte kriteriene, er temmelig identisk med <b>avvikr</b> bortsett av vi erstatter beregningen av \( t_{r2} \) og \( t_{r3} \) 
med

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">   ta1 = max(dy);
   ta2 = sum(dy)/n;
   ta3 = sqrt(dot(dy,dy))/n;
</pre></div>
<p>
<!-- !split -->

<h2 id="ch3:sec44">Ligninger på delta-form</h2>

<p>
Fra lign. \eqref{eq:3428}

$$
\begin{equation*}
\begin{array}{c}
(y_i^{m+1})^2 = (y_i^m + \delta y_i)^2 = (y_i^m)^2 + 2y_i^m \cdot \delta y_i + (\delta y_i)^2\\ 
\approx (y_i^m)^2 + 2y_i^m \cdot \delta y_i = y_i^m(2y_i^{m+1} - y_i^m)
\end{array}
\end{equation*}
$$

<p>
Vi har her innført \( \delta y_i = y_i^{m+1} - y_i^m \)  slik at ligningsystemet løses m.h.p  \( y_i^{m+1} \). Dette er ikke nødvendig. Vi kan beholde  
\( \delta y_i \) som ukjent og løse systemet m.h.p. delta-størrelsene. Ved å innføre \( y_k^{m+1} = y_k^m + \delta y_k \), \( k = i-1 \ , \ i \ , \ i+1 \) samt 
\( (y_i^{m+1})^2 \approx (y_i^m)^2 + 2y_i^m \cdot \delta y_i \) i \eqref{eq:3415} eventuelt  \eqref{eq:3429}, får vi følgende ligningsystem 

$$
\begin{equation} \label{eq:34417a}
\begin{array}{rcl}
-(2+3y_1^mh^2)\delta y_1 + \delta y_2 &= -(y_2^m - 2y_1^m + 4) + \frac{3}{2}(y_1^mh)^2\\\\ 
\delta y_{i-1} - (2+3y_i^mh^2)\delta y_i + \delta y_{i+1} &= -(y_{i+1}^m - 2y_i^m + y_{i-1}^m) + \frac{3}{2}(y_i^mh)^2\\\\ 
\delta y_{N-1} - (2+3y_N^mh^2)\delta y_N &= -(1-2y_N^m + y_{N-1}^m)+\frac{3}{2}(y_N^mh)^2\\ 
\end{array}
\end{equation}
$$

<p>
der \( i=2,3,...,N-1 \) , \( m=0,1,2,...   \)

<p>
Vi har benyttet at  \( y_0 = 4 \), \( \delta y_0 = 0 \), \( y_{N+1} = 1 \), \( \delta y_{N+1}=0 \) fra randbetingelsene. For hver iterasjon oppdateres  y-verdiene ved:

$$
\begin{equation}
y_i^{m+1} = y_i^m + \delta y_i \ , \ i=1,2,...,N
\label{_auto40}
\end{equation}
$$

<p>
Når vi har funnet ut hvordan iterasjonen forløper, kan vi f. eks. legge inn stopp-kriterier som \( \max|\delta y_i| < \varepsilon_1 \) eller 
\( \max|\delta y_i / y_i^{m+1}| < \varepsilon_2 \), \( i=1,2,...,N \) Iterasjonsløkka i programmet <b>delta34</b>  ser slik ut  med bruk av \eqref{eq:34315c}:

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">it = 0; itmax = 10; dymax = 1.0; RelTol = 1.0e-5;
while (dymax &gt; RelTol) &amp; (it &lt; itmax)
    it = it + 1;    b = -(2.0 + fac*y); % hoveddiagonal
    d = (fac*0.5)*y.^2 ; % høyre side 
   for j = 2:n-1
      d(j) = d(j) -(y(j+1)-2*y(j) + y(j-1));
   end
    d(n) = d(n)- (1.0- 2*y(n) + y(n-1));
    d(1) = d(1) - (y(2)-2*y(1) + 4.0);
    dy = tdma(a,b,c,d); % Løser ligningsystemet
    y = y + dy; % Oppdatering av y-verdier
    dymax = max(abs((dy)./y));% Beregner relativ avvik     
    fprintf(&#39; %10d     %12.3e \n&#39;,it,dymax); 
end
</pre></div>
<p>
<!-- !split -->

<h2 id="ch3:sec45">Kvasilinearisering</h2>

<p>
I det foregående har vi først diskretisert ligningen og deretter linearisert den. Det er fullt mulig å linearisere ligningen først. Dette blir gjerne 
kalt kvasi-linearisering. La oss se på en generell, ikke-lineær 2. ordens ligning:

$$
\begin{equation} \label{eq:34518}
y''(x) = f(x,y,y')
\end{equation}
$$

<p>
Skriver \eqref{eq:34518} på formen:

$$
\begin{equation} \label{eq:34519}
g(x,y,y',y'') \equiv y''(x) - f(x,y,y') = 0
\end{equation}
$$

<p>
Setter

$$
\begin{equation} \label{eq:34520}
\delta y = y_{m+1} - y_m \ , \ \delta  y' = y'_{m+1} -y'_m\ , \ \delta y'' = y''_{m+1} - y''_m
\end{equation}
$$

<p>
der \( m \) og \( m+1 \) som vanlig betyr iterasjonsnummer. (I storparten av dette avsnittet skriver vi iterasjonsnumrene som subindekser)

<p>
Ved rekkeutvikling av \eqref{eq:34519} rundt iterasjon \( m \) :

$$
\begin{equation} \label{eq:34521}
\begin{array}{lcl}
g(x,y_{m+1},y'_{m+1},y''_{m+1}) &\approx g(x,y_m,y'_m,y''_m)\\\\ 
&+&\left( \dfrac{\partial g}{\partial y}\right)_m \delta y + \left( \dfrac{\partial g}{\partial y'}\right)_m \delta y' + \left( \dfrac{\partial g}{\partial y''}\right)_m \delta y''\\ 
\end{array}
\end{equation}
$$

<p>
Anta at vi har iterert så mange ganger at

$$
\begin{equation*}
g(x,y_{m+1},y'_{m+1},y''_{m+1}) \approx g(x,y_m,y'_m,y''_m)\approx 0 
\end{equation*}
$$

<p>
som innsatt i \eqref{eq:34521} gir:

$$
\begin{equation} \label{eq:34522}
\left( \frac{\partial g}{\partial y}\right)_m \delta y + \left( \frac{\partial g}{\partial y'}\right)_m \delta y' + \left( \frac{\partial g}{\partial y''}\right)_m \delta y'' = 0
\end{equation}
$$

<p>
Ved derivasjon av \eqref{eq:34519}:

$$
\begin{equation} \label{eq:34523}
\frac{\partial g}{\partial y} = -\frac{\partial f}{\partial y} \ , \ \frac{\partial g}{\partial y'} = -\frac{\partial f}{\partial y'} \ , \ \frac{\partial g}{\partial y''} = 1
\end{equation}
$$

<p>
som innsatt i \eqref{eq:34522} gir:

$$
\begin{equation} \label{eq:34524}
\delta y'' = \left(\frac{\partial f}{\partial y}\right)_m\delta y + \left(\frac{\partial f}{\partial y'}\right)_m\delta y'
\end{equation}
$$

<p>
Ved å sette inn fra \eqref{eq:34520} i \eqref{eq:34524} samt bruk av \eqref{eq:34518}, får vi:

$$
\begin{equation} \label{eq:34525}
\begin{array}{c}
y''_{m+1}- \left(\dfrac{\partial f}{\partial y'}\right)_m \cdot y'_{m+1} - \left(\dfrac{\partial f}{\partial y}\right)_m \cdot y_{m+1}\\\\ 
= f(x,y_m,y'_m)-\left(\dfrac{\partial f}{\partial y}\right)_m \cdot y_m - \left(\dfrac{\partial f}{\partial y'}\right)_m \cdot y'_m
\end{array}
\end{equation}
$$

<p>
Skriver tilslutt \eqref{eq:34525} med vår vanlige notasjon med iterasjonsnummer oppe:

$$
\begin{equation} \label{eq:34526}
\begin{array}{c}
(y'')^{m+1}- \left(\dfrac{\partial f}{\partial y'}\right)_m \cdot (y')^{m+1} - \left(\dfrac{\partial f}{\partial y}\right)_m \cdot y^{m+1}\\\\ 
= f(x,y^m,(y')^m)-\left(\dfrac{\partial f}{\partial y'}\right)_m \cdot (y')^m - \left(\dfrac{\partial f}{\partial y}\right)_m \cdot y^m
\end{array}
\end{equation}
$$

<p>
Vi har brukt en 2. ordens ligning som eksempel, men \eqref{eq:34524} – \eqref{eq:34526} lar seg umiddelbart generalisere til en n'te ordens ligning, 
f.eks. en 3. ordens:

$$
\begin{equation} \label{eq:34527}
\begin{array}{c}
(y''')^{m+1} - \left(\dfrac{\partial f}{\partial y''}\right) \cdot (y'')^{m+1} - \left(\dfrac{\partial f}{\partial y'}\right)_m \cdot (y')^{m+1} - \left(\dfrac{\partial f}{\partial y}\right)_m \cdot y^{m+1} \\\\ 
= f(x,y^m,(y')^m,(y'')^m)-\left(\dfrac{\partial f}{\partial y''}\right)_m \cdot (y'')^{m}\\\\ 
 - \left(\dfrac{\partial f}{\partial y'}\right)_m \cdot (y')^{m}-\left(\dfrac{\partial f}{\partial y}\right)_m \cdot (y)^{m}
\end{array}
\end{equation}
$$

<h2 id="___sec59">Example: </h2>

<p>
<b>1)</b>

$$
\begin{equation*}
\text{Ligningen } y''(x) = \frac{3}{2}y^2
\end{equation*}
$$

<p>
Her blir \( \frac{\partial f}{\partial y'} = 0 \) , \( \frac{\partial f}{\partial y} = 3y \)  som innsatt i \eqref{eq:34526} gir:

$$
\begin{equation*}
(y'')^{m+1} - 3y^m \cdot y^{m+1} = -\frac{3}{2}(y^m)^2
\end{equation*}
$$

<p>
Ved å diskretisere med sentraldifferanser \( y_i'' \approx \frac{y_{i+1} - 2y_i + y_{i-1}}{h^2} \) : får vi følgende differanseligning:

$$
\begin{equation*}
y_{i-1}^{m+1} - (2+3h^2y_i^m)y_i^{m+1} + y_{i+1}^{m+1} = -\frac{3}{2}(hy_i^m)^2
\end{equation*}
$$

<p>
som er i overenstemmelse med \eqref{eq:3429}.

<p>
<b>2)</b>

$$
\begin{equation*}
\text{Falkner-Skan-ligningen } y'' + y \cdot y'' + \beta \cdot [1-(y')^2] = 0
\end{equation*}
$$

<p>
Vi skriver ligningen på formen:

$$
\begin{equation*}
y'' = -\left(y\cdot y'' + \beta \cdot [1 - (y')^2]\right) = f(x,y,y',y'')
\end{equation*}
$$

<p>
Lign. \eqref{eq:34527} gir med \( \frac{\partial f}{\partial y''} = -y \) , \( \frac{\partial f}{\partial y'}=2\beta y' \) og \( \frac{\partial f}{\partial y} = -y'' \) :

$$
\begin{equation*}
\begin{array}{c}
(y''')^{m+1} + y^m \cdot (y'')^{m+1} -2\beta(y')^m \cdot (y')^{m+1} + (y'')^m \cdot y^{m+1}\\ 
= -\beta \left( 1 + \left[(y')^m\right]^2\right) + y^m \cdot (y'')^m
\end{array}
\end{equation*}
$$

<p>
Bruk sentraldifferanser og verifiser lign.(F.O.16) i appendiks F i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>

<p>
!split

<h1 id="ch3:sec5">Løsning av Blasius ligning ved bruk av differansemetode</h1>

<p>
Test av kapittel 3 avsnitt 5
<!-- !split -->

<h1 id="ch3:sec6">Deriverte randbetingelser</h1>

<p>
Test av kapittel 3 ansnitt 6
<!-- !split -->

<h1 id="ch3:sec7">Iterasjonsmetoder ved løsning av ODL</h1>

<p>
Test av kapittel 3 seksjon7
<!-- !split -->
<!-- Externaldocuments: ../chapter3.do.txt -->

<center><h1 id="ch:7">Elliptic partial differential equations</h1></center> <!-- chapter heading -->

<h1 id="kap:71">Introduction</h1>

<p>
Important and frequently occuring practical problems are governed by elliptic PDEs, including steady-state temperature distribution in solids.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Famous elliptic PDEs.</b>
Some famous elliptic PDEs are better know by their given names: 

<ul>
  <li> Laplace:</li>
</ul>

$$
\begin{equation}
  \nabla^2u=0
\label{eq:7104}
\end{equation}
$$


<ul>
  <li> Poisson:</li>
</ul>

$$
\begin{equation} \label{eq:7103}
  \nabla^2u=q
\end{equation}
$$


<ul>
  <li> Helmholtz:</li>
</ul>

$$
  \begin{equation}
  \nabla^2u+c\cdot u = q
\label{eq:7102}
  \end{equation}
$$
</div>


$$
\begin{equation*}
  \text{where } \nabla^2=\frac{\partial^2}{\partial x^2}+\frac{\partial^2}{\partial y^2}+\frac{\partial^2}{\partial z^2} \text{ in 3D}
\end{equation*}
$$

and 
$$
\begin{equation*}
  \text{where } \nabla^2=\frac{\partial^2}{\partial x^2}+\frac{\partial^2}{\partial y^2} \text{ in 2D}
\end{equation*}
$$

<p>
The 2D versions of the famous equations above are special cases of the a generic elliptic PDE may be represented by:

$$
\begin{equation}
  \frac{\partial}{\partial x}\left(a\frac{\partial u}{\partial
      x}\right)+\frac{\partial}{\partial y}\left(b\frac{\partial
      u}{\partial y}\right) +c\cdot u = q
\label{eq:7101}
\end{equation}
$$

where \( a \), \( b \), \( c \) og \( q \) may be functions of \( x \) and \( y \) and  \( a \) and \( b \) have the same sign. 

<ul>
  <li> Transient heat conduction is governed by:</li>
</ul>

$$
\begin{align}
  \dfrac{\partial T}{\partial t}=\alpha\left(\dfrac{\partial^2T}{\partial x^2}+\dfrac{\partial^2T}{\partial y^2}+\dfrac{\partial^2T}{\partial z^2}\right)
\label{eq:parabolic}
\end{align}
$$

which is a parabolic PDE, but at steady state when  \( \left( \dfrac{\partial T}{\partial t}=0\right) \), we get:
$$
\begin{align}
\left(\dfrac{\partial^2T}{\partial
      x^2}+\dfrac{\partial^2T}{\partial
      y^2}+\dfrac{\partial^2T}{\partial z^2}\right)=0
\label{_auto41}
\end{align}
$$

which is an elliptic PDE.

<p>
From the classification approach in the chapter ref{kap:43}  (see also <a href="http://www.ucl.ac.uk/~ucahhwi/LTCC/sectionD-classification.pdf" target="_self">Classification of linear 2nd order PDEs</a>) we  see that \eqref{eq:7104} to \eqref{eq:7102} are elliptic, meaning no real characteristics.
Therefore, elliptic PDEs must be treated as boundary value problems (see ref{kap:44} and  ref{kap:45}) for a discussion about the conditions for a well posed problem).

<p>
For the solution of a generic elliptic PDE like \eqref{eq:7101}, in a
domain in two-dimensions bounded by the boundary curve C (<a href="#fig:71">56</a>), we reiterate
the most common boundary value conditions from ref{kap:44}:

<ul>
  <li> Dirichlet-condition:  \( u(x,y)=G_1(x,y) \) on the boundary cure C</li>
  <li> Neumann-condition:     \( \dfrac{\partial u}{\partial n}=G_2(x,y) \) on C</li>
  <li> Robin-condition:    \( a\cdot u(x,y)+b\cdot \dfrac{\partial u(x,y)}{\partial n}= G_3(x,y) \) on C</li>
</ul>

<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 56:  A solution domain in two-dimensions bounded by a boundary curve C.  <div id="fig:71"></div> </p></center>
<p><img src="fig-ch7/1.png" align="bottom" width=400></p>
</center>

<p>
For the Neuman-problem, at least one value of \( u(x,y) \) must be specified on \( C \) for the solution to be unique.
Additionally, the contour integral of \( G_2(x,y) \) on \( C \) must vanish.

<p>
Several physical problems may be modeled by the Poisson equation \eqref{eq:7103}

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Possion problems.</b>

<ul>
  <li> The stress equation for torsion of an elastic rod</li> 
  <li> The displacement of an membrane under constant pressure.</li>
  <li> Stokes flow (low Reynolds number flow)</li>
  <li> Numerous analytical solutions (also in polar coordinantes) may be found in <a href="#white91viscous">[9]</a> section 3-3.</li>
</ul>
</div>


<p>
<!-- !split -->

<h1 id="kap:72">Direct numerical solution</h1>

<p>
In situations where the elliptic PDE correspons to the stationary
solution of a parabolic problem \eqref{eq:parabolic}, one may naturally
solve the parabolic equation until stationary conditions
occurs. Normally, this will be time consuming task and one may
encounter limitations to ensure a stable solution. By disregarding
such a timestepping approach one does not have to worry about
stability. Apart from seeking a fast solution, we are also looking for
schemes with efficient storage management a reasonable programming
effort.

<p>
Let us start by discretizing the stationary heat equation in a rectangular plated with dimension as given in Figure <a href="#fig:73">57</a>:

$$
\begin{equation}
  \frac{\partial^2 T}{\partial x^2} + \frac{\partial^2 T}{\partial
    y^2}=0
\label{eq:7201}
\end{equation}
$$

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 57:  Rectangular domain with prescribed values at the boundaries (Dirichlet). <div id="fig:73"></div> </p></center>
<p><img src="fig-ch7/4.png" align="bottom" width=400></p>
</center>

<p>
We adopt the following notation:
$$
\begin{align*}
x_i&=x_0+i\cdot h,\ i=0,1,2,\dots\\ 
y_j&=y_0+j\cdot h,\ j=0,1,2,\dots
\end{align*}
$$

For convenience we assume \( \Delta x = \Delta y = h \). The ordering of
the unkown temperatures is illsustrated in (<a href="#fig:ch7-3">58</a>).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 58:  Illustration of the numerical stencil. <div id="fig:ch7-3"></div> </p></center>
<p><img src="fig-ch7/3_new_transparent.png" align="bottom" width=400></p>
</center>

<p>
By approximation the second order differentials in \eqref{eq:7201} by central differences we get the following numerical stencil:
$$
\begin{equation}
  T_{i+1,j}+T_{i-1,j}+T_{i,j+1}+T_{i,j-1}-4 T_{i,j}=0
\label{eq:7202}
\end{equation}
$$

<p>
which states that the temperature \( T_{i,j} \) in at the location \( (i,j) \) depends on the values of its neighbors to the left, right, up and down. Frequently, the neighbors are denoted in compass notation, i.e. \( \text{west}=i-1 \), \( \text{east}=i+1 \), \( \text{south}=j-1 \), and \( \text{north}=j+1 \). By referring to the compass directions with their first letters, and equivalent representation of the stencil in \eqref{eq:7202} reads:

$$
\begin{equation}
  T_{e}+T_{w}+T_{n}+T_{s}-4 T_{m}=0
\label{eq:compass}
\end{equation}
$$

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 59:  Illustration of the numerical stencil with compass notation. <div id="fig:ch7-3_compass"></div> </p></center>
<p><img src="fig-ch7/3_compass_sanseriff.png" align="bottom" width=400></p>
</center>

<p>
The smoothing nature of elliptic problems may be seen even more clearly by isolating the \( T_{i,j} \) in \eqref{eq:compass} on the left hand side:
$$
\begin{equation}
T_{m}= \frac{T_{e}+T_{w}+T_{n}+T_{s}}{4}
\label{eq:avearge}
\end{equation}
$$

showing that the temperature \( T_{m} \) in each point is the average temperature
of the neighbors (to the east, west, north, and south).

<p>
The temperature is prescribed at the bondaries (i.e. Dirichlet
boundary conditions) and are given by:

$$
\begin{align}
  T&=0.0 \quad \textrm{at} \quad  y=0 \nonumber \\ 
  T&=0.0 \quad \textrm{at} \quad  x=0  \quad \textrm{ and }\quad  x=1 \quad  \textrm{ for } \quad 0 \leq y < 1.5 \label{eq:BCs}\\ 
  T&=100.0 \quad \textrm{at} \quad y=1.5 \nonumber
\end{align}
$$

<p>
Our mission is now to find the temperature distribution over the plate
by using \eqref{eq:7202} and \eqref{eq:BCs} with \( \Delta x = \Delta y =
0.25 \). In each discretized point in (<a href="#fig:ch7-3">58</a>) the temperatures
need to satisfy \eqref{eq:7202}, meaning that we have to satisfy as
many equations as we have unknown temperatures. As the temperatures in
each point depends on their neighbors, we end up with a system of
algebraic equations. To set up the system of equations we traverse our
our unknows one by one in a systematic manner and make use of use of
\eqref{eq:7202} and \eqref{eq:BCs} in each.  All unknown temperatures
close to any of the boundaries (left, right, top, bottom) in Figure
<a href="#fig:73">57</a> will be influenced by the prescribed and known
temperatures the wall via the 5-point stencil
\eqref{eq:7202}. Prescribed values do not have to be calculated an can
therefore be moved to the right hand side of the equation, and by
doing so we modify the numerical stencil in that specific discretized
point. In fact, inspection of Figure <a href="#fig:73">57</a>, reveals that only
three unknown temperatures are not explicitly influenced by the
presences of the wall (\( T_{2,2} \), \( T_{2,3} \), and \( T_{2,3} \)). The four
temperatures in the corners (\( T_{1,1} \),$T_{1,5}$, \( T_{3,1} \), and
\( T_{3,5} \)) have two precribed values to be accounted for on the right
hand side of their specific version of the generic numerical stencil
\eqref{eq:7202}.  All other unknown temperatures close to the wall have
only one prescribed value to be accounted for in their specific
numerical stenscil.

<p>
By starting at the lower left corner and traversing in the y-direction
first, and subsequently in the x-direction we get the following system
of equations:

$$
\begin{align}
  -4\cdot T_{11}+T_{12}+T_{21}&=0 \nonumber\\ 
  T_{11}-4\cdot T_{12}+T_{13}+T_{22} &=0 \nonumber\\ 
  T_{12}-4\cdot T_{13}+T_{14}+T_{23}&=0 \nonumber\\ 
 T_{13}-4\cdot T_{14}+T_{15}+T_{24} &=0 \nonumber\\ 
  T_{14}-4\cdot T_{15}+T_{25}&=-100 \nonumber\\ 
T_{11}-4\cdot T_{21}+T_{22}+T_{31}&=0 \nonumber\\ 
    T_{12}+T_{21}-4\cdot T_{22}+T_{23}+T_{32}&=0 \nonumber \\ 
    T_{13}+T_{22}-4\cdot T_{23}+T_{24}+T_{33}&=0 \label{eq:7203} \\ 
    T_{14}+T_{23}-4\cdot T_{24}+T_{25}+T_{34}&=0 \nonumber \\ 
    T_{15}+T_{24}-4\cdot T_{25}+T_{35}&=100 \nonumber \\ 
  T_{21}-4\cdot T_{31}+T_{32}&=0,\nonumber \\ 
  T_{22}+T_{31}-4\cdot T_{32}+T_{33}&=0 \nonumber \\ 
  T_{23}+T_{32}-4\cdot T_{33}+T_{34}&=0 \nonumber \\ 
  T_{24}+T_{33}-4\cdot T_{34}+T_{35}&=0 \nonumber \\ 
  T_{25}+T_{34}-4\cdot T_{35}&=-100 \nonumber 
\end{align}
$$

<p>
The equations in \eqref{eq:7203} represent a linear, algebraic system
of equations with \( 5\times3=15 \) unknowns, which has the more convenient and
condensed symbolic representation:
$$
\begin{equation}
  \mathbf{A\cdot T=b}
\label{eq:7204}
\end{equation}
$$

<p>
where \( \mathbf{A} \) denotes the coefficient matrix, \( \mathbf{T} \) holds
the unknown tempeartures, and \( \mathbf{b} \) the prescribed boundary
temperatures. Notice that the structure of the coefficient matrix
\( \mathbf{A} \) is completely dictated by the way the unknown
temperatures are ordered. The non-zero elements in the coefficient
matrix are markers for which unknow temperatures are coupled with each
other. 
Below we will show an example where we order the temperatures
in y-direction first and then x-direction. In this case, the
components of the coefficient matrix \( \mathbf{A} \) and the temperature
vector \( \mathbf{T} \) are given by:

$$
\begin{equation}
    \left(\begin{array}{ccccccccccccccc}
      -4& 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &0 \\ 
      1& -4 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &0 \\ 
      0& 1 & -4 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 &0 \\ 
      0& 0 & 1 & -4 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 &0 \\ 
      0& 0 & 0 & 1 & -4 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 &0 \\ 
      1& 0 & 0 & 0 & 0 & -4 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 &0 \\ 
      0& 1 & 0 & 0 & 0 & 1 & -4 & 1 & 0 & 0 & 0 & 1 & 0 & 0 &0 \\ 
      0& 0 & 1 & 0 & 0 & 0 & 1 & -4 & 1 & 0 & 0 & 0 & 1 & 0 &0 \\ 
      0& 0 & 0 & 1 & 0 & 0 & 0 & 1 & -4 & 1 & 0 & 0 & 0 & 1 &0 \\ 
      0& 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & -4 & 0 & 0 & 0 & 0 &1 \\ 
      0& 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & -4 & 1 & 0 & 0 &0 \\ 
      0& 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & -4 & 1 & 0 &0 \\ 
      0& 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & -4 & 1 &0 \\ 
      0& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & -4 &1 \\ 
      0& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 &-4
    \end{array}\right)
    \cdot
    \left(\begin{array}{c}
      T_{11}\\ 
      T_{12}\\ 
      T_{13}\\ 
      T_{14}\\ 
      T_{15}\\ 
      T_{21}\\ 
      T_{22}\\ 
      T_{23}\\ 
      T_{24}\\ 
      T_{25}\\ 
      T_{31}\\ 
      T_{32}\\ 
      T_{33}\\ 
      T_{34}\\ 
      T_{35}
    \end{array}\right)
    =
    \left(\begin{array}{c}
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      -100\\ 
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      -100\\ 
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      -100
    \end{array}\right)
\label{eq:7205}
\end{equation}
$$

<p>
The analytical solution of \eqref{eq:7201} and \eqref{eq:BCs} may be found to be:
$$
\begin{align}
    &T(x,y)=100\cdot \sum^\infty_{n=1}A_n\sinh(\lambda_ny)\cdot \sin(\lambda_nx) \label{eq:7206}\\ 
    &\textrm{where } \lambda_n = \pi\cdot n \textrm{ and }
      A_n=\frac{4}{\lambda_n\sinh(\frac{3}{2}\lambda_n)} \nonumber
\end{align}
$$

<p>
The analytical solution of the temperature field \( T(x,y) \) in
\eqref{eq:7206} may be proven to be symmetric around \( x = 0.5 \) (see <a href="#exercise:symmetry">Exercise 1: Symmetric solution</a>).

<p>
<!-- !split -->

<p>
We immediately realize that it may be inefficient to solve
\eqref{eq:7205} as it is, due to the presence of all the
zero-elements. The coefficient matrix \( \mathbf{A} \) has \( 15\times
15=225 \) elementes, out of which on 59 are non-zero. Further, a
symmetric, band structure of \( \mathbf{A} \) is evident from
\eqref{eq:7205}. Clearly, these properties may be exploited to
construct an efficent scheme which does not need to store all non-zero
elements of \( \mathbf{A} \).

<p>
SciPy offers a sparse matrix package <a href="http://docs.scipy.org/doc/scipy/reference/sparse.html" target="_self">scipy.sparse</a>. The <code>spdiags</code>
function may be used to construct a sparse matrix from diagonals. Note
that all the diagonals must have the same length as the dimension of
their sparse matrix - consequently some elements of the diagonals are
not used. The first \( k \) elements are not used of the \( k \)
super-diagonal, whereas the last \( k \) elements are not used of the \( -k \)
sub-diagonal (see <a href="http://hplgit.github.io/bumpy/doc/pub/lectures-basics-TKT4140-bootstrap_bg.html#___sec27" target="_self">SciPy sparse example</a>).

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter7/src-ch7/laplace_Diriclhet1.py</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy</span> 
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.linalg</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse.linalg</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pylab</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sinh

<span style="color: #408080; font-style: italic">#import matplotlib.pyplot as plt</span>
<span style="color: #408080; font-style: italic"># Change some default values to make plots more readable on the screen</span>
LNWDT<span style="color: #666666">=2</span>; FNT<span style="color: #666666">=15</span>
plt<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; plt<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT

<span style="color: #408080; font-style: italic"># Set simulation parameters</span>
n <span style="color: #666666">=</span> <span style="color: #666666">15</span>
d <span style="color: #666666">=</span> np<span style="color: #666666">.</span>ones(n) <span style="color: #408080; font-style: italic"># diagonals</span>
b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(n) <span style="color: #408080; font-style: italic">#RHS</span>
d0 <span style="color: #666666">=</span> d<span style="color: #666666">*-4</span>
d1 <span style="color: #666666">=</span> d[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]
d5 <span style="color: #666666">=</span> d[<span style="color: #666666">0</span>:<span style="color: #666666">10</span>]

A <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>diags([d0, d1, d1, d5, d5], [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">-1</span>, <span style="color: #666666">5</span>, <span style="color: #666666">-5</span>], format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csc&#39;</span>)

<span style="color: #408080; font-style: italic">#alternatively (scalar broadcasting version:)</span>
<span style="color: #408080; font-style: italic">#A = scipy.sparse.diags([1, 1, -4, 1, 1], [-5, -1, 0, 1, 5], shape=(15, 15)).toarray()</span>

<span style="color: #408080; font-style: italic"># update A matrix</span>
A[<span style="color: #666666">4</span>, <span style="color: #666666">5</span>], A[<span style="color: #666666">5</span>, <span style="color: #666666">4</span>], A[<span style="color: #666666">10</span>, <span style="color: #666666">9</span>], A[<span style="color: #666666">9</span>, <span style="color: #666666">10</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">0</span>
<span style="color: #408080; font-style: italic"># update RHS:</span>
b[<span style="color: #666666">4</span>], b[<span style="color: #666666">9</span>], b[<span style="color: #666666">14</span>] <span style="color: #666666">=</span> <span style="color: #666666">-100</span>, <span style="color: #666666">-100</span>, <span style="color: #666666">-100</span>
<span style="color: #408080; font-style: italic">#print A.toarray()</span>


tic<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
theta <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A,b) <span style="color: #408080; font-style: italic">#theta=sc.linalg.solve_triangular(A,d)</span>
toc<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;sparse solver time:&#39;</span>,toc<span style="color: #666666">-</span>tic

 
tic<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
theta2<span style="color: #666666">=</span>scipy<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A<span style="color: #666666">.</span>toarray(),b)
toc<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;linalg solver time:&#39;</span>,toc<span style="color: #666666">-</span>tic

<span style="color: #408080; font-style: italic"># surfaceplot:</span>
x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">5</span>)
y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">1.5</span>, <span style="color: #666666">7</span>)

X, Y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>meshgrid(x, y)

T <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(X)

T[<span style="color: #666666">-1</span>,:] <span style="color: #666666">=</span> <span style="color: #666666">100</span>

<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>,<span style="color: #666666">6</span>):
    T[n,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> theta[n<span style="color: #666666">-1</span>]
    T[n,<span style="color: #666666">2</span>] <span style="color: #666666">=</span> theta[n<span style="color: #666666">+5-1</span>]
    T[n,<span style="color: #666666">3</span>] <span style="color: #666666">=</span> theta[n<span style="color: #666666">+10-1</span>]
    
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mpl_toolkits.mplot3d</span> <span style="color: #008000; font-weight: bold">import</span> Axes3D
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> cm
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.ticker</span> <span style="color: #008000; font-weight: bold">import</span> LinearLocator, FormatStrFormatter
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
ax <span style="color: #666666">=</span> fig<span style="color: #666666">.</span>gca(projection<span style="color: #666666">=</span><span style="color: #BA2121">&#39;3d&#39;</span>)
surf <span style="color: #666666">=</span> ax<span style="color: #666666">.</span>plot_surface(X, Y, T, rstride<span style="color: #666666">=1</span>, cstride<span style="color: #666666">=1</span>, cmap<span style="color: #666666">=</span>cm<span style="color: #666666">.</span>coolwarm,
                       linewidth<span style="color: #666666">=0</span>, antialiased<span style="color: #666666">=</span><span style="color: #008000">False</span>)
ax<span style="color: #666666">.</span>set_zlim(<span style="color: #666666">0</span>, <span style="color: #666666">110</span>)

ax<span style="color: #666666">.</span>zaxis<span style="color: #666666">.</span>set_major_locator(LinearLocator(<span style="color: #666666">10</span>))
ax<span style="color: #666666">.</span>zaxis<span style="color: #666666">.</span>set_major_formatter(FormatStrFormatter(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%.02f</span><span style="color: #BA2121">&#39;</span>))
ax<span style="color: #666666">.</span>set_xlabel(<span style="color: #BA2121">&#39;x&#39;</span>)
ax<span style="color: #666666">.</span>set_ylabel(<span style="color: #BA2121">&#39;y&#39;</span>)
ax<span style="color: #666666">.</span>set_zlabel(<span style="color: #BA2121">&#39;T [$^o$C]&#39;</span>)
ax<span style="color: #666666">.</span>set_xticks(x)
ax<span style="color: #666666">.</span>set_yticks(y)

fig<span style="color: #666666">.</span>colorbar(surf, shrink<span style="color: #666666">=0.5</span>, aspect<span style="color: #666666">=5</span>)
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
<!-- !split -->
A somewhat more complicated solution of \eqref{eq:7201} may be found by specifying the differente temperatures on all four boundaries. However, the code structure follows the same way of reasoning as for the previous example:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># chapter7/src-ch7/laplace_Diriclhet2.py</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy</span> 
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.linalg</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse.linalg</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pylab</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sinh

<span style="color: #408080; font-style: italic">#import matplotlib.pyplot as plt</span>

<span style="color: #408080; font-style: italic"># Change some default values to make plots more readable on the screen</span>
LNWDT<span style="color: #666666">=2</span>; FNT<span style="color: #666666">=15</span>
plt<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; plt<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT

<span style="color: #408080; font-style: italic"># Set temperature at the top</span>
Ttop<span style="color: #666666">=30</span>
Tbottom<span style="color: #666666">=0.0</span>
Tleft<span style="color: #666666">=10.0</span>
Tright<span style="color: #666666">=10.0</span>

xmax<span style="color: #666666">=1.0</span>
ymax<span style="color: #666666">=1.5</span>
 
<span style="color: #408080; font-style: italic"># Set simulation parameters</span>
<span style="color: #408080; font-style: italic">#need hx=(1/nx)=hy=(1.5/ny)</span>
Nx <span style="color: #666666">=</span> <span style="color: #666666">20</span>
h<span style="color: #666666">=</span>xmax<span style="color: #666666">/</span>Nx
Ny <span style="color: #666666">=</span> <span style="color: #008000">int</span>(ymax<span style="color: #666666">/</span>h)

nx <span style="color: #666666">=</span> Nx<span style="color: #666666">-1</span>
ny <span style="color: #666666">=</span> Ny<span style="color: #666666">-1</span>
n <span style="color: #666666">=</span> (nx)<span style="color: #666666">*</span>(ny) <span style="color: #408080; font-style: italic">#number of unknowns</span>
<span style="color: #008000; font-weight: bold">print</span> n, nx, ny

d <span style="color: #666666">=</span> np<span style="color: #666666">.</span>ones(n) <span style="color: #408080; font-style: italic"># diagonals</span>
b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(n) <span style="color: #408080; font-style: italic">#RHS</span>
d0 <span style="color: #666666">=</span> d<span style="color: #666666">*-4</span>
d1 <span style="color: #666666">=</span> d[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]
d5 <span style="color: #666666">=</span> d[<span style="color: #666666">0</span>:<span style="color: #666666">-</span>ny]

A <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>diags([d0, d1, d1, d5, d5], [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">-1</span>, ny, <span style="color: #666666">-</span>ny], format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csc&#39;</span>)

<span style="color: #408080; font-style: italic">#alternatively (scalar broadcasting version:)</span>
<span style="color: #408080; font-style: italic">#A = scipy.sparse.diags([1, 1, -4, 1, 1], [-5, -1, 0, 1, 5], shape=(15, 15)).toarray()</span>

<span style="color: #408080; font-style: italic"># set elements to zero in A matrix where BC are imposed</span>
<span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>,nx):
    j <span style="color: #666666">=</span> k<span style="color: #666666">*</span>(ny)
    i <span style="color: #666666">=</span> j <span style="color: #666666">-</span> <span style="color: #666666">1</span>
    A[i, j], A[j, i] <span style="color: #666666">=</span> <span style="color: #666666">0</span>, <span style="color: #666666">0</span>
    b[i] <span style="color: #666666">=</span> <span style="color: #666666">-</span>Ttop

b[<span style="color: #666666">-</span>ny:]<span style="color: #666666">+=-</span>Tright  <span style="color: #408080; font-style: italic">#set the last ny elements to -Tright       </span>
b[<span style="color: #666666">-1</span>]<span style="color: #666666">+=-</span>Ttop      <span style="color: #408080; font-style: italic">#set the last element to -Ttop</span>
b[<span style="color: #666666">0</span>:ny<span style="color: #666666">-1</span>]<span style="color: #666666">+=-</span>Tleft <span style="color: #408080; font-style: italic">#set the first ny elements to -Tleft </span>
b[<span style="color: #666666">0</span>::ny]<span style="color: #666666">+=-</span>Tbottom <span style="color: #408080; font-style: italic">#set every ny-th element to -Tbottom</span>

tic<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
theta <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A,b) <span style="color: #408080; font-style: italic">#theta=sc.linalg.solve_triangular(A,d)</span>
toc<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;sparse solver time:&#39;</span>,toc<span style="color: #666666">-</span>tic
 
tic<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
theta2<span style="color: #666666">=</span>scipy<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>solve(A<span style="color: #666666">.</span>toarray(),b)
toc<span style="color: #666666">=</span>time<span style="color: #666666">.</span>clock()
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;linalg solver time:&#39;</span>,toc<span style="color: #666666">-</span>tic

<span style="color: #408080; font-style: italic"># surfaceplot:</span>
x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, xmax, Nx <span style="color: #666666">+</span> <span style="color: #666666">1</span>)
y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, ymax, Ny <span style="color: #666666">+</span> <span style="color: #666666">1</span>)

X, Y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>meshgrid(x, y)

T <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(X)


<span style="color: #408080; font-style: italic"># set the imposed boudary values</span>
T[<span style="color: #666666">-1</span>,:] <span style="color: #666666">=</span> Ttop
T[<span style="color: #666666">0</span>,:] <span style="color: #666666">=</span> Tbottom
T[:,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> Tleft
T[:,<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> Tright


<span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>,ny<span style="color: #666666">+1</span>):
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, nx <span style="color: #666666">+</span> <span style="color: #666666">1</span>):
        T[j, i] <span style="color: #666666">=</span> theta[j <span style="color: #666666">+</span> (i<span style="color: #666666">-1</span>)<span style="color: #666666">*</span>ny <span style="color: #666666">-</span> <span style="color: #666666">1</span>]

    
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">mpl_toolkits.mplot3d</span> <span style="color: #008000; font-weight: bold">import</span> Axes3D
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> cm
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.ticker</span> <span style="color: #008000; font-weight: bold">import</span> LinearLocator, FormatStrFormatter

fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
ax <span style="color: #666666">=</span> fig<span style="color: #666666">.</span>gca(projection<span style="color: #666666">=</span><span style="color: #BA2121">&#39;3d&#39;</span>)
surf <span style="color: #666666">=</span> ax<span style="color: #666666">.</span>plot_surface(X, Y, T, rstride<span style="color: #666666">=1</span>, cstride<span style="color: #666666">=1</span>, cmap<span style="color: #666666">=</span>cm<span style="color: #666666">.</span>coolwarm,
                       linewidth<span style="color: #666666">=0</span>, antialiased<span style="color: #666666">=</span><span style="color: #008000">False</span>)
ax<span style="color: #666666">.</span>set_zlim(<span style="color: #666666">0</span>, Ttop<span style="color: #666666">+10</span>)
ax<span style="color: #666666">.</span>set_xlabel(<span style="color: #BA2121">&#39;x&#39;</span>)
ax<span style="color: #666666">.</span>set_ylabel(<span style="color: #BA2121">&#39;y&#39;</span>)
ax<span style="color: #666666">.</span>set_zlabel(<span style="color: #BA2121">&#39;T [$^o$C]&#39;</span>)


nx<span style="color: #666666">=4</span>
xticks<span style="color: #666666">=</span>np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0.0</span>,xmax,nx<span style="color: #666666">+1</span>)
ax<span style="color: #666666">.</span>set_xticks(xticks)

ny<span style="color: #666666">=8</span>
yticks<span style="color: #666666">=</span>np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0.0</span>,ymax,ny<span style="color: #666666">+1</span>)
ax<span style="color: #666666">.</span>set_yticks(yticks)

nTicks<span style="color: #666666">=5</span>
dT<span style="color: #666666">=</span><span style="color: #008000">int</span>(Ttop<span style="color: #666666">/</span>nTicks)
Tticklist<span style="color: #666666">=</span><span style="color: #008000">range</span>(<span style="color: #666666">0</span>,Ttop<span style="color: #666666">+1</span>,dT)
ax<span style="color: #666666">.</span>set_zticks(Tticklist)

<span style="color: #408080; font-style: italic">#fig.colorbar(surf, shrink=0.5, aspect=5)</span>
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
Vi får følgende resultat der tallene i parantes er beregnet fra den analytiske løsningen i \eqref{eq:7206}:

$$
\begin{align*}
  &T_{11}=T_{31}=1.578\ (1.406),\ T_{12}=T_{32}=4.092\ (3.725)\\ 
  &T_{13}=T_{33}=9.057\ (8.483),\ T_{14}=T_{34}=19.620\ (18.945)\\ 
  &T_{15}=T_{35}=43.193\ (43.483),\ T_{21}=2.222\ (1.987),\ T_{22}=5.731\ (5.261)\\ 
  &T_{23}=12.518\ (11.924),\ T_{24}=26.228\ (26.049),\ T_{25}=53.154\ (54.449)
\end{align*}
$$

<p>
The structure of the coefficient matrix will not necessarily be so
regular cases, e.g. more complicated operators than the
Laplace-operator or even more so for non-linear problems. Even though
the matrix will predominantly be sparse also for these problems, the
requirements for fast solutions and efficent storage will be harder to
obtain for the problems. For such problems iterative methods are
appealing, as they often are relatively simple to program and hoffer
effective memory management. However, they are often hapered by
convergence challanges. We will look into iterative methods in a later
section.

<p>
<!-- !split -->

<h2 id="kap:722">von Neumann boundary conditions</h2>

<p>
The problem illustrated in Figure <a href="#fig:74">70</a>  has
prescribed temperatures on the boundaries (i.e. Dirichlet boundaray
conditions). In this section we will consider a problem with identical
governing equation \eqref{eq:7201} as for the problem in
<a href="#fig:74">70</a>. The only difference being that we consider von Neuman
conditions, i.e. zero derivatives, at \( x=0 \) og \( y=0 \), as illustrated
in figure <a href="#fig:76">60</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 60:  Laplace-equation for a quadratic domain with von Neumann boundary conditions. <div id="fig:76"></div> </p></center>
<p><img src="fig-ch7/8.png" align="bottom" width=400></p>
</center>

<p>
Mathematically the problem in Figure <a href="#fig:76">60</a>, is specified with
the governing equation \eqref{eq:7201} which we reiterate for
convenience:

$$
\begin{equation}
  \frac{\partial^2T}{\partial x^2}+\frac{\partial^2T}{\partial y^2}=0
\label{eq:72213a}
\end{equation}
$$

with corresponding boundary conditions (von Neuman)
$$
\begin{align}
    \frac{\partial T}{\partial x}=0 \quad \text{ for } x=0, \text{ and } 0 < y < 1
\label{_auto42}\\ 
    \frac{\partial T}{\partial y}=0 \quad \text{ for } y=0, \text{ and } 0 < x < 1
\label{eq:72213b}
\end{align}
$$

and prescribed values for:
$$
\begin{align*}
  T=1 \quad \text{ for } y=1,\text{ and } 0\leq x\leq1\\ 
  T=0 \quad \text{ for } x=1,\text{ and } 0\leq y < 1
\end{align*}
$$

<p>
By assuming \( \Delta x=\Delta y \), as for the Dirichlet problem, an
identical, generic difference equation is obtained as in
\eqref{eq:7202}. However, at the boundaries we need to take into
account the von Neumann conditions. We will take a closer look at
\( \dfrac{\partial T}{\partial x}=0 \) for \( x=0 \). The other von Neuman
boundary is treated in the same manner. Notice that we have
discontinuities in the corners \( (1,0) \) og \( (1,1) \), additionally the
corner \( (0,0) \) may cause problems too.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 61:  Illustration of how ghostcells with negative indices may be used to implement von Neumann boundary conditions.  <div id="fig:77"></div> </p></center>
<p><img src="fig-ch7/9.png" align="bottom" width=400></p>
</center>

<p>
A central difference approximation (see Figure <a href="#fig:77">61</a>) of \( \dfrac{\partial T}{\partial x}=0 \) at \( i=0 \) yields:
$$
\begin{equation}
  \frac{T_{1,j}-T_{-1,j}}{2\Delta x}=0 \to T_{-1,j}=T_{1,j}
\label{eq:72214}
\end{equation}
$$

<p>
where we have introduced ghostcells with negative indices outside the
physical domain to express the derivative at the boundary. Note that
the requirement of a zero derivative relate the value of the
ghostcells to the values inside the physical domain.

<p>
One might also approximate \( \dfrac{\partial T}{\partial x}=0 \)  by forward differences (see \eqref{eq:5105}) for a generic discrete point \( (i,j) \): 

$$
\begin{equation*}
  \frac{\partial T}{\partial x}\bigg|_ {i,j} = \frac{-3T_{i,j}+4T_{i+1,j}-T_{i+2,j}}{2\Delta x}
\end{equation*}
$$

<p>
which for \( \dfrac{\partial T}{\partial x}=0 \) for \( x=0 \) reduce to:

$$
\begin{equation}
  T_{0,j}=\frac{4T_{1,j}-T_{2,j}}{3}
\label{eq:72215}
\end{equation}
$$

<p>
For the problem at hand, illustrated in Figure <a href="#fig:76">60</a>, central
difference approximation \eqref{eq:72214} and forward difference
approximation \eqref{eq:72215} yields fairly similar results, but
\eqref{eq:72215} results in a shorter code when the methods in
<a href="#kap:73">Iteration methods for linear algebraic equation systems</a> are employed.

<p>
To solve the problem in Figure <a href="#fig:76">60</a>  we employ the numerical stencil  \eqref{eq:compass} for the unknows in the field (not influenced by the boundaries)
$$
\begin{equation}
  T_w+ T_e + T_s+ T_n -4 T_m=0
\label{eq:72216}
\end{equation}
$$

where we used the same ordering as given in Figurw <a href="#fig:78">62</a>. For the boundary conditions we have chosen to implement the by means of \eqref{eq:72214} which is illustrated in Figure <a href="#fig:78">62</a> by the dashed lines.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 62:  Von Neumann boundary conditions with ghost cells. <div id="fig:78"></div> </p></center>
<p><img src="fig-ch7/10.png" align="bottom" width=400></p>
</center>

<p>
Before setting up the complete equation system it normally pays of to
look at the boundaries, like the lowermost boundary, which by
systematic usage of \eqref{eq:72216} along with the boundary conditions
in \eqref{eq:72213b} yield:

$$
\begin{align*}
  &2T_2+2T_5-4T_1=0\\ 
  &T_1+2T_6+T_3-4T_2=0\\ 
  &T_2+2T_7+T_4-4T_3=0\\ 
  &T_3+2T_8-4T_4=0\\ 
\end{align*}
$$

The equations for the upper boundary become:
$$
\begin{align*}
  &T_9+2T_{14}-4T_{13}=-1\\ 
  &T_{10}+T_{13}+T_{15}-4T_{14}=-1\\ 
  &T_{11}+T_{14}+T_{16}-4T_{15}=-1\\ 
  &T_{12}+T_{15}-4T_{16}=-1
\end{align*}
$$

<p>
Notice that for the coarse mesh with only 16 unknown temperatures (see
Figure <a href="#fig:76">60</a>) only 4 (\( T_{6} \), \( T_{7} \), \( T_{10} \), and \( T_{11} \))
are not explicitly influenced by the boundaries.Finally, the complete
discretized equation system for the problem may be represented:

$$
\begin{equation}
    \left(\begin{array}{cccccccccccccccc}
      -4& 2 & 0 & 0 & 2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &0 & 0\\ 
      1& -4 & 1 & 0 & 0 & 2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &0 & 0\\ 
      0& 1 & -4 & 1 & 0 & 0 & 2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &0 & 0\\ 
      0& 0 & 1 & -4 & 0 & 0 & 0 & 2 & 0 & 0 & 0 & 0 & 0 & 0 &0 & 0\\ 
      1& 0 & 0 & 0 & -4 & 2 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 &0 & 0\\ 
      0& 1 & 0 & 0 & 1 & -4 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 &0 & 0\\ 
      0& 0 & 1 & 0 & 0 & 1 & -4 & 1 & 0 & 0 & 1 & 0 & 0 & 0 &0 & 0\\ 
      0& 0 & 0 & 1 & 0 & 0 & 1 & -4 & 0 & 0 & 0 & 1 & 0 & 0 &0 & 0\\ 
      0& 0 & 0 & 0 & 1 & 0 & 0 & 0 & -4 & 2 & 0 & 0 & 1 & 0 &0 & 0\\ 
      0& 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & -4 & 1 & 0 & 0 & 1 &0 & 0\\ 
      0& 0 & 0 & 0 & 0 & 0 &1 & 0 & 0 & 1 & -4 &  1 & 0 & 0 &1 & 0\\ 
      0& 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & -4 & 0 & 0 &0 & 1\\ 
      0& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & -4 & 2 &0 & 0\\ 
      0& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & -4 &1 & 0\\ 
      0& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 &-4 & 1\\ 
      0& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 &-4
    \end{array}\right)
    \cdot
    \left(\begin{array}{c}
      T_{1}\\ 
      T_{2}\\ 
      T_{3}\\ 
      T_{4}\\ 
      T_{5}\\ 
      T_{6}\\ 
      T_{7}\\ 
      T_{8}\\ 
      T_{9}\\ 
      T_{10}\\ 
      T_{11}\\ 
      T_{12}\\ 
      T_{13}\\ 
      T_{14}\\ 
      T_{15}\\ 
      T_{16}
    \end{array}\right)
    =
    \left(\begin{array}{c}
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      -1\\ 
      -1\\ 
      -1\\ 
      -1
    \end{array}\right)
\label{eq:72217}
\end{equation}
$$

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy</span> 
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.linalg</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">scipy.sparse.linalg</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pylab</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">time</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sinh

<span style="color: #408080; font-style: italic">#import matplotlib.pyplot as plt</span>

<span style="color: #408080; font-style: italic"># Change some default values to make plots more readable on the screen</span>
LNWDT<span style="color: #666666">=2</span>; FNT<span style="color: #666666">=15</span>
plt<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; plt<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">setup_LaplaceNeumann_xy</span>(Ttop, Tright, nx, ny):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Function that returns A matrix and b vector  of the laplace Neumann heat problem A*T=b using central differences</span>
<span style="color: #BA2121; font-style: italic">        and assuming dx=dy, based on numbering with respect to x-dir, e.g:</span>
<span style="color: #BA2121; font-style: italic">        </span>
<span style="color: #BA2121; font-style: italic">                1   1   1             -4  2  2  0  0  0          0</span>
<span style="color: #BA2121; font-style: italic">            T6  T5  T6  0              1 -4  0  2  0  0          0</span>
<span style="color: #BA2121; font-style: italic">            T4  T3  T4  0              1  0 -4  2  1  0          0</span>
<span style="color: #BA2121; font-style: italic">            T2  T1  T2  0     --&gt; A =  0  1  1 -4  0  1    ,b =  0</span>
<span style="color: #BA2121; font-style: italic">                T3  T4                 0  0  1  0 -4  2         -1</span>
<span style="color: #BA2121; font-style: italic">                                       0  0  0  1  1 -4         -1</span>
<span style="color: #BA2121; font-style: italic">            </span>
<span style="color: #BA2121; font-style: italic">            T = [T1, T2, T3, T4, T5, T6]^T</span>
<span style="color: #BA2121; font-style: italic">            </span>
<span style="color: #BA2121; font-style: italic">        Args:</span>
<span style="color: #BA2121; font-style: italic">            nx(int): number of elements in each row in the grid, nx=2 in the example above</span>
<span style="color: #BA2121; font-style: italic">            ny(int): number of elements in each column in the grid, ny=3 in the example above</span>
<span style="color: #BA2121; font-style: italic">        Returns:</span>
<span style="color: #BA2121; font-style: italic">            A(matrix): Sparse matrix A, in the equation A*T = b</span>
<span style="color: #BA2121; font-style: italic">            b(array): RHS, of the equation A*t = b</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    
    n <span style="color: #666666">=</span> (nx)<span style="color: #666666">*</span>(ny) <span style="color: #408080; font-style: italic">#number of unknowns</span>
    d <span style="color: #666666">=</span> np<span style="color: #666666">.</span>ones(n) <span style="color: #408080; font-style: italic"># diagonals</span>
    b <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(n) <span style="color: #408080; font-style: italic">#RHS</span>
    
    d0 <span style="color: #666666">=</span> d<span style="color: #666666">.</span>copy()<span style="color: #666666">*-4</span>
    d1_lower <span style="color: #666666">=</span> d<span style="color: #666666">.</span>copy()[<span style="color: #666666">0</span>:<span style="color: #666666">-1</span>]
    d1_upper <span style="color: #666666">=</span> d1_lower<span style="color: #666666">.</span>copy()
    
    dnx_lower <span style="color: #666666">=</span> d<span style="color: #666666">.</span>copy()[<span style="color: #666666">0</span>:<span style="color: #666666">-</span>nx]
    dnx_upper <span style="color: #666666">=</span> dnx_lower<span style="color: #666666">.</span>copy()
    
    d1_lower[nx<span style="color: #666666">-1</span>::nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span> <span style="color: #408080; font-style: italic"># every nx element on first diagonal is zero; starting from the nx-th element</span>
    d1_upper[nx<span style="color: #666666">-1</span>::nx] <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    d1_upper[::nx] <span style="color: #666666">=</span> <span style="color: #666666">2</span> <span style="color: #408080; font-style: italic"># every nx element on first upper diagonal is two; stating from the first element. </span>
                 <span style="color: #408080; font-style: italic"># this correspond to all equations on border (x=0, y)</span>
    
    dnx_upper[<span style="color: #666666">0</span>:nx] <span style="color: #666666">=</span> <span style="color: #666666">2</span> <span style="color: #408080; font-style: italic"># the first nx elements in the nx-th upper diagonal is two; </span>
                        <span style="color: #408080; font-style: italic"># This correspond to all equations on border (x, y=0) </span>
    
    b[<span style="color: #666666">-</span>nx:] <span style="color: #666666">=</span> <span style="color: #666666">-</span>Ttop
    b[nx<span style="color: #666666">-1</span>::nx] <span style="color: #666666">+=</span> <span style="color: #666666">-</span>Tright

    A <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>diags([d0, d1_upper, d1_lower, dnx_upper, dnx_lower], [<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">-1</span>, nx, <span style="color: #666666">-</span>nx], format<span style="color: #666666">=</span><span style="color: #BA2121">&#39;csc&#39;</span>)
    
    <span style="color: #008000; font-weight: bold">return</span> A, b

<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">Visualization</span> <span style="color: #008000; font-weight: bold">import</span> plot_SurfaceNeumann_xy
    <span style="color: #408080; font-style: italic"># Main program</span>
    <span style="color: #408080; font-style: italic"># Set temperature at the top</span>
    Ttop<span style="color: #666666">=1</span>
    Tright <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
    xmax<span style="color: #666666">=1.0</span>
    ymax<span style="color: #666666">=1.</span>
     
    <span style="color: #408080; font-style: italic"># Set simulation parameters</span>
    <span style="color: #408080; font-style: italic">#need hx=(1/nx)=hy=(1.5/ny)</span>
    
    Nx <span style="color: #666666">=</span> <span style="color: #666666">10</span>
    h<span style="color: #666666">=</span>xmax<span style="color: #666666">/</span>Nx
    Ny <span style="color: #666666">=</span> <span style="color: #008000">int</span>(ymax<span style="color: #666666">/</span>h)
    
    A, b <span style="color: #666666">=</span> setup_LaplaceNeumann_xy(Ttop, Tright, Nx, Ny)
    
    Temp <span style="color: #666666">=</span> scipy<span style="color: #666666">.</span>sparse<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>spsolve(A, b)
    
    plot_SurfaceNeumann_xy(Temp, Ttop, Tright, xmax, ymax, Nx, Ny)

<span style="color: #408080; font-style: italic">#    figfile=&#39;LaPlace_vNeumann.png&#39;</span>
<span style="color: #408080; font-style: italic">#    plt.savefig(figfile, format=&#39;png&#39;,transparent=True)</span>
    plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
The analytical solution is given by:

$$
\begin{align}
    &T(x,y)	= \sum^\infty_{n=1}A_n\cosh(\lambda_ny)\cdot\cos(\lambda_nx),
\label{_auto43}\\ 
    &\text{der } \lambda_n=(2n-1)\cdot\frac{\pi}{2},\ A_n=2\frac{(-1)^{n-1}}{\lambda_n\cosh(\lambda_n)},\ n=1,2,\dots
\label{_auto44}
\end{align}
$$

<p>
The solution for the problem illustrated Figure <a href="#fig:76">60</a> is
computed and visualized the the python code above. The solution is
illustrated in Figure <a href="#fig:712">66</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 63:  Solution of the Laplace equation with von Neuman boundary conditions. <div id="fig:712"></div> </p></center>
<p><img src="fig-ch7/12_python_vNeuman.png" align="bottom" width=800></p>
</center>

<h1 id="kap:73">Iteration methods for linear algebraic equation systems</h1>

<h2 id="kap:731">EKSEMPLER</h2>

<p>
In ref{kap:37} we introduced the classical iteration methods,
Jacobi, Gauss-Seidel og SOR, for the solution of ordinary
differtential equations (ODEs).

<p>
Vi skal her se nærmere på noen av disse metodene, hovedsakelig brukt på lineære, elliptiske differensialligninger.

<p>
Konvergenskriterier er behandlet i \ref {kap:732}.

<p>
Anta at vi har et system av lineære, algebraiske ligninger \( \mathbf{ A\cdot x=b} \)  som
utskrevet for et sett av tre ligninger blir:

$$
\begin{align}
    &a_{11}x_1+a_{12}x_2+a_{13}x_3=b_1
\label{_auto45}\\ 
    &a_{21}x_1+a_{22}x_2+a_{23}x_3=b_2
\label{_auto46}\\ 
    &a_{31}x_1+a_{32}x_2+a_{33}x_3=b_3
\label{eq:7311}
\end{align}
$$

Skriver  \eqref{eq:7311} på følgende måte:

$$
\begin{align}
    &x_1=x_1 +\frac{1}{a_{11}}[b_1-(a_{11}x_1+a_{12}x_2+a_{13}x_3)]
\label{_auto47}\\ 
    &x_2=x_2 +\frac{1}{a_{22}}[b_2-(a_{21}x_1+a_{22}x_2+a_{23}x_3)]
\label{_auto48}\\ 
    &x_3=x_3 +\frac{1}{a_{33}}[b_3-(a_{31}x_1+a_{32}x_2+a_{33}x_3)]
\label{eq:7312}
\end{align}
$$

<p>
Lager oss en iterasjonsprosess ved å skrive:

$$
\begin{align}
    &x_1^{m+1}=x_1^{m} +\frac{1}{a_{11}}[b_1-(a_{11}x_1^{m}+a_{12}x_2^{m}+a_{13}x_3^{m})]
\label{_auto49}\\ 
    &x_2^{m+1}=x_2^{m} +\frac{1}{a_{22}}[b_2-(a_{21}x_1^{m}+a_{22}x_2^{m}+a_{23}x_3^{m})]
\label{_auto50}\\ 
    &x_3^{m+1}=x_3^{m}
      +\frac{1}{a_{33}}[b_3-(a_{31}x_1^{m}+a_{32}x_2^{m}+a_{33}x_3^{m})]
\label{eq:7313}
\end{align}
$$

<p>
der \( m \) og \( m+1 \)  er iterasjonsnummer. \eqref{eq:7313} kan skrives kompakt for et
system av \( n \) ligninger:

$$
\begin{align}
    &x_i^{m+1}=x_i^m+\delta x_i
\label{_auto51}\\ 
    &\delta x_i=\frac{1}{a_{ii}} \left[b_i-\sum^n_{j=1}a_{ij}x^m_j\right],\ i=1,2,\dots,n,\ m=0,1,\dots
\label{eq:7314}
\end{align}
$$

Iterasjonsprosessen starter ved å velge verdier \( x=x_0 \) ved iterasjon  \( m=0 \).

<p>
Prosessen i \eqref{eq:7314} kalles Jacobis metode . Den kan også utledes direkte fra lign. \eqref{eq:3703} i ref{kap:37}. Vi ser av \eqref{eq:7313} at metoden kan forbedres ved å sette inn for \( x_1^{m+1} \)  i den andre ligningen og for \( x_1^{m+1} \) og \( x_2^{m+1} \) i den tredje ligningen, slik at vi får:

$$
\begin{align}
    &x_1^{m+1}=x_1^{m} +\frac{1}{a_{11}}[b_1-(a_{11}x_1^{m}+a_{12}x_2^{m}+a_{13}x_3^{m})]
\label{_auto52}\\ 
    &x_2^{m+1}=x_2^{m} +\frac{1}{a_{22}}[b_2-(a_{21}x_1^{m}+a_{22}x_2^{m}+a_{23}x_3^{m})]
\label{_auto53}\\ 
    &x_3^{m+1}=x_3^{m} +\frac{1}{a_{33}}[b_3-(a_{31}x_1^{m}+a_{32}x_2^{m}+a_{33}x_3^{m})]
\label{eq:7315}
\end{align}
$$

Dette er Gauss-Seidels metode. 
Ved å multiplisere med en faktor \( \omega \), får vi enda en variant:

$$
\begin{align}
  &x_1^{m+1}=x_1^{m} +\frac{\omega}{a_{11}}[b_1-(a_{11}x_1^{m}+a_{12}x_2^{m}+a_{13}x_3^{m})]
\label{_auto54}\\ 
  &x_2^{m+1}=x_2^{m} +\frac{\omega}{a_{22}}[b_2-(a_{21}x_1^{m}+a_{22}x_2^{m}+a_{23}x_3^{m})]
\label{_auto55}\\ 
  &x_3^{m+1}=x_3^{m}
    +\frac{\omega}{a_{33}}[b_3-(a_{31}x_1^{m}+a_{32}x_2^{m}+a_{33}x_3^{m})]
\label{eq:7316a}
\end{align}
$$

Generelt kan \eqref{eq:7316a} skrives:

$$
\begin{align}
  &x_i^{m+1}=x_i^m+\delta x_i
\label{_auto56}\\ 
  &\delta x_i=\frac{\omega}{a_{ii}}
    \left[b_i-\left(\sum^{i-1}_{k=1}a_{ik}x^{m+1}_k+\sum^n_{k=1}a_{ik}x^m_k\right)\right],\ 
    i=1,2,\dots,n,
\label{eq:7316b}
\end{align}
$$

<p>
Faktoren \( \omega \)  kalles \( relaksasjonsparameteren \) eller \( relaksasjonsfaktoren \). Metoden i \eqref{eq:7316b} kalles sukssesiv overrelaksasjon når \( \omega>1 \), vanligvis forkortet til SOR. \( \omega=1 \) gir Gauss-Seidels metode. Det kan vises at \( \omega \)  ligger i intervallet  \( (0, 2) \) for Laplace - og Poissonligninger, men \( \omega >1 \)  er mest effektivt.
Vi skal ikke bruke SOR på ligningsystem gitt på formen
\eqref{eq:7311}, men isteden bruke differanseligningene direkte, 
like in the chapter ref{kap:37}.

<p>
La oss se på en Poissonligning:

$$
\begin{equation} \label{eq:7317}
  \frac{\partial^2u}{\partial x^2}+\frac{\partial^2u}{\partial y^2}=f(x,y)
\end{equation}
$$

som diskretisert med \( \Delta x=\Delta y = h \) gir følgende differanseligning:

$$
\begin{align}
  u_{i-1,j}+u_{i+1,j}+u_{i,j+1}+u_{i,j-1}-4u_{i,j}=h^2\cdot f_{i,j}
\label{eq:7318a}
\end{align}
$$

Som vanlig:

$$
\begin{align}
  &x_i=x_0+i\cdot h,\ i=0,1,2,\dots,i_{max}
\label{_auto57}\\ 
  &y_j=y_0+j\cdot h,\ j=0,1,2,\dots,j_{max}
\label{eq:7318b}
\end{align}
$$

<p>
(Se <a href="#kap:72">Direct numerical solution</a>)

<p>
Dersom vi bruker \eqref{eq:7316b} på \eqref{eq:7318a} og \eqref{eq:7318b} får vi:

$$
\begin{align}
    &u_{i,j}^{m+1}=u_{i,j}^m+\delta u_{i,j}
\label{_auto58}\\ 
    &\delta u_{i,j}=\frac{\omega}{4}
      \left[u^{m+1}_{i-1,j}+u^{m+1}_{i,j-1}+u^{m}_{i+1,j}+u^{m}_{i,j+1}-4u^{m}_{i,j}-h^2\cdot
      f_{i,j}\right] \label{eq:7319}
\end{align}
$$

Kan også skrive:

$$
\begin{align}
    &u_{i,j}^{m+1}=u_{i,j}^m+\frac{\omega}{4}R_{i,j}
\label{_auto59}\\ 
    &R_{i,j}=\left[u^{m+1}_{i-1,j}+u^{m+1}_{i,j-1}+u^{m}_{i+1,j}+u^{m}_{i,j+1}-4u^{m}_{i,j}-h^2\cdot
      f_{i,j}\right]
\label{eq:73110}
\end{align}
$$

\( R_{i,j} \)  kalles residuet (avviket) i punkt \( (i,j) \).

<p>
Løser nå eksemplet i figur <a href="#fig:73">57</a>, <a href="#kap:72">Direct numerical solution</a>,  med bruk av \eqref{eq:7319}.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 64:  Caption goes here.   <div id="fig:710"></div> </p></center>
<p><img src="fig-ch7/13.png" align="bottom" width=400></p>
</center>

<p>
Figur <a href="#fig:710">64</a> viser figur <a href="#fig:73">57</a> med ny indeksering. Vi tar ikke hensyn til symmetrien.
\( i \)-indeks henviser til \( x \)-retningen, \( j \)-indeks til \( y \)-retningen.

<p>
Randverdier:

$$
\begin{align}
    &\text{Langs }x=0: T_{1,j}=0.0,\ j=1,2,\dots,6
\label{_auto60}\\ 
    &\text{Langs }x=1: T_{5,j}=0.0,\ j=1,2,\dots,6
\label{_auto61}\\ 
    &\text{Langs }y=0: T_{i,1}=0.0,\ i=2,3,\dots,4
\label{_auto62}\\ 
    &\text{Langs }y=1.5: T_{i,7}=100,\ i=1,2,\dots,5
\label{eq:73111}
\end{align}
$$

<p>
Velger startverdier lik 0 for de andre temperaturene. Bruker \( \omega = 1.5 \)  og
utfører 20 iterasjoner som vist i programmet <b>lapsor1v1</b> nedenfor. \( h=0.25 \).

<p>

<!-- code=matlab (!bc mcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">  <span style="color: #408080; font-style: italic">% program lapsor1v1</span>
  clear
  nx = <span style="color: #666666">4</span> ; <span style="color: #408080; font-style: italic">% parts in x-direction</span>
  ny = <span style="color: #666666">6</span>;  <span style="color: #408080; font-style: italic">% parts in y-direction</span>
  imax = nx <span style="color: #666666">+</span> <span style="color: #666666">1</span>; <span style="color: #408080; font-style: italic">% points in x-direction</span>
  jmax = ny <span style="color: #666666">+</span> <span style="color: #666666">1</span>; <span style="color: #408080; font-style: italic">% points in y-direction</span>
  T = <span style="color: #008000">zeros</span>(imax,jmax); <span style="color: #408080; font-style: italic">% temperatures</span>
  T(<span style="color: #666666">1</span>:imax,jmax) = <span style="color: #666666">100</span>; <span style="color: #408080; font-style: italic">%  boundary values</span>
  omega = <span style="color: #666666">1.5</span>; <span style="color: #408080; font-style: italic">% relaxation factor</span>
  <span style="color: #408080; font-style: italic">% --- Start iteration ---</span>
  <span style="color: #008000; font-weight: bold">for</span> it = <span style="color: #666666">1</span>: <span style="color: #666666">20</span>
  <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">i</span> = <span style="color: #666666">2</span>: imax<span style="color: #666666">-1</span>
  <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">j</span> = <span style="color: #666666">2</span>: jmax<span style="color: #666666">-1</span>
  resid = (T(<span style="color: #008000">i</span><span style="color: #666666">-1</span>,<span style="color: #008000">j</span>)<span style="color: #666666">+</span>T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span><span style="color: #666666">-1</span>) <span style="color: #666666">+</span> T(<span style="color: #008000">i</span><span style="color: #666666">+1</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span><span style="color: #666666">+1</span>) <span style="color: #666666">-</span> <span style="color: #666666">4*</span>T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>));
  dT = <span style="color: #666666">0.25*</span>omega<span style="color: #666666">*</span>resid;
  T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>) = T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> dT;
  <span style="color: #008000; font-weight: bold">end</span>
  <span style="color: #008000; font-weight: bold">end</span>
  <span style="color: #008000; font-weight: bold">end</span>
</pre></div>
<p>
Utskrift av T-matrise:

<p>

<div class="row">
  <div class="col-xs-5">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>0</b></td> <td align="center"><b>  0   </b></td> <td align="center"><b>  0   </b></td> <td align="center"><b>   0   </b></td> <td align="center"><b>   0   </b></td> <td align="center"><b>   0   </b></td> <td align="center"><b>100.0000</b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   0    </td> <td align="center">   1.5784    </td> <td align="center">   4.0918    </td> <td align="center">   9.0575     </td> <td align="center">   19.6196    </td> <td align="center">   43.1933    </td> <td align="center">   100.0000    </td> </tr>
<tr><td align="center">   0    </td> <td align="center">   2.2220    </td> <td align="center">   5.7310    </td> <td align="center">   12.5185    </td> <td align="center">   26.2279    </td> <td align="center">   53.1537    </td> <td align="center">   100.0000    </td> </tr>
<tr><td align="center">   0    </td> <td align="center">   1.5784    </td> <td align="center">   4.0917    </td> <td align="center">   9.0575     </td> <td align="center">   19.6197    </td> <td align="center">   43.1933    </td> <td align="center">   100.0000    </td> </tr>
<tr><td align="center">   0    </td> <td align="center">   0         </td> <td align="center">   0         </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   0          </td> <td align="center">   100.0000    </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-5 -->
<p>
Resultatet stemmer godt overens med verdiene gitt i <a href="#kap:72">Direct numerical solution</a>.
I dette programmet har vi valgt vilkårlig \( \omega=1.5 \)  og antall iterasjoner lik 20.
Vi ønsker selvfølgelig et program med en selvstoppende iterasjonsprosess. Dessuten er det ønskelig med en  \( \omega \)-verdi som gir færrest mulig iterasjoner for en gitt nøyaktighet.

<h3 id="___sec69">Stoppkriterier </h3>

<p>
Eksempelvis kan vi bruke \( \max(\delta T_{i,j}) < \varepsilon_a \) eller
\( \max\left( \dfrac{\delta T_{i,j}}{T_{i,j}} \right) < \varepsilon_r \).
Eventuelt kan vi bruke residuet isteden. Andre alternativ:

$$
\begin{equation}
  \frac{1}{N} \sum_i\sum_j|\delta T_{i,j}| < tol_a,\ 
  \frac{1}{N}\sum_i\sum_j\left|\frac{\delta T_{i,j}}{T_{i,j}}
  \right| < tol_r,\ |T_{i,j}|\neq 0 \label{eq:73112}
\end{equation}
$$

<p>
\( N \) er antall beregningspunkt. I \eqref{eq:73112} kan residuet brukes istedet for  \( \delta T_{i,j} \).
I den første uttrykket bruker vi en absolutt toleranse, mens vi bruker en relativ toleranse  i det siste. Velger å bruke følgende alternativ til \eqref{eq:73112}:

$$
\begin{equation}
  \frac{\sum_i\sum_j\left|\delta
      T_{i,j}\right|}{\sum_i\sum_j\left|T_{i,j}\right|} < tol_r,\ 
  \frac{\max\left(\left|\delta T_{i,j}
      \right|\right)}{\max\left(\left| T_{i,j} \right|\right)} < tol_r \label{eq:73113}
\end{equation}
$$

<p>
\eqref{eq:73113} gir en slags midlere relativ feiltest. Vi summerer over alle beregnings-punktene i disse formlene. Fra figur <a href="#fig:310">48</a> i ref{kap:37}, ser vi at antall iterasjoner er en funksjon både av \( \omega \)  og \( h \), der vi bruker  \( \Delta x=\Delta y=h \). Lager derfor et program der vi kan variere skrittlengden \( h \). I programmet <b>lapsor1v2</b> på neste side, kan vi forandre \( h \) i trinn med \( h_n=\frac{h}{2^n},\ n=0,1,\dots \)
Bruker \( \frac{\sum_i\sum_j\left|\delta
    T_{i,j}\right|}{\sum_i\sum_j\left|T_{i,j}\right|} < tol_r, \) som
stoppkriterium.  Figur <a href="#fig:711">65</a> viser antall iterasjoner som funksjon av \( \omega \)  og \( h \) med \( tol_r=10^{-5} \)

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 65:  Caption goes here. <div id="fig:711"></div> </p></center>
<p><img src="fig-ch7/14.png" align="bottom" width=400></p>
</center>

<p>

<!-- code=matlab (!bc mcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">  <span style="color: #408080; font-style: italic">% program lapsor1v2</span>
  clear
  n = <span style="color: #666666">0</span>;
  fac = <span style="color: #666666">2</span>^(n<span style="color: #666666">+1</span>);
  imax = <span style="color: #666666">2*</span>fac <span style="color: #666666">+</span> <span style="color: #666666">1</span>; <span style="color: #408080; font-style: italic">% points in x-direction</span>
  jmax = <span style="color: #666666">3*</span>fac <span style="color: #666666">+</span> <span style="color: #666666">1</span>; <span style="color: #408080; font-style: italic">% points in y-direction</span>
  T = <span style="color: #008000">zeros</span>(imax,jmax); <span style="color: #408080; font-style: italic">% temperatures</span>

  T(<span style="color: #666666">1</span>:imax,jmax) = <span style="color: #666666">100</span>; <span style="color: #408080; font-style: italic">% boundary values</span>
  reltol = <span style="color: #666666">1.0e-5</span>; <span style="color: #408080; font-style: italic">% relative iteration error</span>
  omega = <span style="color: #666666">1.95</span>; <span style="color: #408080; font-style: italic">% relaxation factor</span>
  relres = <span style="color: #666666">1.0</span>; it = <span style="color: #666666">0</span>;
  <span style="color: #408080; font-style: italic">% --- Start iteration ---</span>
  <span style="color: #008000; font-weight: bold">while</span> relres <span style="color: #666666">&gt;</span> reltol
  it = it <span style="color: #666666">+</span> <span style="color: #666666">1</span>;
  Tsum = <span style="color: #666666">0.0</span>; dTsum = <span style="color: #666666">0.0</span>;
  <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">i</span> = <span style="color: #666666">2</span>: imax<span style="color: #666666">-1</span>
  <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">j</span> = <span style="color: #666666">2</span>: jmax<span style="color: #666666">-1</span>
  resid = T(<span style="color: #008000">i</span><span style="color: #666666">-1</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span><span style="color: #666666">-1</span>) <span style="color: #666666">+</span> T(<span style="color: #008000">i</span><span style="color: #666666">+1</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span><span style="color: #666666">+1</span>)<span style="color: #666666">-4*</span>T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>);
  dT = <span style="color: #666666">0.25*</span>omega<span style="color: #666666">*</span>resid;
  dTsum = dTsum <span style="color: #666666">+</span> <span style="color: #008000">abs</span>(dT);
  T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>) = T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> dT;
  Tsum = Tsum <span style="color: #666666">+</span> <span style="color: #008000">abs</span>(T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>));
  <span style="color: #008000; font-weight: bold">end</span>
  <span style="color: #008000; font-weight: bold">end</span>
  relres = dTsum<span style="color: #666666">/</span>Tsum;
  <span style="color: #008000; font-weight: bold">end</span>
</pre></div>
<p>
Dersom vi isteden bruker \( \frac{\max\left(\left|\delta T_{i,j}
    \right|\right)}{\max\left(\left| T_{i,j} \right|\right)} < tol_r \) som stoppkriterium, vil iterasjonløkka bli:

<p>

<!-- code=matlab (!bc mcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">  <span style="color: #008000; font-weight: bold">while</span> relres <span style="color: #666666">&gt;</span> reltol
  it = it <span style="color: #666666">+</span> <span style="color: #666666">1</span>;
  Tmax = <span style="color: #666666">0.0</span>; dTmax = <span style="color: #666666">0.0</span>;
  <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">i</span> = <span style="color: #666666">2</span>: imax<span style="color: #666666">-1</span>
  <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">j</span> = <span style="color: #666666">2</span>: jmax<span style="color: #666666">-1</span>
  resid = T(<span style="color: #008000">i</span><span style="color: #666666">-1</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span><span style="color: #666666">-1</span>) <span style="color: #666666">+</span> T(<span style="color: #008000">i</span><span style="color: #666666">+1</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span><span style="color: #666666">+1</span>)<span style="color: #666666">-4*</span>T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>);
  dT = <span style="color: #666666">0.25*</span>omega<span style="color: #666666">*</span>resid;
  dTmax = max(dTmax, <span style="color: #008000">abs</span>(dT));
  T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>) = T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> dT;
  Tmax = max(Tmax, <span style="color: #008000">abs</span>(T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>));
  <span style="color: #008000; font-weight: bold">end</span>
  <span style="color: #008000; font-weight: bold">end</span>
  relres = dTmax<span style="color: #666666">/</span>Tmax;
  <span style="color: #008000; font-weight: bold">end</span>
</pre></div>
<p>
Resultatet blir stort sett det samme for dette tilfellet.

<h3 id="___sec70">Optimal relaksasjonsparameter </h3>

<p>
Med optimal menes her den verdien som gir færrest mulig iterasjoner når \( \omega \)  holdes konstant under hele beregningen. For Laplace- og Poisson-ligninger på rektangulære områder er det mulig å beregne en slik optimal \( \omega \)  som vi vil kalle den teoretisk optimale.

<p>
La \( L_x \) og \( L_y \)  være utstrekningen av rektanglet i henholdsvis \( x \)- og \( y \)-retning.
Med den samme skrittlengden \( h \) i begge retningene, setter vi:\\ \( n_x=\dfrac{L_x}{h},\ n_y=\dfrac{L_y}{h} \)  der \( n_x \) og \( n_y \)  blir antall deler i henholdsvis \( x \)- og \( y \)-retning. \( n_x \) og \( n_y \) skal være heltall. Den teoretisk optimale \( \omega \)  er da gitt ved:

$$
\begin{align}
    &\rho = \frac{1}{2}[\cos(\pi/n_x)+\cos(\pi/n_y)]
\label{_auto63}\\ 
    &\omega = \frac{2}{1+\sqrt{1-\rho^2}}
\label{eq:73114}
\end{align}
$$

<p>
Dersom skrittlengden \( h \) er forskjellig i \( x \)- og \( y \)- retning med \( h=h_x \)  i \( x \)-retning
og \( h=h_y \)  i  \( y \)-retning, får vi isteden for \eqref{eq:73114}:

$$
\begin{equation}
  \rho = \frac{\cos(\pi/n_x)+(h_x/h_y)^2\cdot
    \cos(\pi/n_y)}{1+(h_x/h_y)^2}
\label{eq:73115}
\end{equation}
$$

<p>
Dersom området ikke er rektangulært, kan vi bruke Garabedians estimat:

$$
\begin{equation}
  \omega = \frac{2}{1+3.014\cdot h / \sqrt{A}},\ A\ \text{er arealet
    av området}
\label{eq:73116}
\end{equation}
$$

<p>
La oss regne ut \( \omega \) fra disse formlene for eksemplet der \( L_x=1,\ L_y=1.5 \) og \( A=L_x\cdot L_y=1.5 \).

<p>

<div class="row">
  <div class="col-xs-4">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>   h   </b></td> <td align="center"><b>\eqref{eq:73114}</b></td> <td align="center"><b>\eqref{eq:73116}</b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   0.25       </td> <td align="center">   1.24               </td> <td align="center">   1.24               </td> </tr>
<tr><td align="center">   0.125      </td> <td align="center">   1.51               </td> <td align="center">   1.53               </td> </tr>
<tr><td align="center">   0.0625     </td> <td align="center">   1.72               </td> <td align="center">   1.74               </td> </tr>
<tr><td align="center">   0.03125    </td> <td align="center">   1.85               </td> <td align="center">   1.86               </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-4 -->
<p>
Vi ser at Garabedians estimat stemmer godt overens med de teoretisk eksakte
verdiene i dette tilfellet. Figur <a href="#fig:711">65</a> stemmer også godt overens med verdiene i denne tabellen.

<h3 id="___sec71">Eksempel på bruk av SOR </h3>

<p>
Vi løser nå temperaturproblemet i figur <a href="#fig:76">60</a>  (se  <a href="#kap:722">von Neumann boundary conditions</a>). Nummereringen
blir som vist nedenfor i figur <a href="#fig:712">66</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 66:  Caption goes here. <div id="fig:712"></div> </p></center>
<p><img src="fig-ch7/15.png" align="bottom" width=400></p>
</center>

<p>
Vi bruker også her falske punkt som indikert med de stiplede linjene.
For \( T_{1,1} \)  får vi spesielt:

$$
\begin{equation}
  T_{1,1}=\frac{1}{4}(T_{1,2}+T_{1,2}+T_{2,1}+T_{2,1})=\frac{1}{2}(T_{1,2}+T_{2,1})
\label{eq:73117}
\end{equation}
$$

<p>
Beregningen startes ved iterere langs \( y=0 \)  med start i  \( T_{2,1} \).
Deretter itereres langs \( x=0 \)  med start i \( T_{1,2} \). Etterpå itereres i en
dobbel løkke over de indre punktene. Tilslutt beregnes \( T_{1,1} \)  fra \eqref{eq:73117}.
Beregningen er vist i programmet <b>lapsor2</b> på neste side. Vi
har brukt stoppkriteriet \( \frac{\sum_i\sum_j\left|\delta
    T_{i,j}\right|}{\sum_i\sum_j\left|T_{i,j}\right|} < tol_r \) samt optimal  \( \omega \) fra \eqref{eq:73114} og tipper \( T=0.5 \)  som startverdier for hele feltet unntatt for de gitte randbetingelsene.
Nøyaktigheten er som i utskriften for <b>lap2v3</b> i <a href="#kap:722">von Neumann boundary conditions</a>.

<p>

<!-- code=matlab (!bc mcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">  <span style="color: #408080; font-style: italic">% program lapsor2</span>
  clear
  net = <span style="color: #666666">1</span>;
  h = <span style="color: #666666">0.25</span>;
  hn = h<span style="color: #666666">/2</span>^(net <span style="color: #666666">-1</span>);
  nx = <span style="color: #666666">1/</span>hn; ny = nx;
  imax = nx <span style="color: #666666">+</span> <span style="color: #666666">1</span>; <span style="color: #408080; font-style: italic">% points in x-direction</span>
  jmax = ny <span style="color: #666666">+</span> <span style="color: #666666">1</span>; <span style="color: #408080; font-style: italic">% points in y-direction</span>
  T = <span style="color: #666666">0.5*</span><span style="color: #008000">ones</span>(imax,jmax); <span style="color: #408080; font-style: italic">% temperatures</span>
  <span style="color: #408080; font-style: italic">% --- Compute optimal omega ---</span>
  ro = <span style="color: #008000">cos</span>(<span style="color: #008000">pi</span><span style="color: #666666">/</span>nx);
  omega = <span style="color: #666666">2/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #008000">sqrt</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> ro^<span style="color: #666666">2</span>));
  T(<span style="color: #666666">1</span>:imax,jmax) = <span style="color: #666666">1</span>;  <span style="color: #408080; font-style: italic">% boundary values along y = 1</span>
  T(imax,<span style="color: #666666">1</span>:jmax<span style="color: #666666">-1</span>) = <span style="color: #666666">0</span>;<span style="color: #408080; font-style: italic">% boundary values along x = 1</span>
  reltol = <span style="color: #666666">1.0e-5</span>; <span style="color: #408080; font-style: italic">% relative iteration error</span>
  relres = <span style="color: #666666">1.0</span>; it = <span style="color: #666666">0</span>;
  <span style="color: #408080; font-style: italic">% --- Start iteration ---</span>
  <span style="color: #008000; font-weight: bold">while</span> relres <span style="color: #666666">&gt;</span> reltol
  it = it <span style="color: #666666">+</span> <span style="color: #666666">1</span>;
  Tsum = <span style="color: #666666">0.0</span>; dTsum = <span style="color: #666666">0.0</span>;
  <span style="color: #408080; font-style: italic">% --- boundary values along y = 0 ---</span>
  <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">i</span> = <span style="color: #666666">2</span>: imax <span style="color: #666666">-</span> <span style="color: #666666">1</span>
  resid = <span style="color: #666666">2*</span>T(<span style="color: #008000">i</span>,<span style="color: #666666">2</span>) <span style="color: #666666">+</span> T(<span style="color: #008000">i</span><span style="color: #666666">-1</span>,<span style="color: #666666">1</span>) <span style="color: #666666">+</span> T(<span style="color: #008000">i</span><span style="color: #666666">+1</span>,<span style="color: #666666">1</span>) <span style="color: #666666">-</span> <span style="color: #666666">4*</span>T(<span style="color: #008000">i</span>,<span style="color: #666666">1</span>);
  dT = <span style="color: #666666">0.25*</span>omega<span style="color: #666666">*</span>resid;
  dTsum = dTsum <span style="color: #666666">+</span> <span style="color: #008000">abs</span>(dT);
  T(<span style="color: #008000">i</span>,<span style="color: #666666">1</span>) = T(<span style="color: #008000">i</span>,<span style="color: #666666">1</span>) <span style="color: #666666">+</span> dT;
  Tsum = Tsum <span style="color: #666666">+</span> <span style="color: #008000">abs</span>(T(<span style="color: #008000">i</span>,<span style="color: #666666">1</span>));
  <span style="color: #008000; font-weight: bold">end</span>
  <span style="color: #408080; font-style: italic">% --- boundary values along x = 0 ---</span>
  <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">j</span> = <span style="color: #666666">2</span>: jmax <span style="color: #666666">-</span> <span style="color: #666666">1</span>
  resid = <span style="color: #666666">2*</span>T(<span style="color: #666666">2</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> T(<span style="color: #666666">1</span>,<span style="color: #008000">j</span><span style="color: #666666">-1</span>) <span style="color: #666666">+</span> T(<span style="color: #666666">1</span>,<span style="color: #008000">j</span><span style="color: #666666">+1</span>) <span style="color: #666666">-</span> <span style="color: #666666">4*</span>T(<span style="color: #666666">1</span>,<span style="color: #008000">j</span>);
  dT = <span style="color: #666666">0.25*</span>omega<span style="color: #666666">*</span>resid;
  dTsum = dTsum <span style="color: #666666">+</span> <span style="color: #008000">abs</span>(dT);
  T(<span style="color: #666666">1</span>,<span style="color: #008000">j</span>) = T(<span style="color: #666666">1</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> dT;
  Tsum = Tsum <span style="color: #666666">+</span> <span style="color: #008000">abs</span>(T(<span style="color: #666666">1</span>,<span style="color: #008000">j</span>));
  <span style="color: #008000; font-weight: bold">end</span>
  <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">i</span> = <span style="color: #666666">2</span>: imax<span style="color: #666666">-1</span>
  <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">j</span> = <span style="color: #666666">2</span>: jmax<span style="color: #666666">-1</span>
  resid = T(<span style="color: #008000">i</span><span style="color: #666666">-1</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span><span style="color: #666666">-1</span>) <span style="color: #666666">+</span> T(<span style="color: #008000">i</span><span style="color: #666666">+1</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span><span style="color: #666666">+1</span>)<span style="color: #666666">-4*</span>T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>);
  dT = <span style="color: #666666">0.25*</span>omega<span style="color: #666666">*</span>resid;
  dTsum = dTsum <span style="color: #666666">+</span> <span style="color: #008000">abs</span>(dT);
  T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>) = T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> dT;
  Tsum = Tsum <span style="color: #666666">+</span> <span style="color: #008000">abs</span>(T(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>));
  <span style="color: #008000; font-weight: bold">end</span>
  <span style="color: #008000; font-weight: bold">end</span>
  T(<span style="color: #666666">1</span>,<span style="color: #666666">1</span>) = <span style="color: #666666">0.5*</span>(T(<span style="color: #666666">2</span>,<span style="color: #666666">1</span>) <span style="color: #666666">+</span> T(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>));
  relres = dTsum<span style="color: #666666">/</span>Tsum;
  <span style="color: #008000; font-weight: bold">end</span>
</pre></div>

<h3 id="___sec72">Startverdier og randbetingelser </h3>

<p>
Vi venter å få raskere konvergens dersom vi tipper startverdier som ligger nær den korrekte løsningen. Dette er typisk for ikke-lineære ligninger, mens vi står mer fritt til å tippe startverdier når vi løser lineære ligninger uten at det går utover konvergenshastigheten. For temperaturproblemet i figur <a href="#fig:73">57</a> for eksempel, er det lite forskjell i antall iterasjoner om vi starter iterasjonen med å tippe \( T=0 \)  i hele feltet eller om vi starter med \( T=100 \). Den optimale \( \omega \)  for dette tilfellet er også uavhengig av startverdiene.
Situasjonen er helt forskjellig for tilfellet i figur <a href="#fig:76">60</a>. Vi løser også her en lineær ligning, men har mer kompliserte randbetingelser der vi foreskriver temperaturen langs to render (Dirichlet-betingelser) og den deriverte av temperaturen langs de to andre rendene (Neumann-betingelser) . Dessuten er temperaturen diskontinuerlig i hjørnet  \( x=1,\ y=1 \). I hjørnet \( x=0,\ y=0 \)  er den korrekte løsningen  \( T=0.5 \) fra den analytiske løsningen. Dersom vi tipper \( T=0.5 \) som startverdier i hele feltet, får vi rask  konvergens med optimal \( \omega \) lik den teoretiske fra \eqref{eq:73114}. Dersom vi avviker litt fra \( T=0.5 \)  som startverdi, er ikke lenger den optimale \( \omega \)  lik den teoretisk optimale. Situasjonen blir som vist i figur ref{fig:713} nedenfor.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 67:  Caption goes here. <div id="fig:714"></div> </p></center>
<p><img src="fig-ch7/17.png" align="bottom" width=400></p>
</center>

<p>
Tabellen nedenfor viser  den teoretisk optimale \( \omega \)  etter formel \eqref{eq:73114} og \eqref{eq:73116}

<p>

<div class="row">
  <div class="col-xs-4">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>   h   </b></td> <td align="center"><b>\eqref{eq:73114}</b></td> <td align="center"><b>\eqref{eq:73116}</b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   0.25       </td> <td align="center">   1.17               </td> <td align="center">   1.14               </td> </tr>
<tr><td align="center">   0.125      </td> <td align="center">   1.45               </td> <td align="center">   1.45               </td> </tr>
<tr><td align="center">   0.0625     </td> <td align="center">   1.67               </td> <td align="center">   1.68               </td> </tr>
<tr><td align="center">   0.03125    </td> <td align="center">   1.82               </td> <td align="center">   1.83               </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-4 -->
<p>
Vi ser at tabell-verdiene stemmer godt med verdiene i figur <a href="#fig:714">67</a> når startverdien for iterasjonsprosessen er 0.5.

<h3 id="___sec73">Eksempel på en ikke-lineær ligning </h3>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 68:  Caption goes here. <div id="fig:715"></div> </p></center>
<p><img src="fig-ch7/18.png" align="bottom" width=400></p>
</center>

<p>
  Vi ønsker å løse en ikke-lineær Poisson-ligning på kvadratet i figur <a href="#fig:715">68</a>:

$$
\begin{align}
    \frac{\partial^2u}{\partial x^2}+\frac{\partial^2u}{\partial y^2}+ u^2=-1
\label{_auto64}\\ 
    \text{der } u=u(x,y) \text{ og } u=0 \text{ på rendene.} \nonumber
  \end{align}
$$

<p>
  Denne ligningen er bare svakt ikke-lineær, kalt semi-lineær i, men den illustrerer fremgangsmåten.

<p>
  Vi diskretiserer på vanlig måte med skrittlengde \( h \) i begge retningene:

$$
\begin{align*}
    &\nabla^2u_{i,j}+u^2_{i,j}+1=0\to \\ 
    &\frac{1}{h^2}[u_{i+1,j}+u_{i-1,j}+u_{i,j-1}-4u_{i,j}]+u_{i,j}^2+1=0
  \end{align*}
$$

  eller:

$$
\begin{align}
    f_{i,j}=u_{i+1,j}+u_{i-1,j}+u_{i,j-1}-4u_{i,j}+h^2(u_{i,j}^2+1)=0
\label{eq:73119}
  \end{align}
$$

  Her er \( x_i=h\cdot(i-1),\ i=1,2,\dots \) og $y_j=h\cdot(j-1),\ j=1,2,\dots$\\

<p>
  Nummereringen er vist i figur <a href="#fig:716">69</a> for tilfellet  \( h=0.25 \).

<p>
<!-- original latex figure with scale=0.9 -->

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 69:  Caption goes here. <div id="fig:716"></div> </p></center>
<p><img src="fig-ch7/19.png" align="bottom" width=400></p>
</center>

<p>
Vi løser \eqref{eq:73119} med Newtons metode ved å se på den lokalt som en funksjon der vi forandrer en variabel etter tur.

<p>
  I dette tilfellet blir iterasjonsprosessen:

$$
\begin{align}
    &u_{i,j}^{m+1}=u_{i,j}^{m}+\delta u_{i,j}
\label{_auto65}\\ 
    &\delta u_{i,j}= -\omega \frac{f(u_{k,l})}{\dfrac{\partial
      f(u_{k,l})}{\partial u_{i,j}}} \label{eq:73120a}
  \end{align}
$$

  Her blir:

$$
\begin{align}
    &u_{k,l}=u_{k,l}^{m+1} \text{ for } k < i,\ l < j
\label{_auto66}\\ 
    &u_{k,l}=u_{k,l}^m \text{ ellers} \label{eq:73120b}
  \end{align}
$$


$$
\begin{align}
    \frac{\partial f}{\partial u_{i,j}}=-4+2h^2\cdot u_{i,j} \text{ og
    } \delta u_{i,j}=\omega \frac{f}{4-2h^2u_{i,j}}
\label{eq:73120c}
  \end{align}
$$

  Programmet <b>npoisor</b> på neste side bruker \eqref{eq:73119} og
  \eqref{eq:73120a} --\eqref{eq:73120c}

<p>

<!-- code=matlab (!bc mcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #408080; font-style: italic">% program npoisor</span>
    <span style="color: #408080; font-style: italic">% We may select different nets</span>
    <span style="color: #408080; font-style: italic">% by specifying the parameter net.</span>
    <span style="color: #408080; font-style: italic">%</span>
    <span style="color: #408080; font-style: italic">% net = 1 -&gt; h = 0.25, net = 2 -&gt; h = 0.25/2</span>
    <span style="color: #408080; font-style: italic">% giving hn = h/2^(net -1)</span>
    clear
    net = <span style="color: #666666">2</span>;
    h = <span style="color: #666666">0.25</span>;
    hn = h<span style="color: #666666">/2</span>^(net <span style="color: #666666">-1</span>);
    nx = <span style="color: #666666">1/</span>hn; ny = nx;
    hn2 = hn<span style="color: #666666">*</span>hn;
    imax = nx <span style="color: #666666">+</span> <span style="color: #666666">1</span>; <span style="color: #408080; font-style: italic">% points in x-direction</span>
    jmax = ny <span style="color: #666666">+</span> <span style="color: #666666">1</span>; <span style="color: #408080; font-style: italic">% points in y-direction</span>
    <span style="color: #408080; font-style: italic">% --- Initial values including the boundaries ---</span>
    u = <span style="color: #008000">zeros</span>(imax,jmax);
    <span style="color: #408080; font-style: italic">%</span>
    <span style="color: #408080; font-style: italic">% --- Compute optimal omega ---</span>
    ro = <span style="color: #008000">cos</span>(<span style="color: #008000">pi</span><span style="color: #666666">/</span>nx);
    omega = <span style="color: #666666">2/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #008000">sqrt</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> ro^<span style="color: #666666">2</span>));
    reltol = <span style="color: #666666">1.0e-5</span>; <span style="color: #408080; font-style: italic">% relative iteration error</span>
    relres = <span style="color: #666666">1.0</span>; it = <span style="color: #666666">0</span>;
    <span style="color: #408080; font-style: italic">% --- Start iteration ---</span>
    <span style="color: #008000; font-weight: bold">while</span> relres <span style="color: #666666">&gt;</span> reltol
    it = it <span style="color: #666666">+</span> <span style="color: #666666">1</span>;
    usum = <span style="color: #666666">0.0</span>; dusum = <span style="color: #666666">0.0</span>;
    <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">i</span> = <span style="color: #666666">2</span>: imax<span style="color: #666666">-1</span>
    <span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">j</span> = <span style="color: #666666">2</span>: jmax<span style="color: #666666">-1</span>
    fac1 = <span style="color: #666666">4</span> <span style="color: #666666">-</span> <span style="color: #666666">2*</span>hn2<span style="color: #666666">*</span>u(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>) ;
    fac2 = hn2<span style="color: #666666">*</span>(u(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>)^<span style="color: #666666">2</span> <span style="color: #666666">+</span> <span style="color: #666666">1</span>);
    resid = u(<span style="color: #008000">i</span><span style="color: #666666">-1</span>,<span style="color: #008000">j</span>)<span style="color: #666666">+</span>u(<span style="color: #008000">i</span>,<span style="color: #008000">j</span><span style="color: #666666">-1</span>)<span style="color: #666666">+</span>u(<span style="color: #008000">i</span><span style="color: #666666">+1</span>,<span style="color: #008000">j</span>)<span style="color: #666666">+</span>u(<span style="color: #008000">i</span>,<span style="color: #008000">j</span><span style="color: #666666">+1</span>)<span style="color: #666666">-</span>
    <span style="color: #666666">4*</span>u(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>)<span style="color: #666666">+</span>fac2
    du = omega<span style="color: #666666">*</span>resid<span style="color: #666666">/</span>fac1;
    dusum = dusum <span style="color: #666666">+</span> <span style="color: #008000">abs</span>(du);
    u(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>) = u(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>) <span style="color: #666666">+</span> du;
    usum = usum <span style="color: #666666">+</span> <span style="color: #008000">abs</span>(u(<span style="color: #008000">i</span>,<span style="color: #008000">j</span>));
    <span style="color: #008000; font-weight: bold">end</span>
    <span style="color: #008000; font-weight: bold">end</span>
    relres = dusum<span style="color: #666666">/</span>usum;
    <span style="color: #008000; font-weight: bold">end</span>
    u
</pre></div>
<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u =
 0         0         0         0         0         0         0         0         0
 0    0.0178    0.0278    0.0330    0.0346    0.0330    0.0278    0.0178         0
 0    0.0278    0.0448    0.0539    0.0568    0.0539    0.0448    0.0278         0
 0    0.0330    0.0539    0.0654    0.0691    0.0654    0.0539    0.0330         0
 0    0.0346    0.0568    0.0691    0.0730    0.0691    0.0568    0.0346         0
 0    0.0330    0.0539    0.0654    0.0691    0.0654    0.0539    0.0330         0
 0    0.0278    0.0448    0.0539    0.0568    0.0539    0.0448    0.0278         0
 0    0.0178    0.0278    0.0330    0.0346    0.0330    0.0278    0.0178         0
 0         0         0         0         0         0         0         0         0
</pre></div>
<p>
Utskriften ovenfor er for \( h=0.125 \) og vi har brukt stoppkriteriet
\( \frac{\sum_i\sum_j\left|\delta
    TT_{i,j}\right|}{\sum_i\sum_j\left|T_{i,j}\right|} < tol_r \)
med \( tol_r=10^{-5} \). Startverdien \( u=0 \) for hele feltet er naturlig
i dette tilfellet.  Vi har brukt \eqref{eq:73114} til å beregne den
optimale \( \omega \). Tabellen nedenfor viser også den virkelig
optimale \( \omega \) for starverdien \( u=0 \).

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( h \)</td> <td align="center"><b>\eqref{eq:73114}</b></td> <td align="center"><b>Virkelig</b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   0.25       </td> <td align="center">   1.17               </td> <td align="center">   1.19        </td> </tr>
<tr><td align="center">   0.125      </td> <td align="center">   1.45               </td> <td align="center">   1.46        </td> </tr>
<tr><td align="center">   0.0625     </td> <td align="center">   1.67               </td> <td align="center">   1.69        </td> </tr>
<tr><td align="center">   0.03125    </td> <td align="center">   1.82               </td> <td align="center">   1.83        </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-3 -->
<p>
I dette tilfellet får vi god overenstemmelse selv om ligningen er svakt ikke-lineær.

<h2 id="___sec74">KONVERGENSKRITERIER </h2>

<p>
<div id="kap:732"></div>

<p>
Vi går tilbake til et lineært ligningsystem \( \mathbf{Ax=b} \) som for et tilfelle med 4 ukjente blir:

$$
\begin{align*}
  &a_{11}x_1+a_{12}x_2+a_{13}x_3+a_{14}x_4=b_1\\ 
  &a_{21}x_1+a_{22}x_2+a_{23}x_3+a_{24}x_4=b_2\\ 
  &a_{31}x_1+a_{32}x_2+a_{33}x_3+a_{34}x_4=b_3\\ 
  &a_{41}x_1+a_{42}x_2+a_{43}x_3+a_{44}x_4=b_4
\end{align*}
$$

Innfører følgende matriser:
$$
\begin{equation}
  \mathbf{D=}
  \left(\begin{array}{cccc}
    a_{11}&	0&	0&	0 \\ 
    0&	a_{22}&	0&	0 \\ 
    0&	0&	a_{33}&	0 \\ 
    0&	0&	0&	a_{44}
  \end{array}\right)
  ,\mathbf{ -L=}
  \left(\begin{array}{cccc}
    0&	0&	0&	0 \\ 
    a_{21}&	0&	0&	0 \\ 
    a_{31}&a_{32}&	0&	0 \\ 
    a_{41}&a_{42}&a_{43}&	0
  \end{array}\right)
  \mathbf{ -U=}
  \left(\begin{array}{cccc}
    0&	a_{12}&	a_{13}&	a_{14} \\ 
    0&	0&	a_{23}&	a_{24} \\ 
    0&	0&	0&	a_{34} \\ 
    0&	0&	0&	0
  \end{array}\right)
\label{eq:73221}
\end{equation}
$$

<p>
<b>D</b> er en diagonalmatrise og <b>L</b> og <b>U</b> er henholdsvis en nedre og en øvre trekantmatrise. Koeffisientmatrisa <b>A</b> kan da skrives: \( \mathbf{A=D-L-U} \) slik at  ligningsystemet blir:

$$
\begin{equation}
  \mathbf{Dx=(L+U)x+b}
\label{eq:73222}
\end{equation}
$$

Med bruk av notasjonen i \eqref{eq:73222}, kan Jacobis iterasjonsmetode i \eqref{eq:7313} skrives:

$$
\begin{align*}
  \mathbf{Dx^{m+1}=(L+U)x^m+b}
\end{align*}
$$

som gir:

$$
\begin{align}
  \mathbf{x^{m+1}=D^{-1}(L+U)x^m+D^{-1}b}
\label{eq:73223}
\end{align}
$$

Setter:

$$
\begin{align} \label{eq:73224}
  \mathbf{G_J=D^{-1}(L+U)}
\end{align}
$$

<p>
\( \mathbf{G_J} \)  kalles iterasjonsmatrisa for Jacobis metode.
Når ligningene er skrevet på matriseform, gjelder de selvfølgelig for et
vilkårlig antall ukjente.

<p>
Tilsvarende for Gauss-Seidels metode i \eqref{eq:7315}:

$$
\begin{align*}
  \mathbf{Dx^{m+1}=Lx^{m+1}+Ux^m+b}
\end{align*}
$$

som gir:

$$
\begin{align}
  \mathbf{x^{m+1}=(D-L)^{-1}Ux^m+(D-L)^{-1}b}
\label{eq:73225}
\end{align}
$$

Setter:

$$
\begin{align}
  \mathbf{G_{GS}=(D-L)^{-1}U}
\label{eq:73226}
\end{align}
$$

<p>
\( \mathbf{G_{GS}} \)  kalles iterasjonsmatrisa for Gauss-Seidels metode.

<p>
For SOR- metoden  i  \eqref{eq:7316b}:

$$
\begin{align*}
  (\mathbf{I}-\omega\mathbf{D}^{-1}\mathbf{L})\mathbf{x}^{m+1}=[(1-\omega)\mathbf{I}+\omega\mathbf{D}^{-1}\mathbf{U}]\mathbf{x}^m+\omega\mathbf{D}^{-1}\mathbf{b}
\end{align*}
$$

som gir:

$$
\begin{align}
  \mathbf{x}^{m+1}=(\mathbf{I}-\omega\mathbf{D}^{-1}\mathbf{L})^{-1}[(1-\omega)\mathbf{I}+\omega\mathbf{D}^{-1}\mathbf{U}]\mathbf{x}^m+(\mathbf{I}-\omega\mathbf{D}^{-1}\mathbf{L})^{-1}\omega\mathbf{D}^{-1}\mathbf{b}
\label{eq:73227}
\end{align}
$$

Setter

$$
\begin{align}
  \mathbf{G}_{SOR} =
  (\mathbf{I}-\omega\mathbf{D}^{-1}\mathbf{L})^{-1}[(1-\omega)\mathbf{I}+\omega\mathbf{D}^{-1}\mathbf{U}]
\label{eq:73228}
\end{align}
$$

<p>
\( \mathbf{G}_{SOR} \)   kalles iterasjonsmatrisa for SOR-metoden.
Gauss-Seidel fås som et spesialtilfelle ved å sette  \( \omega = 1 \).

<p>
Vi har delvis fulgt fremstillingen som er gitt i Smith <a href="#14">[12]</a>, side 266.

<p>
Vi ser at alle tre metodene kan skrives:

$$
\begin{align}
  &\mathbf{x}^{m+1}=\mathbf{Gx}^m+\mathbf{c}
\label{_auto67}\\ 
  &\mathbf{G} \text{ står her for } \mathbf{G}_J,\ \mathbf{G}_{GS}
    \text{ og } \mathbf{G}_{SOR}
\label{eq:73229}
\end{align}
$$

Ved konvergens blir \( \mathbf{x}^{m+1}=\mathbf{x}^m=\mathbf{x} \)  slik at det eksakte systemet kan skrives:

$$
\begin{equation}
  \mathbf{x}=\mathbf{Gx+c}
\label{eq:73230}
\end{equation}
$$

Vi kaller feil-vektoren i den \( m \)'te iterasjonen for \( \mathbf{e}^m \)  slik at

$$
\begin{equation}
  \mathbf{e}^m=\mathbf{x}-\mathbf{x}^m
\label{eq:73231}
\end{equation}
$$

Ved å trekke \eqref{eq:73229} fra \eqref{eq:73230} får vi:

$$
\begin{equation}
  \mathbf{e}^{m+1}=\mathbf{Ge}^m
\label{eq:73232}
\end{equation}
$$

Derav følger:

$$
\begin{equation}
  \mathbf{e}^m=\mathbf{Ge}^{m-1}=\mathbf{G}^2\mathbf{e}^{m-2}=\mathbf{G}^3\mathbf{e}^{m-3}=\dots=\mathbf{G}^m\mathbf{e}^{0}
\label{eq:73233}
\end{equation}
$$

der \( \mathbf{e}^m \)  er feilvektoren i den første iterasjonen, altså forskjellen mellom startverdiene og de rette verdiene.

<p>
Dersom prosessen i \eqref{eq:73232} og \eqref{eq:73233} skal konvergere for vilkårlige startverdier \( \mathbf{x^0} \),
må  følgende betingelse være oppfylt:

$$
\begin{equation}
  \lim_{m\to \infty} \mathbf{G}^m=0
\label{eq:73234}
\end{equation}
$$

En nødvendig og tilstrekkelig betingelse for å oppfylle  \eqref{eq:73234}, er at
tallverdien for den største egenverdien i  \( \mathbf{G} \) er mindre enn 1.

<p>
Dette skrives:

$$
\begin{equation}
  \rho= |\lambda_{max}| < 1
\label{_auto68}
\end{equation}
$$

<p>
Absoluttverdien av den største egenverdien av en matrise <b>A</b> kalles
spektralradien og betegnes ofte med \( \rho \). Skrives gjerne \( \rho(\mathbf{A}) \)  når det er nødvendig å henvise til den underliggende matrisa. (Se ref{app:15}).

<p>
I Smith <a href="#14">[12]</a> er både nødvendigheten og tilstrekkeligheten vist under forutsetningen av at alle egenvektorene av <b>G</b> er uavhengige.
Et generelt bevis er mer kronglete og kan finnes i mer avansert litteratur,
f.eks Hageman \&Young <a href="#23">[13]</a>.

<p>
Følger derfor Smith og antar at iterasjonsmatrisa <b>G</b> har dimensjon \( n\times n \) og har \( n \) uavhengige egenvektorer \( \mathbf{v}_k,\ k=1,2,\dots,n \).

<p>
Feilvektoren \( \mathbf{e}^0 \)  i den første iterasjonen kan da utrykkes i egenvektor-rommet ved:

$$
\begin{align*}
  &\mathbf{e}^0=c_1\mathbf{v}_1+c_2\mathbf{v}_2+\dots+c_n\mathbf{v}_n=\sum^n_{k=1}c_k\mathbf{v}_k\\ 
  &\text{der } c_k,\ k=1,2,\dots,n \text{ er skalarer}
\end{align*}
$$

Nå får vi:

$$
\begin{equation}
  \mathbf{e}^1=\mathbf{Ge}^0=c_1\mathbf{Gv}_1+c_2\mathbf{Gv}_2+\dots+c_n\mathbf{Gv}_n=\sum^n_{k=1}c_k\mathbf{Gv}_k \label{eq:73236}
\end{equation}
$$

La \( \lambda_k \)  være den \( k \)'te egenverdien slik at med \( \mathbf{v}_k \)  som den \( k \)'te egenvektoren,
får vi \( \mathbf{Gv}_k=\lambda_k\mathbf{v}_k \)  som innsatt i \eqref{eq:73236} gir:

$$
\begin{equation*}
  \mathbf{e}^1=\sum^n_{k=1}c_k\lambda_k\mathbf{v}_k
\end{equation*}
$$

Dette er for den første iterasjonen.
For den \( m \)'te iterasjonen:

$$
\begin{equation}
  \mathbf{e}^m=\sum^n_{k=1}c_k(\lambda_k)^m\mathbf{v}_k
\label{eq:73237}
\end{equation}
$$

\eqref{eq:73237} gir da følgende:

<p>
<em>Nødvendig betingelse: </em>
Dersom $ \lim^{}_{ m\to 0} \mathbf{e}^m=0$  skal gjelde for vilkårlige
startvektorer \( \mathbf{x}^0 \)  og da også for vilkårlige feilvektorer
\( \mathbf{e}^0 \), må \( |\lambda_k| < 1,\ k=1,2,\dots,n \).

<p>
<em>Tilstrekkelig betingelse: </em>
Dersom  \( |\lambda_k| < 1,\ k=1,2,\dots,n \), følger umiddelbart at \( \mathbf{e}^m\to 0 \)  for en vilkårlig  \( \mathbf{e}^0 \).

<p>
Dette betyr at at de klassiske iterasjonsmetodene konvergerer hvis og bare hvis  spektralradien for iterasjonsmatrisa er mindre enn 1.

<p>
Vi kan også bruke \eqref{eq:73237} til å si noe om
konvergenshastigheten.  Til det trenger vi vektor- og
matrisenormer. Henviser her til ref{app:15}.  La oss se på et
egenverdiproblem \( \mathbf{Ax}=\lambda\mathbf{x},\ \mathbf{x}\neq 0 \),
. Med bruk av lign. \eqref{a1:58}

$$
\begin{align*}
  &||\mathbf{Ax}||=||\lambda \mathbf{x}||=|\lambda|||\mathbf{x}||\\ 
  &||\mathbf{Ax}||\leq ||\mathbf{A}||\cdot ||\mathbf{x}||
\end{align*}
$$

som gir:

$$
\begin{align*}
  |\lambda|\cdot ||\mathbf{x}||\leq ||\mathbf{A}||\cdot ||\mathbf{x}||
\end{align*}
$$

eller:

$$
\begin{align}
  |\lambda|\leq ||\mathbf{A}||
\label{eq:73238}
\end{align}
$$

Merk at  \( \lambda \) står for alle egenverdiene slik at spesielt \( \rho(\mathbf{A})\leq || \mathbf{A}|| \) \\ 
Fra \eqref{eq:73232}:

$$
\begin{equation*}
  \mathbf{e}^{m+1}=\mathbf{Ge}^m\to ||\mathbf{e}^{m+1}||=||\mathbf{G}||\cdot ||\mathbf{e}^m||
\end{equation*}
$$

Anta nå at  etter at vi har utført \( m \) iterasjoner, gjør \( k \) ekstra:

$$
\begin{equation}
  ||\mathbf{e}^{m+k}||=||\mathbf{G}^k||\cdot ||\mathbf{e}^m||
\label{eq:73239}
\end{equation}
$$

<p>
Sorterer  egenverdiene etter størrelse:
\( |\lambda_1|>|\lambda_2|\geq|\lambda_3|\geq\dots\geq|\lambda_n| \).

<p>
Her er \( \lambda_1=\lambda_{max} \) og \( \rho= |\lambda_{max}| \). Merk at
vi har antatt at \( \lambda_1 \) og \( \lambda_2 \)  ikke faller sammen. Fra \eqref{eq:73237}:

$$
\begin{align*}
  \mathbf{e}^m=&c_1\lambda_1^m\mathbf{v}_1+c_2\lambda_2^m\mathbf{v}_2+\dots+c_n\lambda_n^m\mathbf{v}_n\to ||\mathbf{e}^m||\leq||c_1\lambda_1^m\mathbf{v}_1||+||c_2\lambda_2^m\mathbf{v}_2||\\+&\dots+||c_n\lambda_n^m\mathbf{v}_n||\\ 
  =&|\lambda^m_1|\cdot\left[||c_1\mathbf{v}_1||+	\bigg|\frac{\lambda_2}{\lambda_1}\bigg|^m||c_2\mathbf{v}_2||+\dots+\bigg|\frac{\lambda_n}{\lambda_1}\bigg|^m||c_n\mathbf{v}_n||		\right]
\end{align*}
$$

For tilstrekkelig store verdier av \( m \):

$$
\begin{equation}
  ||\mathbf{e}^m||\approx
  |\lambda_1|^m||c_1\mathbf{v}_1||=\rho^m||c_1\mathbf{v}_1||
\label{eq:73240}
\end{equation}
$$

Fra \eqref{eq:73238}, \eqref{eq:73239} og \eqref{eq:73240} følger:

$$
\begin{equation}
  ||\mathbf{e}^{m+k}||\approx \rho^k||\mathbf{e}^m||\to
  \frac{||\mathbf{e}^{m+k}||}{||\mathbf{e}^m||}\approx \rho^k
\label{eq:73241}
\end{equation}
$$

Vi ønsker spesielt å finne for hvilken verdi av \( k \) er \( ||\mathbf{e}^{m+k}|| \)  en
tiendepart av  \( ||\mathbf{e}^m|| \):

$$
\begin{equation}
  \frac{||\mathbf{e}^{m+k}||}{||\mathbf{e}^m||}=\dfrac{1}{10}\approx
  \rho^k
\label{eq:73242}
\end{equation}
$$

Ved bruk av den Briggske logaritmen i  \eqref{eq:73242}:

$$
\begin{equation}
  k\approx -\frac{1}{\log_{10}(\rho)}
\label{eq:73243}
\end{equation}
$$

\( k \) angir hvor mange iterasjoner vi må utføre for å vinne ett desimalsiffer.
Størrelsen

$$
\begin{equation}
  R=-\log_{10}(\rho)
\label{eq:73244}
\end{equation}
$$

kalles ofte det midlere konvergenstallet.
Istedenfor den Briggske logaritmen brukes gjerne den naturlige.

<p>
Ved bruk av matrisenormer kan vi finne tilstrekkelige betingelser for konvergens.
La oss f. eks. velge Jacobis metode, lign.\eqref{eq:73222} med iterasjonsmatrisa gitt i \eqref{eq:73224}:

$$
\begin{align*}
  \mathbf{G}_J=\mathbf{D}^{-1}(\mathbf{L+U})
\end{align*}
$$

For systemet i \eqref{eq:73221}:
$$
\begin{align*}
    \mathbf{G}_J=&-
    \left(\begin{array}{cccc}
      \frac{1}{a_{11}}	&	0			&	0			&	0			\\ 
      0			&	\frac{1}{a_{2}}	&	0			&	0			\\ 
      0			&	0			&	\frac{1}{a_{3}}	&	0			\\ 
      0			&	0			&	0			&	\frac{1}{a_{44}}	\\ 
    \end{array}\right)\cdot
    \left(\begin{array}{cccc}
      0				&	a_{12}			&	a_{13}			&	a_{14}			\\ 
      a_{21}			&	0				&	a_{23}			&	a_{24}			\\ 
      a_{31}			&	a_{32}			&	0				&	a_{34}			\\ 
      a_{41}			&	a_{42}			&	a_{43}			&	0				\\ 
    \end{array}\right)\\ 
    =&-
    \left(\begin{array}{cccc}
      0				&	\frac{a_{12}}{a_{11}}	&	\frac{a_{13}}{a_{11}}	&	\frac{a_{14}}{a_{11}}	\\ 
      \frac{a_{21}}{a_{22}}	&	0				&	\frac{a_{23}}{a_{22}}	&	\frac{a_{24}}{a_{22}}	\\ 
      \frac{a_{31}}{a_{33}}	&	\frac{a_{32}}{a_{33}}	&	0				&	\frac{a_{34}}{a_{33}}	\\ 
      \frac{a_{41}}{a_{44}}	&	\frac{a_{42}}{a_{44}}	&	\frac{a_{43}}{a_{44}}	&	0				\\ 
    \end{array}\right)
\label{eq:73245}
\end{align*}
$$

<p>
En matrise <b>A</b> kalles strengt diagonaldominant dersom:

$$
\begin{equation}
  |a_{i,j}|>\sum^n_{j=1,\ j\neq i} |a_{i,j}| \text{ for alle } 1\leq i
  \leq n
\label{eq:73246}
\end{equation}
$$

<p>
Anta nå at <b>A</b> er strengt diagonaldominant. Da blir tallverdien av alle leddene i \( \mathbf{G}_j \) mindre enn 1. Bruker matrisenormen \( ||\mathbf{A}||_\infty \)  samt \eqref{eq:73238}:

$$
\begin{align*}
  |\lambda| < ||\mathbf{G}_J||_\infty = \max_{1\leq i \leq n}
  \sum^n_{j=1} |\mathbf{G}_{i,j}| < 1
\end{align*}
$$

<p>
Med andre ord: Dersom iterasjonsmatrisa er strengt diagonaldominant, konvergerer Jacobis metode uavhengig av startvektoren. Det kan vises at dette også gjelder både Gauss-Seidel og SOR også.

<h3 id="___sec75">Eksempel ved bruk av Gauss-Seidels metode </h3>

<p>
  La oss løse følgende system \( \mathbf{Ax=b} \)  med fire ukjente der vi bruker  Gauss-Seidels metode:

$$
\begin{align*}
    \left(\begin{array}{cccc}
      2	&	-1	&	0	&	0	\\ 
      -1	&	3	&	-1	&	0	\\ 
      0	&	-1	&	3	&	-1	\\ 
      0	&	0	&	-1	&	2	\\ 
    \end{array}\right)\cdot
    \left(\begin{array}{c}
      x_1\\ 
      x_2\\ 
      x_3\\ 
      x_4
    \end{array}\right)=
    \left(\begin{array}{c}
      -1\\ 
      4\\ 
      7\\ 
      0
    \end{array}\right)
  \end{align*}
$$

<p>
Dette systemet har løsningen  \( x_1=1,\ x_2=3,\ x_3=4,\ x_4=2 \). I praksis ville vi selvfølgelig ikke bruke Gauss-Seidels metode på et slik system, men systemet er så enkelt at det er mulig å analysere det.
  Lign. \eqref{eq:73221} blir i dette tilfellet:
  \footnotesize

$$
\begin{equation*}
    \mathbf{D=}
    \left(\begin{array}{cccc}
      2&	0&	0&	0 \\ 
      0&	3&	0&	0 \\ 
      0&	0&	3&	0 \\ 
      0&	0&	0&	2
    \end{array}\right)
    ,\mathbf{ -U=}
    \left(\begin{array}{cccc}
      0&	-1&	0&	0 \\ 
      0&	0&	-1&	0 \\ 
      0&	0&	0&	-1 \\ 
      0&	0&	0&	0
    \end{array}\right)
    \mathbf{ -L=}
    \left(\begin{array}{cccc}
      0&	0&	0&	0 \\ 
      -1&	0&	0&	0 \\ 
      0&	-1&	0&	0 \\ 
      0&	0&	-1&	0
    \end{array}\right)
  \end{equation*}
$$

<p>
Videre får vi:
  \footnotesize

$$
\begin{equation*}
    \mathbf{D-L}=
    \left(\begin{array}{cccc}
      2&	0&	0&	0 \\ 
      -1&	3&	0&	0 \\ 
      0&	-1&	3&	0 \\ 
      0&	0&	-1&	2
    \end{array}\right)
    ,\ 
    (\mathbf{D-L})^{-1}=
    \left(\begin{array}{cccc}
      \frac{1}{2}&	0&	0&	0 \\ 
      \frac{1}{6}&\frac{1}{3}&	0&	0 \\ 
      \frac{1}{18}&\frac{1}{9}&\frac{1}{3}&	0 \\ 
      \frac{1}{36}&\frac{1}{18}&\frac{1}{6}&\frac{1}{2}
    \end{array}\right)
  \end{equation*}
$$

<p>
Iterasjonsmatrisa \( \mathbf{G}_{GS} \)  i \eqref{eq:73226} blir nå:

$$
\begin{equation*}
    \mathbf{G_{GS}}=\mathbf{(D-L)^{-1}U} =
    \left(\begin{array}{cccc}
      0 &	\frac{1}{2}	&	0		&	0		\\ 
      0&	\frac{1}{6}	&	\frac{1}{3}	&	0		\\ 
      0&	\frac{1}{18}	& 	\frac{1}{9}	& 	\frac{1}{3}	\\ 
      0& 	\frac{1}{36}	& 	\frac{1}{18}	& 	\frac{1}{6}	\\ 
    \end{array}\right)
  \end{equation*}
$$

  Beregner egenverdiene av iterasjonsmatrisa:

$$
\begin{equation*}
    \det (\mathbf{G_{GS}-\lambda I}) = \det
    \left(\begin{array}{cccc}
      -\lambda &	\frac{1}{2}		&	0		&	0		\\ 
      0	&	\frac{1}{6}-\lambda&	\frac{1}{3}	&	0		\\ 
      0	&	\frac{1}{18}		&	\frac{1}{9}-\lambda&	\frac{1}{3}\\ 
      0	&	\frac{1}{36}	&	\frac{1}{18}	&	\frac{1}{6}-\lambda\\ 
    \end{array}\right) = 0
  \end{equation*}
$$

<p>
Vi får en enkel 4. grads ligning: \( \lambda^2(\lambda^2 -\frac{4}{9}\lambda+\frac{1}{36})=0 \) med løsning:

$$
\begin{equation*}
    \rho = \lambda_1=0.3692,\ \lambda_2=0.0752,\ \lambda_3=\lambda_4 = 0
  \end{equation*}
$$

Vi kan selvfølgelig bruke Matlab direkte til å finne egenverdiene:

<p>

<!-- code=matlab (!bc mcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #666666">&gt;</span> Ggs = [<span style="color: #666666">0</span> <span style="color: #666666">1/2</span> <span style="color: #666666">0</span> <span style="color: #666666">0</span>; <span style="color: #666666">0</span> <span style="color: #666666">1/6</span> <span style="color: #666666">1/3</span> <span style="color: #666666">0</span>; <span style="color: #666666">0</span> <span style="color: #666666">1/18</span> <span style="color: #666666">1/9</span> <span style="color: #666666">1/3</span>; <span style="color: #666666">0</span> <span style="color: #666666">1/36</span> <span style="color: #666666">1/18</span> <span style="color: #666666">1/6</span>];
    <span style="color: #666666">&gt;&gt;</span> eig(Ggs)
    <span style="color: #008000">ans</span> = <span style="color: #666666">0</span> <span style="color: #666666">0.0752</span>  <span style="color: #666666">0.3692</span> <span style="color: #666666">0.0000</span>
    <span style="color: #666666">&gt;&gt;</span>
</pre></div>
<p>
Da tallverdien for alle egenverdiene er mindre enn 1, følger at
Gauss-Seidels metode konvergerer for dette tilfellet. (Systemet er
strengt diagonaldominant).  Konvergenstallet \( -\log_{10}(\rho) \) fra
\eqref{eq:73244} blir \( -\log_{10}(0.3692)=0.4327 \) slik at
\( k\approx2.3 \) som betyr at vi må utføre litt mer enn to iterasjoner
for hvert desimalsiffer vi ønsker.

<p>
Gauss-Seidel systemet i \eqref{eq:73225} blir i vårt tilfelle:

$$
\begin{equation*}
    \left(\begin{array}{c}
      x_1\\ 
      x_2\\ 
      x_3\\ 
      x_4\\ 
    \end{array}\right)^{m+1} =
    \left(\begin{array}{cccc}
      0 &	\frac{1}{2}	&	0		&	0		\\ 
      0&	\frac{1}{6}	&	\frac{1}{3}	&	0		\\ 
      0&	\frac{1}{18}	& 	\frac{1}{9}	& 	\frac{1}{3}	\\ 
      0& 	\frac{1}{36}	& 	\frac{1}{18}	& 	\frac{1}{6}	\\ 
    \end{array}\right) \cdot
    \left(\begin{array}{c}
      x_1\\ 
      x_2\\ 
      x_3\\ 
      x_4\\ 
    \end{array}\right)^{m} +
    \left(\begin{array}{c}
      -\frac{1}{2}\\ 
      \frac{7}{6}\\ 
      \frac{49}{18}\\ 
      \frac{49}{36}\\ 
    \end{array}\right),\ m=0,1,\dots
  \end{equation*}
$$

  Vi skriver et lite Matlabprogram som utfører iterasjonsprosessen:

<p>

<!-- code=matlab (!bc mcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #408080; font-style: italic">% Program GStest</span>
    Ggs = [<span style="color: #666666">0</span> <span style="color: #666666">1/2</span> <span style="color: #666666">0</span> <span style="color: #666666">0</span>; <span style="color: #666666">0</span> <span style="color: #666666">1/6</span> <span style="color: #666666">1/3</span> <span style="color: #666666">0</span>; <span style="color: #666666">0</span> <span style="color: #666666">1/18</span> <span style="color: #666666">1/9</span> <span style="color: #666666">1/3</span> ; <span style="color: #666666">0</span> <span style="color: #666666">1/36</span> <span style="color: #666666">1/18</span> <span style="color: #666666">1/6</span>];
    c = [ <span style="color: #666666">-1/2</span>; <span style="color: #666666">7/6</span> ; <span style="color: #666666">49/18</span>; <span style="color: #666666">49/36</span> ];
    x = <span style="color: #008000">zeros</span>(<span style="color: #666666">4</span>,<span style="color: #666666">1</span>); <span style="color: #408080; font-style: italic">% Startverdier</span>
    <span style="color: #008000; font-weight: bold">for</span> k = <span style="color: #666666">1</span>:<span style="color: #666666">12</span>
    x = Ggs<span style="color: #666666">*</span>x <span style="color: #666666">+</span> c;
    fprintf(<span style="color: #BA2121">&#39; $%6.4f %6.4f  %6.4f  %6.4f \n&#39;</span>,x<span style="color: #666666">&#39;</span>)
    <span style="color: #008000; font-weight: bold">end</span>
</pre></div>
<p>

<!-- code=matlab (!bc mcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #666666">&gt;&gt;</span> GStest
    <span style="color: #666666">-0.5000</span> <span style="color: #666666">1.1667</span>  <span style="color: #666666">2.7222</span>  <span style="color: #666666">1.3611</span>
    <span style="color: #666666">0.0833</span> <span style="color: #666666">2.2685</span>  <span style="color: #666666">3.5432</span>  <span style="color: #666666">1.7716</span>
    <span style="color: #666666">0.6343</span> <span style="color: #666666">2.7258</span>  <span style="color: #666666">3.8325</span>  <span style="color: #666666">1.9162</span>
    <span style="color: #666666">0.8629</span> <span style="color: #666666">2.8985</span>  <span style="color: #666666">3.9382</span>  <span style="color: #666666">1.9691</span>
    <span style="color: #666666">0.9492</span> <span style="color: #666666">2.9625</span>  <span style="color: #666666">3.9772</span>  <span style="color: #666666">1.9886</span>
    <span style="color: #666666">0.9812</span> <span style="color: #666666">2.9861</span>  <span style="color: #666666">3.9916</span>  <span style="color: #666666">1.9958</span>
    <span style="color: #666666">0.9931</span> <span style="color: #666666">2.9949</span>  <span style="color: #666666">3.9969</span>  <span style="color: #666666">1.9984</span>
    <span style="color: #666666">0.9974</span> <span style="color: #666666">2.9981</span>  <span style="color: #666666">3.9989</span>  <span style="color: #666666">1.9994</span>
    <span style="color: #666666">0.9991</span> <span style="color: #666666">2.9993</span>  <span style="color: #666666">3.9996</span>  <span style="color: #666666">1.9998</span>
    <span style="color: #666666">0.9997</span> <span style="color: #666666">2.9997</span>  <span style="color: #666666">3.9998</span>  <span style="color: #666666">1.9999</span>
    <span style="color: #666666">0.9999</span> <span style="color: #666666">2.9999</span>  <span style="color: #666666">3.9999</span>  <span style="color: #666666">2.0000</span>
    <span style="color: #666666">1.0000</span> <span style="color: #666666">3.0000</span>  <span style="color: #666666">4.0000</span>  <span style="color: #666666">2.0000</span>
    <span style="color: #666666">&gt;&gt;</span>
</pre></div>
<p>
  Vi ser at i dette tilfellet konvergerer Gauss-Seidels metode raskt,
  noe som skyldes at spektralradien er liten og godt separert fra
  \( \lambda_2 \). Desverre er nok ikke forholdene så gunstige for de
  tilfellene der vi ønsker å bruke iterasjonsmetoder.

<p>
  Anta at vi skal løse en Poisson-ligning \( \nabla^2u=f(x,y) \) på et
  enhetskvadrat, se f.eks. figur <a href="#fig:715">68</a>, og la skrittlengden
  være \( h \) i begge koordinat-retningene.  For dette tilfellet er det
  mulig å finne spektralradien analytisk, se. f.eks Hageman \& Young
  <a href="#23">[13]</a>. Vi finner følgende uttrykk:

<p>
Jacobis metode:

$$
\begin{equation} \rho = \cosh(\pi h) \approx 1-\frac{(\pi h)^2}{2}
  \text{ for små } h \label{eq:73247a}
\end{equation}
$$

Gauss-Seidels metode:

$$
\begin{equation}
    \rho = \cosh^2(\pi h)\approx 1-(\pi h)^2 \text{ for små } h
\label{eq:73247b}
  \end{equation}
$$

SOR:

$$
\begin{equation}
    \rho = \frac{1-\sinh(\pi h)}{1+\sinh(\pi h)} \approx 1-2\pi h
    \text{ for små } h
\label{eq:73247c}
  \end{equation}
$$

Tilfelle (c) er basert på optimal  \( \omega \).

<p>
Vi husker at betingelsen for konvergens er at spektralradien
\( \rho < 1 \). For små \( h \) nærmer spektralradien seg raskt 1 for alle
metodene, men særlig er dette tydelig for Jacobi- og Gauss-Seidels
metode. Tabellen nedenfor viser dette klart.

<p>

<div class="row">
  <div class="col-xs-9">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>Spektral radius </b></td> <td align="center">\( h=\frac{1}{32} \)</td> <td align="center">\( h=\frac{1}{64} \)</td> <td align="center">\( h= \frac{1}{128} \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   \( \rho_{J} \)      </td> <td align="center">   0.9952                  </td> <td align="center">   0.9988                  </td> <td align="center">   0.9997                    </td> </tr>
<tr><td align="center">   \( \rho_{GS} \)     </td> <td align="center">   0.9904                  </td> <td align="center">   0.9976                  </td> <td align="center">   0.9994                    </td> </tr>
<tr><td align="center">   \( \rho_{SOR} \)    </td> <td align="center">   0.8215                  </td> <td align="center">   0.9065                  </td> <td align="center">   0.9521                    </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-9 -->
<p>
Dette vises enda tydligere når vi beregner antall iterasjoner som
behøves for å vinne ett desimalsiffer, se lign. \eqref{eq:73243}.

<p>

<div class="row">
  <div class="col-xs-9">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b> Iterasjoner </b></td> <td align="center">\( h=\frac{1}{32} \)</td> <td align="center">\( h=\frac{1}{64} \)</td> <td align="center">\( h= \frac{1}{128} \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   \( k_{J} \)      </td> <td align="center">   477                     </td> <td align="center">   1910                    </td> <td align="center">   7644                      </td> </tr>
<tr><td align="center">   \( k_{GS} \)     </td> <td align="center">   239                     </td> <td align="center">   955                     </td> <td align="center">   3822                      </td> </tr>
<tr><td align="center">   \( k_{SOR} \)    </td> <td align="center">   12                      </td> <td align="center">   23                      </td> <td align="center">   47                        </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-9 -->
<p>
Konklusjon: Det er bare SOR som er praktisk brukbare av disse metodene.

<p>
 På grunn av denne konklusjonen, har vi bare brukt SOR på eksemplene i
 dette avsnittet med unntak av et demo-eksempel med Gauss-Seidel. Det
 er mulig å forbedre SOR betraktelig. Vi kan f.eks. variere \( \omega \)
 for hver iterasjon etter bestemte skjema istedenfor å la den være
 konstant i hele iterasjonsprosessen.  Legg også merke til at SOR, med
 Gauss-Seidel som spesialtilfelle, er avhengig av nummereringen. Vi
 kan forbedre konvergensen ved f.eks å bruke sjakkbrett-nummerering,
 dvs: Først gjennomløpe \( 1,3,5,\dots \) og deretter \( 2,4,6,\dots \). Den
 SOR-versjonen vi har brukt kalles punkt-SOR fordi vi går fra punkt
 til punkt. Her er det forbedringspotensiale ved heller å operere på
 hele blokker, eventuelt hele linjer. For dem som er interessert i
 disse variantene, henvises til Press <a href="#15">[14]</a> og Hageman \& Young
 <a href="#23">[13]</a> der det også finnes programmer. Det er sjelden bryet verdt
 å bruke disse mer avanserte versjonene fordi det idag finnes mer
 effektive iterasjons-metoder. Fordelen med den enkle SOR-metoden vi
 har brukt, er at den er lett å programmere både for lineære- og
 ikke-lineære ligninger. Legg merke til at når vi brukte
 direkte-løsere (se <a href="#kap:72">Direct numerical solution</a>), måtte vi sette opp hele
 matrisa på forhånd. Dette var forholdsvis enkelt i de viste
 eksemplene, noe som ofte ikke er tilfelle ellers. Samtidig var vi
 avhengige av de innebygde løserne i Matlab.

<p>
 Dersom du ønsker å bruke iterasjonsmetoder på et fint nett, bør du
 bruke noen av de nyere metodene. Disse går under betegnelsene
 Flernett-metoder (Multigrid) og Krylov-metoder. En god introduksjon
 til Flernett-metoder finnes i Briggs <a href="#24">[15]</a>.  En rekke av
 Krylov-metodene finnes tilgjengelig i Matlab. Stikkord er her
 \( bicg, cgs, bicgstab, pcg, gmres og qmr \). Skriv f.eks \( doc\ gmres \) og
 se på eksemplene.  Istedenfor matrisene som er gitt i eksemplene der,
 kan du bruke koeffisient-matrisene fra eksemplene i avsnitt
 <a href="#kap:72">Direct numerical solution</a>. Se Saad <a href="#25">[16]</a> for mer om Krylov-metoder.  Mange av
 disse metodene er også behandlet av Kelley <a href="#26">[17]</a> med nedlastbare
 Matlabprogram.

<h2 id="kap:721">UTNYTTELSE AV SYMMETRI</h2>

<p>
Ved å utnytte eventuell symmetri for et problem, kan vi redusere
antall ukjente.
Dersom vi ser på figur <a href="#fig:74">70</a>, har vi symmetri
om linja \( x=0.5 \).

<p>
Formelt får vi da betingelsen \( \frac{\partial T}{\partial x}=0 \) langs
denne linja, men det er selvfølgelig ikke nødvendig å utføre noe
diskretisering da det følger direkte at \\ 
\( T_{11}=T_{31},\ T_{12}=T_{32} \) osv. Dette fører til at at systemet i
\eqref{eq:7205} i dette tilfellet blir:

$$
\begin{equation}
    \left(\begin{array}{cccccccccc}
      -4& 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0  \\ 
      1& -4 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0  \\ 
      0& 1 & -4 & 1 & 0 & 0 & 0 & 1 & 0 & 0  \\ 
      0& 0 & 1 & -4 & 1 & 0 & 0 & 0 & 1 & 0  \\ 
      0& 0 & 0 & 1 & -4 & 0 & 0 & 0 & 0 & 1  \\ 
      2& 0 & 0 & 0 & 0 & -4 & 1 & 0 & 0 & 0 \\ 
      0& 2 & 0 & 0 & 0 & 1 & -4 & 1 & 0 & 0  \\ 
      0& 0 & 2 & 0 & 0 & 0 & 1 & -4 & 1 & 0  \\ 
      0& 0 & 0 & 2 & 0 & 0 & 0 & 1 & -4 & 1 \\ 
      0& 0 & 0 & 0 & 2 & 0 & 0 & 0 & 1 & -4  \\ 
    \end{array}\right)
    \cdot
    \left(\begin{array}{c}
      T_{11}\\ 
      T_{12}\\ 
      T_{13}\\ 
      T_{14}\\ 
      T_{15}\\ 
      T_{21}\\ 
      T_{22}\\ 
      T_{23}\\ 
      T_{24}\\ 
      T_{25}\\ 
    \end{array}\right)
    =
    \left(\begin{array}{c}
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      -100\\ 
      0\\ 
      0\\ 
      0\\ 
      0\\ 
      -100\\ 
    \end{array}\right)
\label{eq:7217}
\end{equation}
$$

<p>
Løsningen av \eqref{eq:7217} er gitt i Matlab-programmet <b>lap1s</b> nedenfor.

<p>

<!-- code=matlab (!bc mcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">  <span style="color: #408080; font-style: italic">% program lap1s</span>
  clear
  n = <span style="color: #666666">10</span>;
  d = <span style="color: #008000">ones</span>(n,<span style="color: #666666">1</span>); <span style="color: #408080; font-style: italic">% diagonal</span>
  b = <span style="color: #008000">zeros</span>(n,<span style="color: #666666">1</span>); <span style="color: #408080; font-style: italic">% right hand side</span>
  <span style="color: #408080; font-style: italic">% --- Update b ---</span>
  b(<span style="color: #666666">5</span>) = <span style="color: #666666">-100</span>; b(<span style="color: #666666">10</span>) = <span style="color: #666666">-100</span>;
  <span style="color: #408080; font-style: italic">% --- Generate A-matrix ---</span>
  A = spdiags([<span style="color: #666666">2*</span>d d <span style="color: #666666">-4*</span>d d d],[<span style="color: #666666">-5</span> <span style="color: #666666">-1</span> <span style="color: #666666">0</span> <span style="color: #666666">1</span> <span style="color: #666666">5</span>], n,n);
  <span style="color: #408080; font-style: italic">% --- Update A ---</span>
  A(<span style="color: #666666">5</span>,<span style="color: #666666">6</span>) = <span style="color: #666666">0</span>; A(<span style="color: #666666">6</span>,<span style="color: #666666">5</span>) = <span style="color: #666666">0</span>;
  <span style="color: #408080; font-style: italic">% --- Solve system ---</span>
  T = A<span style="color: #666666">\</span>b;
</pre></div>

<h3 id="___sec77">Poisson-ligning </h3>

<p>
La oss se på lign. \eqref{eq:7107} for et kvadratisk tverrsnitt av en kanal

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 70:  Caption goes here. <div id="fig:74"></div> </p></center>
<p><img src="fig-ch7/5.png" align="bottom" width=400></p>
</center>

<p>
Dersom vi ikke utnytter symmetrien, blir problemet fra \eqref{eq:7107}

$$
\begin{equation}
  \dfrac{\partial^2 u}{\partial x^2}+ \dfrac{\partial^2u}{\partial
    y^2}=-1
\label{eq:7218}
\end{equation}
$$

Randbetingelser: \( u=0 \)	  langs hele randkurven.

<p>
Dette er et problem med Dirichlet-betingelser. Dersom vi utnytter symmetrien om \( x=0.5 \) og \( y=0.5 \), blir formelt symmetri-betingelsene:

$$
\begin{align*}
  \frac{\partial u}{\partial x}=0 \text{ for } x=0.5\\ 
  \frac{\partial u}{\partial y}=0 \text{ for } y=0.5
\end{align*}
$$

<p>
Vi ser at vi også kan benytte oss av symmetrien om diagonalene, slik at det f.eks er tilstrekkelig å løse ligningen i trekanten ABC da AC er en symmetrilinje.
Figur <a href="#fig:75">71</a> på neste side viser trekanten ABC med nummerering der vi har utnyttet symmetrien. Vi setter \( u_1=u_{1,1},\ u_2=u_{1,2},\ u_3=u_{1,3} \)  osv. Langs AB har vi avmerket
randverdien  \( u=0 \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 71:  Caption goes here. <div id="fig:75"></div> </p></center>
<p><img src="fig-ch7/6.png" align="bottom" width=400></p>
</center>

<p>
Den diskretiserte versjonen av \eqref{eq:7218} blir:

$$
\begin{equation}
  u_{i+1,j}+u_{i-1,j}+u_{i,j+1}+u_{i,j-1}-4u_{i,j}=-h^2
\label{eq:7219}
\end{equation}
$$


$$
\begin{equation*}
  \text{med } \Delta x= \Delta y = h
\end{equation*}
$$

Vi har valgt \( h=0.1 \)  i figur <a href="#fig:75">71</a>.  Beregningsmolekylet med enkle indekser:

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 72:  Caption goes here. </p></center>
<p><img src="fig-ch7/7.png" align="bottom" width=400></p>
</center>

<p>
slik at  \eqref{eq:7219} blir:

$$
\begin{equation}
  u_a+u_b+u_c+u_d-4u_m=-h^2
\label{eq:72110}
\end{equation}
$$

Noen eksempler på bruk av \eqref{eq:72110}:

$$
\begin{align*}
  2u_2-4u_1=-h^2\\ 
  2u_4+u_9-4u_5=-h^2\\ 
  u_7+u_4+u_9+u_{11}-4u_8=-h^2
\end{align*}
$$

med  \( m=1,\, 5 \) og \( 8 \). 
Det endelige ligningsystemet blir som gitt i \eqref{eq:72111}:

$$
\begin{equation}
    \left(\begin{array}{ccccccccccccccc}
      -4& 2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &0 \\ 
      1& -4 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &0 \\ 
      0& 1 & -4 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &0 \\ 
      0& 0 & 1 & -4 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 &0 \\ 
      0& 0 & 0 & 2 & -4 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 &0 \\ 
      0& 2 & 0 & 0 & 0 & -4 & 2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &0 \\ 
      0& 0 & 1 & 0 & 0 & 1 & -4 & 1 & 0 & 1 & 0 & 0 & 0 & 0 &0 \\ 
      0& 0 & 0 & 1 & 0 & 0 & 1 & -4 & 1 & 0 & 1 & 0 & 0 & 0 &0 \\ 
      0& 0 & 0 & 0 & 1 & 0 & 0 & 2 & -4 & 0 & 0 & 1 & 0 & 0 &0 \\ 
      0& 0 & 0 & 0 & 0 & 0 & 2 & 0 & 0 & -4 & 2 & 0 & 0 & 0 &0 \\ 
      0& 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & -4 & 1 & 1 & 0 &0 \\ 
      0& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 2 & -4 & 0 & 1 &0 \\ 
      0& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 0 & -4 & 2 &0 \\ 
      0& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 2 & -4 &1 \\ 
      0& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 4 &-4
    \end{array}\right)
    \cdot
    \left(\begin{array}{c}
      u_{1}\\ 
      u_{2}\\ 
      u_{3}\\ 
      u_{4}\\ 
      u_{5}\\ 
      u_{6}\\ 
      u_{7}\\ 
      u_{8}\\ 
      u_{9}\\ 
      u_{10}\\ 
      u_{11}\\ 
      u_{12}\\ 
      u_{13}\\ 
      u_{14}\\ 
      u_{15}
    \end{array}\right)
    = -
    \left(\begin{array}{c}
      h^2\\ 
      h^2\\ 
      h^2\\ 
      h^2\\ 
      h^2\\ 
      h^2\\ 
      h^2\\ 
      h^2\\ 
      h^2\\ 
      h^2\\ 
      h^2\\ 
      h^2\\ 
      h^2\\ 
      h^2\\ 
      h^2
    \end{array}\right)
\label{eq:72111}
\end{equation}
$$

<p>
Selv om bandstrukturen er tydelig, blir den mer rotet fordi vi har utnyttet symmetrien. Det blir mer oppdatering av koeffisientmatrisa.
Programmet <b>poisson</b> løser \eqref{eq:72111}:

<p>

<!-- code=matlab (!bc mcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">  <span style="color: #408080; font-style: italic">% program poisson</span>
  clear
  n = <span style="color: #666666">15</span>;
  h = <span style="color: #666666">0.1</span>; h2 = h<span style="color: #666666">*</span>h;
  d0 = <span style="color: #008000">zeros</span>(n,<span style="color: #666666">1</span>); <span style="color: #408080; font-style: italic">% diagonal</span>
  d = <span style="color: #008000">ones</span>(n,<span style="color: #666666">1</span>); <span style="color: #408080; font-style: italic">% diagonal</span>
  b = <span style="color: #666666">-</span>h2<span style="color: #666666">*</span><span style="color: #008000">ones</span>(n,<span style="color: #666666">1</span>); <span style="color: #408080; font-style: italic">% right hand side</span>
  <span style="color: #408080; font-style: italic">% --- generate A-matrix ---</span>
  A = spdiags([d0 d0 d0 d <span style="color: #666666">-4*</span>d d d0 d0 d0],[<span style="color: #666666">-4</span> <span style="color: #666666">-3</span> <span style="color: #666666">-2</span>  <span style="color: #666666">-1</span> <span style="color: #666666">0</span> <span style="color: #666666">1</span> <span style="color: #666666">2</span> <span style="color: #666666">3</span> <span style="color: #666666">4</span>], n,n);
  <span style="color: #408080; font-style: italic">% === Update A ===</span>

 <span style="color: #408080; font-style: italic">% --- sub-diagonals ---</span>
  A(<span style="color: #666666">6</span>,<span style="color: #666666">2</span>) = <span style="color: #666666">2</span>; A(<span style="color: #666666">7</span>,<span style="color: #666666">3</span>) = <span style="color: #666666">1</span>; A(<span style="color: #666666">8</span>,<span style="color: #666666">4</span>) = <span style="color: #666666">1</span>; A(<span style="color: #666666">9</span>,<span style="color: #666666">5</span>) = <span style="color: #666666">1</span>;
  A(<span style="color: #666666">10</span>,<span style="color: #666666">7</span>) = <span style="color: #666666">2</span>; A(<span style="color: #666666">11</span>,<span style="color: #666666">8</span>) = <span style="color: #666666">1</span>; A(<span style="color: #666666">12</span>,<span style="color: #666666">9</span>) = <span style="color: #666666">1</span>;
  A(<span style="color: #666666">13</span>,<span style="color: #666666">11</span>) = <span style="color: #666666">2</span>; A(<span style="color: #666666">14</span>,<span style="color: #666666">12</span>) = <span style="color: #666666">1</span>;
  A(<span style="color: #666666">5</span>,<span style="color: #666666">4</span>) = <span style="color: #666666">2</span>; A(<span style="color: #666666">6</span>,<span style="color: #666666">5</span>) = <span style="color: #666666">0</span>; A(<span style="color: #666666">9</span>,<span style="color: #666666">8</span>) = <span style="color: #666666">2</span>; A(<span style="color: #666666">10</span>,<span style="color: #666666">9</span>) = <span style="color: #666666">0</span>; A(<span style="color: #666666">12</span>,<span style="color: #666666">11</span>) = <span style="color: #666666">2</span>;
  A(<span style="color: #666666">13</span>,<span style="color: #666666">12</span>) = <span style="color: #666666">0</span>; A(<span style="color: #666666">14</span>,<span style="color: #666666">13</span>) = <span style="color: #666666">2</span>; A(<span style="color: #666666">15</span>,<span style="color: #666666">14</span>) = <span style="color: #666666">4</span>;
  <span style="color: #408080; font-style: italic">% --- super-diagonals ---</span>
  A(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>) = <span style="color: #666666">2</span>; A(<span style="color: #666666">5</span>,<span style="color: #666666">6</span>) = <span style="color: #666666">0</span>; A(<span style="color: #666666">6</span>,<span style="color: #666666">7</span>) = <span style="color: #666666">2</span>; A(<span style="color: #666666">9</span>,<span style="color: #666666">10</span>) = <span style="color: #666666">0</span>;
  A(<span style="color: #666666">10</span>,<span style="color: #666666">11</span>) = <span style="color: #666666">2</span>; A(<span style="color: #666666">12</span>,<span style="color: #666666">13</span>) = <span style="color: #666666">0</span>; A(<span style="color: #666666">13</span>,<span style="color: #666666">14</span>) = <span style="color: #666666">2</span>;
  A(<span style="color: #666666">11</span>,<span style="color: #666666">13</span>) = <span style="color: #666666">1</span>; A(<span style="color: #666666">12</span>,<span style="color: #666666">14</span>) = <span style="color: #666666">1</span>;
  A(<span style="color: #666666">7</span>,<span style="color: #666666">10</span> ) = <span style="color: #666666">1</span>; A(<span style="color: #666666">8</span>,<span style="color: #666666">11</span>) = <span style="color: #666666">1</span>; A(<span style="color: #666666">9</span>,<span style="color: #666666">12</span>) = <span style="color: #666666">1</span>;
  A(<span style="color: #666666">2</span>,<span style="color: #666666">6</span>) = <span style="color: #666666">1</span>; A(<span style="color: #666666">3</span>,<span style="color: #666666">7</span>) = <span style="color: #666666">1</span>; A(<span style="color: #666666">4</span>,<span style="color: #666666">8</span>) = <span style="color: #666666">1</span>; A(<span style="color: #666666">5</span>,<span style="color: #666666">9</span>) = <span style="color: #666666">1</span>;
  <span style="color: #408080; font-style: italic">% --- solve system ---</span>
  u = A<span style="color: #666666">\</span>b;
</pre></div>
<p>
Tabellen nedenfor viser de numeriske verdiene fra programmet. De analytiske verdiene er gitt i siste kolonne. Senterverdien \( u_{15} \)  har en feil på 0.8%.
Koordinatene refererer til figur <a href="#fig:74">70</a>.

<p>

<div class="row">
  <div class="col-xs-4">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( u_{1}=u(0.1 , 0.1 ) \) </td> <td align="center"><b>0.0128</b></td> <td align="center"><b>0.0131</b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   \( u_{2}=u(0.2 , 0. 1) \)     </td> <td align="center">   0.0206    </td> <td align="center">   0.0209    </td> </tr>
<tr><td align="center">   \( u_{3}=u(0.3 , 0.1 ) \)     </td> <td align="center">   0.0254    </td> <td align="center">   0.0256    </td> </tr>
<tr><td align="center">   \( u_{4}=u(0.4 , 0.1 ) \)     </td> <td align="center">   0.0280    </td> <td align="center">   0.0282    </td> </tr>
<tr><td align="center">   \( u_{5}=u(0.5 , 0.1 ) \)     </td> <td align="center">   0.0288    </td> <td align="center">   0.0290    </td> </tr>
<tr><td align="center">   \( u_{6}=u(0.2 , 0.2 ) \)     </td> <td align="center">   0.0343    </td> <td align="center">   0.0346    </td> </tr>
<tr><td align="center">   \( u_{7}=u(0.3 , 0.2 ) \)     </td> <td align="center">   0.0430    </td> <td align="center">   0.0433    </td> </tr>
<tr><td align="center">   \( u_{8}=u(0.4 , 0.2 ) \)     </td> <td align="center">   0.0478    </td> <td align="center">   0.0482    </td> </tr>
<tr><td align="center">   \( u_{9}=u(0.5 , 0.2 ) \)     </td> <td align="center">   0.0493    </td> <td align="center">   0.0497    </td> </tr>
<tr><td align="center">   \( u_{10}=u(0.3 , 0.3 ) \)    </td> <td align="center">   0.0544    </td> <td align="center">   0.0548    </td> </tr>
<tr><td align="center">   \( u_{11}=u(0.4 , 0.3 ) \)    </td> <td align="center">   0.0608    </td> <td align="center">   0.0613    </td> </tr>
<tr><td align="center">   \( u_{12}=u(0.5 , 0.3 ) \)    </td> <td align="center">   0.0629    </td> <td align="center">   0.0634    </td> </tr>
<tr><td align="center">   \( u_{13}=u(0.4 , 0.4 ) \)    </td> <td align="center">   0.0682    </td> <td align="center">   0.0687    </td> </tr>
<tr><td align="center">   \( u_{14}=u(0.5 , 0.4 ) \)    </td> <td align="center">   0.0706    </td> <td align="center">   0.0712    </td> </tr>
<tr><td align="center">   \( u_{15}=u(0.5 , 0.5 ) \)    </td> <td align="center">   0.0731    </td> <td align="center">   0.0737    </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-4 -->
<p>
De analytiske verdiene er beregnet fra:

$$
\begin{align}
  &u=\zeta\cdot \frac{(1-\zeta)}{2}-\frac{4}{\pi^3}\sum^\infty_{n=1,3,5,\dots}\frac{1}{n^3}\frac{\cosh(n\pi\bar y)}{\cosh\left(\frac{n\pi }{2}\right)}\cdot \sin(n\pi\zeta)
\label{_auto69}\\ 
  &\text{der } \bar x=\left|x-\frac{1}{2}\right|,\ \bar y = \left|y-\frac{1}{2}\right|,\zeta =\frac{1}{2}-\bar x,\ (x,y) \in [0,1].\nonumber \\ 
  &\text{Bytt om $\bar x$ og $\bar y$ dersom $\bar y>\bar x$}
\label{eq72112}
\end{align}
$$

<p>
<!-- --- begin exercise --- -->

<h2 id="exercise:symmetry">Exercise 1: Symmetric solution</h2>

<p>
Prove that the analytical solution of the temperature field \( T(x,y) \) in
\eqref{eq:7206} is symmetric around \( x = 0.5 \).

<p>
<!-- --- end exercise --- -->

<p>
<!-- !split -->

<center><h1 id="ch:5">Diffusjonsproblemer</h1></center> <!-- chapter heading -->

<h1 id="ch5:sec1">Differanser. Notasjon</h1>

<p>
I avsnitt ((<a href="#ch1:sec:differences">Differences</a>))  brukte vi Taylor-utviklingen for en funksjon av en uavhengig variabel til å utlede differanseformler. Tilsvarende kan gjøres for 
funksjoner av flere uavhengige variable. Dersom uttrykkene ikke har noen kryssderiverte, kan vi direkte bruke formlene som vi utledet i avsnitt 
(<a href="#ch1:sec:differences">Differences</a>).
Vi må bare huske å holde indekset for den andre variable konstant.

<p>
Følgende notasjon brukes for de diskrete verdiene i \( x \)- og \( y \)-retning:

$$
\begin{align*}
&x_i=x_0+i\cdot \Delta x,\ i=0,1,2,\dots \\ 
&y_j=y_0+j\cdot \Delta y,\ j=0,1,2,\dots
\end{align*}
$$

<p>
Som tidligere forutsetter vi at \( \Delta x \) og \( \Delta y \) er konstante dersom intet annet blir spesifisert. Figure <a href="#fig:51">73</a> nedenfor gir eksempel 
på notasjonen i to dimensjoner.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 73:  <div id="fig:51"></div> </p></center>
<p><img src="fig-ch5/1.png" align="bottom" width=450></p>
</center>

<p>
Vi skriver nå opp en rekke formler direkte fra avsnitt ((<a href="#ch1:sec:differences">Differences</a>)).

<p>
Foroverdifferanser:

$$
\begin{equation} \label{eq:5101a}
\frac{\partial u}{\partial x}\bigg|_ {i,j} = \frac{u_{i+1,j}-u_{i,j}}{\Delta x} + O(\Delta x)
\end{equation}
$$

<p>
Bakoverdifferanser:

$$
\begin{equation} \label{eq:5101b}
\frac{\partial u}{\partial x}\bigg|_ {i,j} = \frac{u_{i,j}-u_{i-1,j}}{\Delta x} + O(\Delta x)
\end{equation}
$$

<p>
Sentraldifferanser

$$
\begin{equation} \label{eq:5101c}
\frac{\partial u}{\partial x}\bigg|_ {i,j} = \frac{u_{i+1,j}-u_{i-1,j}}{2\Delta x} + O\left[(\Delta x)^2\right]
\end{equation}
$$


$$
\begin{equation} \label{eq:5102}
\frac{\partial^2 u}{\partial x^2}\bigg|_ {i,j} = \frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{(\Delta x)^2} + O\left[(\Delta x)^2\right]
\end{equation}
$$

<p>
Tilsvarende formler for \( \frac{\partial u}{\partial y} \) og \( \frac{\partial^2u}{\partial y^2} \) følger direkte:

<p>
Foroverdifferanser:

$$
\begin{equation} \label{eq:5103a}
\frac{\partial u}{\partial y}\bigg|_ {i,j} = \frac{u_{i,j+1}-u_{i,j}}{\Delta y}
\end{equation}
$$

<p>
Bakoverdifferanser:

$$
\begin{equation} \label{eq:5103b}
\frac{\partial u}{\partial y}\bigg|_ {i,j} = \frac{u_{i,j}-u_{i,j-1}}{\Delta y}
\end{equation}
$$

<p>
Sentraldifferanser

$$
\begin{equation} \label{eq:5103c}
\frac{\partial u}{\partial y}\bigg|_ {i,j} = \frac{u_{i,j+1}-u_{i,j-1}}{2\Delta y} 
\end{equation}
$$


$$
\begin{equation} \label{eq:5104}
\frac{\partial^2 u}{\partial y^2}\bigg|_ {i,j} = \frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{(\Delta y)^2} 
\end{equation}
$$

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">

<h2 id="___sec81">Example: </h2>
Vi diskretiserer Laplace-ligningen \( \frac{\partial^2u}{\partial y^2}+\frac{\partial^2u}{\partial y^2}=0 \) ved å bruke \eqref{eq:5102}og \eqref{eq:5104} 
og velger \( \Delta x= \Delta y \).

<p>
Dette gir følgende differanseligning:

$$
\begin{equation*}
u_{i+1,j}+u_{i-1,j}+u_{i,j-1}+u_{i,j+1}-4u_{i,j}=0
\end{equation*}
$$

<p>
Det resulterende beregningsmolekylet er illustrert i Figure <a href="#fig:5ptstencil">74</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 74:  5-punkts beregningsmolekyl for diffusjonsligningen <div id="fig:5ptstencil"></div> </p></center>
<p><img src="fig-ch5/2transp_5ptstencil.png" align="bottom" width=200></p>
</center>

<p>
Vi ser av formelen at senterverdien er middelverdien av verdiene i de
andre puntene. Denne formelen er velkjent og kalles gjerne
5-punkts-formelen (Brukes i kapittel (<a href="#ch:7">Elliptic partial differential equations</a>) ).
</div>
<!-- end box -->


<p>
<br />

<p>
Ved render er vi ofte nødt til å bruke bakover eller foroverdifferanser. Vi gir her noen formler med 2. ordens nøyaktighet.

<p>
Foroverdifferanser:

$$
\begin{equation} \label{eq:5105}
\frac{\partial u}{\partial x}\bigg|_ {i,j} = \frac{-3u_{i,j}+4u_{i+1,j}-u_{i+2,j}}{2\Delta x} 
\end{equation}
$$

<p>
Bakoverdifferanser:

$$
\begin{equation} \label{eq:5106}
\frac{\partial u}{\partial x}\bigg|_ {i,j} = \frac{3u_{i,j}-4u_{i-1,j}+u_{i-2,j}}{2\Delta x}  
\end{equation}
$$

<p>
Formlene for (<a href="#forward">forward</a>) , (<a href="#backward">backward</a>) og (<a href="#central">central</a>) differanser gitt i kapittel (<a href="#ch:1">Initial value problems for Ordinary Differential Equations</a>) kan brukes nå også bare vi utstyrer dem med to indekser. 
<!-- Programmet <b>diffaf</b> er derfor like nyttig her. Original også en henvisning til dette programmet i kapittel 1, men denne referansen er ikke med i det digitale kompendiet. -->
En fyldig samling av differanseformler finnes i Anderson <a href="#anderson1997computational">[18]</a>. Detaljerte utledninger er 
gitt i Hirsch <a href="#hirsch2007numerical">[19]</a>.

<p>
<!-- !split -->

<h1 id="ch5:sec2">Diffusjonsligningen</h1>

<h2 id="ch5:sec21">Introduction</h2>

<p>
Den endimensjonale diffusjonsligningen er gitt ved:

$$
\begin{equation} 
\label{eq:5211}
\frac{\partial u}{\partial t}=\alpha\frac{\partial^2u}{\partial x^2}
\end{equation}
$$

<p>
\( t \) kalles som tidligere nevnt, den evolusjonsvariable og kan være både tid-og romkoordinat.

<p>
Typiske diffusjonsproblemer:

<p>
1) Varmeledning:
$$
\begin{equation*}
\frac{\partial T}{\partial t}=\alpha \frac{\partial^2T}{\partial x^2}
\end{equation*}
$$

<p>
2) Ikke-stasjonært grensesjikt: (Stokes problem)
$$
\begin{equation*}
\frac{\partial u}{\partial t}=\nu \frac{\partial^2u}{\partial y^2}
\end{equation*}
$$

<p>
3) Strømning i porøse media:
$$
\begin{equation*}
\frac{\partial u}{\partial t}=c \frac{\partial^2u}{\partial x^2}
\end{equation*}
$$

<p>
4) Linearisert grensesjiktligning:
$$
\begin{equation*}
\frac{\partial u}{\partial x}=\frac{\nu}{U_0} \frac{\partial^2u}{\partial y^2}
\end{equation*}
$$

<p>
( Her er \( x \) den evolusjonsvariable. )

<p>
Sammenligner \eqref{eq:5211} med klassifikasjonsligningen \eqref{eq:4301}:
<!-- \\ %i kap. 4: % eq ref, -->

<!-- begin inline comment -->
<font color="red">(<b>Marie 11</b>: Sikkert greit å henvise til kapittel 4, seksjon 3 i kompendiet)</font>
<!-- end inline comment -->


$$
\begin{equation}
\label{eq:4301}
A \frac{\partial^2\phi }{\partial x^2} +B \frac{\partial^2 \phi }{\partial x \partial y} +C\frac{\partial^2 \phi }{\partial y^2} +f=0
\end{equation}
$$


$$
\begin{equation}
\label{eq:4309b}
A\cdot (dy)^2-B\cdot dy \cdot dx+C\cdot (dx)^2=0
\end{equation}
$$


$$
\begin{equation}
\label{eq:43011}
\lambda_{1,2} = \frac{B\pm \sqrt{B^2-4AC}}{2A}
\end{equation}
$$

<p>
\( B   =C=   0 ,\ A=   1 \) som innsatt i \eqref{eq:4309b} og \eqref{eq:43011} gir:
<!-- % i kap. 4 gir: %% eq ref -->

$$
\begin{equation*}
dt   =0 ,\ B^2-4AC=0  
\end{equation*}
$$

<p>
\eqref{eq:5211} er følgelig parabolsk, og karakteristikken er gitt ved \( t= \) konstant.

<p>
Dersom vi dividerer \( dt \) med \( dx \):

$$
\begin{equation} \label{eq:5212}
\frac{dt}{dx}=0\to \frac{dx}{dt}=\infty
\end{equation}
$$

<p>
Derav: Uendelig signalforplantningshastighet langs den karakteristiske kurva \( t= \) konstant.

<p>

<!-- begin inline comment -->
<font color="red">(<b>Marie 12</b>: Mer henvisning til kapittel 4.)</font>
<!-- end inline comment -->

<p>
<!-- Dette er en oppsummering av opplysninger som tidligere har vært gitt i avsnitt ref {ch4:sec4}. (Se spesielt figur ref {fig:46}) %fig ref og kap ref -->

<p>
<!-- !split -->

<h2 id="ch5:sec22">Ikke-stasjonær couette strømning</h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 75:  <div id="fig:52"></div> </p></center>
<p><img src="fig-ch5/3.png" align="bottom" width=400></p>
</center>

<p>
Den klassiske versjonen av dette problemet med \( b=\infty \) har vi tidligere behandlet i avsnitt (<a href="#ch2:sec3">Litt om likedannhetsløsninger</a>) som Stokes 1. problem.

<p>
Ligning:

$$
\begin{equation} \label{eq:5223a}
\frac{\partial U}{\partial \tau}=\nu \frac{\partial^2U}{\partial Y^2},\ 0 < Y < b
\end{equation}
$$

<p>
Initialbetingelse:

$$
\begin{equation} \label{eq:5223b}
U(Y,\ \tau)=0,\ \tau < 0
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{equation} \label{eq:5223c}
\left.\begin{matrix}
U(0,\ \tau)=&U_0\\ 
U(b,\ \tau)=&0
\end{matrix}\right\}=\tau \geq 0
\end{equation}
$$

<p>
I avsnitt (<a href="#ch2:sec3">Litt om likedannhetsløsninger</a>) har vi sett på flere måter å gjøre \eqref{eq:5223a}) dimensjonsløs.

<p>
Innfører følgende dimensjonsløse variable:

$$
\begin{equation} \label{eq:5224}
y=\frac{Y}{b},\ u=\frac{U}{U_0},\ t= \frac{\tau\nu}{b^2}
\end{equation}
$$

<p>
\eqref{eq:5223a} kan da skrives:

$$
\begin{equation} \label{eq:5225a}
\frac{\partial u}{\partial t}=\frac{\partial^2u}{\partial y^2},\ 0 < y < 1
\end{equation}
$$

<p>
Initialbetingelse:

$$
\begin{equation} \label{eq:5225b}
u(y,\ t)=0,\ t < 0
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{equation} \label{eq:5225c}
\left.\begin{matrix}
u(0,\ t)=&1\\ 
u(1,\ t)=&0
\end{matrix}\right\},\ t \geq 0
\end{equation}
$$

<p>
Som i avsnitt (<a href="#ch2:sec3">Litt om likedannhetsløsninger</a>), kan dette eksemplet også formuleres som et varmeledningsproblem.

<p>
Analytisk løsning:

$$
\begin{equation} \label{eq:5226}
u(y,t)=1-y-\frac{2}{\pi}\cdot \sum^{\infty}_{n=1}\frac{1}{n}\exp[-(n\pi)^2t]\sin(n\pi y)
\end{equation}
$$

<p>
Utledningen av \eqref{eq:5226} er gitt i detalj i appendiks G.6 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>.
<!-- \\ %appendiks 7, del 5. %%% app referanse app ref appendiks -->

<p>
Vi diskretiserer \eqref{eq:5225a} ved å benytte foroverdifferanser for tiden \( t \) og sentraldifferanser for romkoordinaten \( y \):

$$
\begin{equation} \label{eq:5227a}
\frac{\partial u}{\partial t}\bigg|^n_j\approx \frac{u^{n+1}_j-u_j^n}{\Delta t}
\end{equation}
$$


$$
\begin{equation} \label{eq:5227b}
\frac{\partial^2u}{\partial y^2} \approx \frac{u^n_{j+1}-2u^n_j+u^n_{j-1}}{(\Delta y)^2}
\end{equation}
$$


$$
\begin{equation*}
\text{der } t_n=n\cdot \Delta t,\ n=0,1,2,\dots,\ y_j=j\cdot \Delta y,\ j=0,1,2,\dots  
\end{equation*}
$$

<p>
\eqref{eq:5227a} innsatt i \eqref{eq:5225a} gir følgende differanseligning:

$$
\begin{equation} \label{eq:5228a}
u_j^{n+1}= r(u_{j+1}^n+u^n_{j-1})+(1-2r)u_j^n
\end{equation}
$$


$$
\begin{equation} \label{eq:5228b}
\text{der } r=\frac{\Delta t}{(\Delta y)^2}=\nu \frac{\Delta \tau}{(\Delta Y)^2}
\end{equation}
$$

<p>
\( r \) er en dimensjonsløs gruppe. I varmeledning brukes betegnelsen det numeriske Fourier-tallet om denne gruppa.(Lign. \eqref{eq:5228a} er behandlet i 
avsnitt 13.1 i C&amp;K <a href="#cheney1999numerical">[7]</a>)). I avsnitt (<a href="#ch5:sec5">Trunkeringsfeil, konsistens og konvergens</a>) viser vi at skjemaet i \eqref{eq:5228a}) er av 2. ordens nøyaktighet i \( t \) 
og 4. ordens nøyaktighet i \( y \) dersom vi bruker \( r=1/6 \). I strømningsmekanikken er det vanlig å skrive \( u^n_j \) istedenfor \( u_{j,n} \) slik at indekset 
for den evolusjonsvariable skrives som et øvre indeks. Vi adopterer denne skrivemåten generelt.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 76:  FTCS-skjemaet <div id="fig:53"></div> </p></center>
<p><img src="fig-ch5/4.png" align="bottom" ></p>
</center>

<p>
Et skjema der vi bruker foroverdifferanser for den tidslignende variable og sentraldifferanser for romkoordinaten, betegnes gjerne på engelsk som et
FTCS-skjema (Forward Time Central Space ). Når vi bruker betegnelsen FTCS , menes 1. ordens nøyaktighet i \( t \) og 2. ordens nøyaktighet i 
romkoordinaten(e). Det er også vanlig å kalle dette skjemaet for Euler-skjemaet.

<p>
Figure <a href="#fig:53">76</a> viser at skjemaet er eksplisitt; verdien ved tiden \( n+1 \) kan finnes direkte av formelen uten å løse et ligningsystem.

<p>
Velger \( \Delta y=0.1 \) og prøver med \( r=0.3 \) og \( r=0.6 \)

<p>
<b>Tilfelle A, r = 0.3</b>

<p>
Fra \eqref{eq:5228a} får vi:

$$
\begin{align*}
\Delta t = (\Delta y)^2\cdot r=3.0\cdot 10^{-3}, \text{ som gir:}\\ 
t_n=n\cdot 3.0\cdot 10^{-3},\ n=0,1,2,\dots
\end{align*}
$$

<p>
Tabell 5.1 <div id="tab:5.1"></div>

<p>

<div class="row">
  <div class="col-xs-12">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b> y </b></td> <td align="center">\( t_n=0.03 \)</td> <td align="center">\( \%\ \varepsilon \)</td> <td align="center">\( t_n=0.06 \)</td> <td align="center">\( \%\ \varepsilon \)</td> <td align="center">\( t_n=0.12 \)</td> <td align="center">\( \%\ \varepsilon \)</td> <td align="center">\( t_n=0.45 \)</td> <td align="center">\( \%\ \varepsilon \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   0.0    </td> <td align="center">   1.0000            </td> <td align="center">   0.0                      </td> <td align="center">   1.0000            </td> <td align="center">   0.0                      </td> <td align="center">   1.0000            </td> <td align="center">   0.0                      </td> <td align="center">   1.0000            </td> <td align="center">   0.00                     </td> </tr>
<tr><td align="center">   0.1    </td> <td align="center">   0.6917            </td> <td align="center">   1.3                      </td> <td align="center">   0.7761            </td> <td align="center">   0.4                      </td> <td align="center">   0.8394            </td> <td align="center">   0.1                      </td> <td align="center">   0.8978            </td> <td align="center">   0.01                     </td> </tr>
<tr><td align="center">   0.2    </td> <td align="center">   0.4266            </td> <td align="center">   3.0                      </td> <td align="center">   0.5692            </td> <td align="center">   1.0                      </td> <td align="center">   0.6851            </td> <td align="center">   0.3                      </td> <td align="center">   0.7958            </td> <td align="center">   0.02                     </td> </tr>
<tr><td align="center">   0.3    </td> <td align="center">   0.2310            </td> <td align="center">   4.7                      </td> <td align="center">   0.3927            </td> <td align="center">   1.6                      </td> <td align="center">   0.5427            </td> <td align="center">   0.5                      </td> <td align="center">   0.6942            </td> <td align="center">   0.03                     </td> </tr>
<tr><td align="center">   0.4    </td> <td align="center">   0.1080            </td> <td align="center">   5.5                      </td> <td align="center">   0.2537            </td> <td align="center">   2.2                      </td> <td align="center">   0.4163            </td> <td align="center">   0.8                      </td> <td align="center">   0.5931            </td> <td align="center">   0.04                     </td> </tr>
<tr><td align="center">   0.5    </td> <td align="center">   0.0428            </td> <td align="center">   3.8                      </td> <td align="center">   0.1528            </td> <td align="center">   2.6                      </td> <td align="center">   0.3084            </td> <td align="center">   1.0                      </td> <td align="center">   0.4928            </td> <td align="center">   0.06                     </td> </tr>
<tr><td align="center">   0.6    </td> <td align="center">   0.0140            </td> <td align="center">   -2.3                     </td> <td align="center">   0.0854            </td> <td align="center">   2.7                      </td> <td align="center">   0.2191            </td> <td align="center">   1.3                      </td> <td align="center">   0.3931            </td> <td align="center">   0.07                     </td> </tr>
<tr><td align="center">   0.7    </td> <td align="center">   0.0036            </td> <td align="center">   -15.2                    </td> <td align="center">   0.0440            </td> <td align="center">   2.1                      </td> <td align="center">   0.1472            </td> <td align="center">   1.5                      </td> <td align="center">   0.2942            </td> <td align="center">   0.08                     </td> </tr>
<tr><td align="center">   0.8    </td> <td align="center">   0.0007            </td> <td align="center">   -35.7                    </td> <td align="center">   0.0206            </td> <td align="center">   0.9                      </td> <td align="center">   0.0896            </td> <td align="center">   1.6                      </td> <td align="center">   0.1958            </td> <td align="center">   0.08                     </td> </tr>
<tr><td align="center">   0.9    </td> <td align="center">   0.0001            </td> <td align="center">   -60.9                    </td> <td align="center">   0.0078            </td> <td align="center">   -0.6                     </td> <td align="center">   0.0422            </td> <td align="center">   1.7                      </td> <td align="center">   0.0978            </td> <td align="center">   0.09                     </td> </tr>
<tr><td align="center">   1.0    </td> <td align="center">   0.0000            </td> <td align="center">   0.0                      </td> <td align="center">   0.0000            </td> <td align="center">   0.0                      </td> <td align="center">   0.0000            </td> <td align="center">   0.0                      </td> <td align="center">   0.0000            </td> <td align="center">   0.00                     </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-12 -->
<p>
\( \% \) er prosent relativ feil \( = \left(\frac{u_{num} \ - \ u_{analytisk}}{u_{analytisk}}\right)\cdot 100 \) der \( u_{analytisk} \) er gitt i \eqref{eq:5226}.

<p>
For \( t_n=0.03 \)  ser vi at \( \Delta y \) er for stor til å gi tilstrekkelig oppløsning. Med \( t_n=0.45 \) har vi praktisk talt fått den stasjonære løsningen 
\( u_s=1-y \).

<p>
For å få en bedre oppløsning for tilfellet \( t_n=0.03 \), utfører vi en beregning med \( \Delta y=  0.05 \) og en med \( \Delta y=    0.01  \). 
For \( \Delta y =  0.05 \) får vi 40 tidskritt og for \( \Delta y = 0.01 \) får vi 1000.

<p>
<br />

<p>
Table 5.2: Resultater for \( r  = 0.3 \). Venstre side av tabellen er for \( \Delta y   =  0.05 \) og høyre side for \( \Delta y  =  0.01 \). <div id="tab:5.2"></div>

<p>

<div class="row">
  <div class="col-xs-8">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b> y </b></td> <td align="center">\( t_n=0.03 \)</td> <td align="center">\( \%\ \varepsilon \)</td> <td align="center">\( t_n=0.06 \)</td> <td align="center">\( \%\ \varepsilon \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   0.0    </td> <td align="center">   1.0000            </td> <td align="center">   0.00                     </td> <td align="center">   1.0000            </td> <td align="center">   0.00                     </td> </tr>
<tr><td align="center">   0.1    </td> <td align="center">   0.6853            </td> <td align="center">   0.32                     </td> <td align="center">   0.6832            </td> <td align="center">   0.01                     </td> </tr>
<tr><td align="center">   0.2    </td> <td align="center">   0.4173            </td> <td align="center">   0.75                     </td> <td align="center">   0.4143            </td> <td align="center">   0.03                     </td> </tr>
<tr><td align="center">   0.3    </td> <td align="center">   0.2232            </td> <td align="center">   1.17                     </td> <td align="center">   0.2208            </td> <td align="center">   0.05                     </td> </tr>
<tr><td align="center">   0.4    </td> <td align="center">   0.1038            </td> <td align="center">   1.33                     </td> <td align="center">   0.1025            </td> <td align="center">   0.05                     </td> </tr>
<tr><td align="center">   0.5    </td> <td align="center">   0.0416            </td> <td align="center">   0.92                     </td> <td align="center">   0.0412            </td> <td align="center">   0.04                     </td> </tr>
<tr><td align="center">   0.6    </td> <td align="center">   0.0142            </td> <td align="center">   -0.5                     </td> <td align="center">   0.0143            </td> <td align="center">   -0.02                    </td> </tr>
<tr><td align="center">   0.7    </td> <td align="center">   0.0041            </td> <td align="center">   -3.44                    </td> <td align="center">   0.0043            </td> <td align="center">   -0.13                    </td> </tr>
<tr><td align="center">   0.8    </td> <td align="center">   0.0010            </td> <td align="center">   -8.39                    </td> <td align="center">   0.0011            </td> <td align="center">   -0.33                    </td> </tr>
<tr><td align="center">   0.9    </td> <td align="center">   0.0002            </td> <td align="center">   -15.2                    </td> <td align="center">   0.0002            </td> <td align="center">   -0.61                    </td> </tr>
<tr><td align="center">   1.0    </td> <td align="center">   0.0000            </td> <td align="center">   0.00                     </td> <td align="center">   0.0000            </td> <td align="center">   0.00                     </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-8 -->
<p>
<b>Tilfelle B, r = 0.6</b>

<p>
Med \( \Delta y =  0.1 \) får vi nå \( t_n=n\cdot 6.0\cdot 10^{-3},\ n=0,1,2,\dots \). 
Resultatet av denne beregningen er vist i tabellen under:

<p>
<br />

<p>
Tabell 5.3: Resultater for r =  0.6. <div id="tab:5.3"></div>

<p>

<div class="row">
  <div class="col-xs-8">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b> y </b></td> <td align="center">\( t_n=0.03 \)</td> <td align="center">\( \%\ \varepsilon \)</td> <td align="center">\( t_n=0.06 \)</td> <td align="center">\( \%\ \varepsilon \)</td> </tr>
</thead>
<tbody>
<tr><td align="center">   0.0    </td> <td align="center">   1.0000            </td> <td align="center">   0.0                      </td> <td align="center">   1.0000            </td> <td align="center">   0.0                      </td> </tr>
<tr><td align="center">   0.1    </td> <td align="center">   0.7939            </td> <td align="center">   16.2                     </td> <td align="center">   0.5797            </td> <td align="center">   -25.0                    </td> </tr>
<tr><td align="center">   0.2    </td> <td align="center">   0.2995            </td> <td align="center">   -27.7                    </td> <td align="center">   0.9186            </td> <td align="center">   63.0                     </td> </tr>
<tr><td align="center">   0.3    </td> <td align="center">   0.3715            </td> <td align="center">   68.4                     </td> <td align="center">   0.0027            </td> <td align="center">   -99.3                    </td> </tr>
<tr><td align="center">   0.4    </td> <td align="center">   0.0259            </td> <td align="center">   -74.7                    </td> <td align="center">   0.6239            </td> <td align="center">   151.4                    </td> </tr>
<tr><td align="center">   0.5    </td> <td align="center">   0.0778            </td> <td align="center">   88.6                     </td> <td align="center">   -0.1241           </td> <td align="center">   -183.3                   </td> </tr>
<tr><td align="center">   0.6    </td> <td align="center">   0.0000            </td> <td align="center">                            </td> <td align="center">   0.2663            </td> <td align="center">   220.0                    </td> </tr>
<tr><td align="center">   0.7    </td> <td align="center">   0.0000            </td> <td align="center">                            </td> <td align="center">   -0.0551           </td> <td align="center">   -227.7                   </td> </tr>
<tr><td align="center">   0.8    </td> <td align="center">   0.0000            </td> <td align="center">                            </td> <td align="center">   0.0625            </td> <td align="center">   206.4                    </td> </tr>
<tr><td align="center">   0.9    </td> <td align="center">   0.0000            </td> <td align="center">                            </td> <td align="center">   -0.0081           </td> <td align="center">   -202.3                   </td> </tr>
<tr><td align="center">   1.0    </td> <td align="center">   0.0000            </td> <td align="center">                            </td> <td align="center">   0.0000            </td> <td align="center">   0.0                      </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-8 -->
<p>
Tabellen  indikerer tydelig en instabilitet. Ser vi på siste leddet i \eqref{eq:5228a}, finner vi at alle leddene er positive for \( 2r\leq 1 \), 
dvs. \( r\leq \frac{1}{2} \), som er en tilstrekkelig betingelse for å hindre oscillasjoner. I Figure <a href="#fig:55">77</a> har vi tegnet opp løsningen fra tabell 
(<a href="#tab:5.1">tab:5.1</a>) og i Figure <a href="#fig:56">78</a> løsningen fra tabell (<a href="#tab:5.2">tab:5.2</a>. Figure <a href="#fig:57">79</a> og (<a href="#fig:58">80</a> viser løsningen for \( r= 0.514 \) med \( \Delta y \) lik 
henholdsvis 0.1 og 0.05.

<p>
Betingelsen \( r\leq\frac{1}{2} \) forhindrer altså økende oscillasjoner i differanseligningen for den gitte initialbetingelsen. Vi skal nå vise at vi kan 
utvide dette resultatet slik at det også kan brukes på andre differanseligninger.

<p>
<b>Resultater FTCS for ulike verdier av</b> \( r \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 77:  \( r=0.3 \) og \( \Delta y = 0.1 \). <div id="fig:55"></div> </p></center>
<p><img src="fig-ch5/5.png" align="bottom" ></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 78:  \( r=0.3 \) og \( \Delta y = 0.05 \). <div id="fig:56"></div> </p></center>
<p><img src="fig-ch5/6.png" align="bottom" ></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 79:  \( r=0.541 \) og \( \Delta y = 0.1 \). <div id="fig:57"></div> </p></center>
<p><img src="fig-ch5/7.png" align="bottom" ></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 80:  \( r=0541 \) og \( \Delta y = 0.05 \). <div id="fig:58"></div> </p></center>
<p><img src="fig-ch5/8.png" align="bottom" ></p>
</center>

<p>
<!-- !split -->

<h2 id="ch5:sec23">PK-kriteriet: Kriteriet om positive koeffisienter</h2>

<p>
La \( s=a_1x_1+a_2x_2+\dots+a_kx_k \) være en sum av \( k \) ledd der tallene \( a_1,a_2,\dots,a_k \) er positive.

<p>
Setter: \( x_{min}=\min(x_1,x_2,\dots,x_k)\text{ og } x_{max}=\max(x_1,x_2,\dots,x_k) \)

<p>
Derav:

$$
\begin{equation} \label{eq:5239}
x_{min}\cdot (a_1+a_2+\dots+a_k)\leq s\leq x_{max}\cdot (a_1+a_2+\dots+a_k)
\end{equation}
$$

<p>
Merk at dette bare gjelder dersom \( a_1,a_2,\dots, a_k \) er positive. 
La oss se på to tilfeller:

<p>
<br />

<p>
<b>Tilfelle 1</b>: \( a_1+a_2+\dots+a_k=1 \)

<p>
Innsatt i \eqref{eq:5239}:

$$
\begin{equation} \label{eq:52310}
x_{min}\leq     s\leq x_{max}
\end{equation}
$$

<p>
Likhetstegnene i \eqref{eq:52310} gjelder for \( x_1=x_2=\dots=x_k \).

<p>
La oss nå anvende \eqref{eq:52310} på differanseligningen i \eqref{eq:5228a}:

$$
\begin{equation*}
u^{n+1}_j=r(u^n_{j+1}+u^n_{j-1})+(1-2r)u^n_j
\end{equation*}
$$

<p>
Her har vi \( a_1=r,\ a_2=r,\ a_3=1-2r \) slik at \( a_1+a_2+a_3=1 \).

<p>
\eqref{eq:52310} gir da:

$$
\begin{equation*}
\min(u^n_{j+1},u^n_{j},u^n_{j-1})\leq u^{n+1}_j\leq \max(u^n_{j+1},u^n_{j},u^n_{j-1}) 
\end{equation*}
$$

<p>
Betingelsen forat dette gjelder, er at alle koeffisientene \( a_1,a_2.\dots,a_k \) er positive. Da \( r > 0 \), betyr dette at bare \( a_3=1-2r \) kan bli negativ. 
Betingelsen for at \( a_3 \) skal være positiv, blir da: \( 1-2r > 0 \) som gir \( r < \frac{1}{2} \). Når \( r=\frac{1}{2} \), forsvinner \( a_3 \), slik at \( a_1+a_2=1 \) 
og betingelsen også er oppfylt med \( r=\frac{1}{2} \). Dette tilfellet kalles Bender - Schmidt formelen.

<p>
Det betyr at dersom vi velger \( r\leq \frac{1}{2} \), vil \( u \)-verdiene ved tidskrittet \( n+1 \) ligge mellom den største og den minste \( u \)-verdien ved 
tidskritt \( n \). Dersom skjemaet er eksplisitt og homogent og \( u=u_0 \) er konstant er en løsning, vil summen av koeffisientene ofte være lik 1. 
(Sett f.eks \( u=u_0 \)  inn i \eqref{eq:5228a}). Dette skyldes formen differanseutrykkene får fra Taylor-utviklingen. 
(Se (<a href="#forward">forward</a>) , (<a href="#backward">backward</a>) og (<a href="#central">central</a>) differanser gitt i kapittel (<a href="#ch:1">Initial value problems for Ordinary Differential Equations</a>)).

<p>
<br />

<p>
<b>Tilfelle 2</b>: \( a_1+a_2+\dots+a_k < 1 \)

<p>
Definerer \( b=1-(a_1+a_2+\dots + a_k) > 0 \) slik at \( a_1+a_2+\dots +a_k+b=1 \)

<p>
Kan da skrive følgende sum:  \( a=a_1x_1+a_2x_2+\dots+a_k+b\cdot 0 \)
Vi ser da at disse utrykkene oppfyller alle betingelsene for tilfelle 1 slik at vi får:

$$
\begin{equation} \label{eq:52311}
\min(0,x_1,x_2,\dots,x_k)\leq s\leq \max(0,x_1,x_2,\dots,x_k)
\end{equation}
$$

<p>
Til forskjell fra \eqref{eq:52310} har vi nå fått inn tallet 0 ; ellers som før. La oss se på et eksempel:

$$
\begin{equation*}
\frac{\partial T}{\partial t}= \alpha \frac{\partial ^2T}{\partial x^2}+bT,\ b=\text{konstant},\ t < t_{maks}
\end{equation*}
$$

<p>
Dersom vi bruker FTCS-skjemaet, får vi:

$$
\begin{equation*}
T^{n+1}_j=r(T^n_{j+1}+T^n_{j-1})+(1-2r+\Delta t\cdot b)T^n_j,\ r=\alpha \frac{\Delta t}{(\Delta x)^2}
\end{equation*}
$$

<p>
Med \( a_1=a_2=r \) og \( a_3=1-2r+\Delta t\cdot b \) får vi:

$$
\begin{equation*}
a_1+a_2+a_3=1+\Delta t\cdot b\leq 1 \text{ bare med negativ verdi av $b$}
\end{equation*}
$$

<p>
Kravet om positive koeffisienter blir nå:

$$
\begin{equation*}
1-2r+\Delta t\cdot b > 0 \text{ som blir: }0 < r < \frac{1}{2}+\frac{\Delta t\cdot b}{2}\text{ der $b$ er negativ}
\end{equation*}
$$

<p>
Kriteriet sier da at \( T \)-verdiene fra differanseligningen ikke øker når \( b \) er negativ.
Dette stemmer med fysikken, da en negativ \( b \) betyr at leddet \( bT \) kan oppfattes som et varmesluk.

<p>
\eqref{eq:52310} og \eqref{eq:52311} er egentlig ikke stabilitetskriterium. Setningene gir en <em>tilstrekkelig</em> betingelse for å hindre at voksende 
oscillasjoner oppstår, noe som kan være adskillig mer restriktivt enn det som er nødvendig for stabilitet. Men i mange tilfeller er vi tilfreds med 
en slik betingelse. PK-kriteriet er mye anvendt  fordi den ofte kan brukes på differanseligninger der en mer eksakt analyse er vanskelig å gjennomføre. 
Legg merke til at det bare kan brukes for eksplisitte skjema dersom vi ikke har ekstra opplysninger. For parabolske ligninger har vi gjerne slike 
ekstra opplysninger i form av det vi kaller maks.-min. prinsipp.(Se avsnitt (<a href="#ch5:sec43">Crank-Nicolson skjemaet. \( \theta \)-skjemaet</a>)). Kriteriet må også modifiseres når vi har problemer med 
økende amplitude.

<p>
Det beste ville selvfølgelig være å ha et kriterium som gir en nødvendig og tilstrekkelig betingelse for numerisk stabilitet. For generelle 
differanseligninger eksisterer det ikke noe slikt kriterium, noe som neppe er overraskende. Et kriterium som ofte gir nødvendige og i noen tilfeller 
også tilstrekkelige betingelser for stabilitet, er von Neumanns metode. Denne metoden består i en Fourier-analyse av den lineariserte 
differanseligningen og kan også brukes for implisitte skjema. Vi skal se på denne metoden i det neste avsnittet.
<!-- !split -->

<h1 id="ch5:sec3">Stabilitetsanalyse med von Neumanns medtode</h1>

<p>
Vi har differensialligningen:

$$
\begin{equation} \label{eq:5301}
\frac{\partial u}{\partial t}=\frac{\partial^2u}{\partial x^2}
\end{equation}
$$

<p>
La oss repetere hvordan vi kan løse denne ved bruk av separasjon av variable. Antar at vi kan skrive \( u(x,t) \) som produkt av to funksjoner 
\( f(t) \) og \( g(x) \):

$$
\begin{equation*}
u(x,t)=f(t)\cdot g(x)
\end{equation*}
$$

<p>
Ved derivasjon:  \( \frac{\partial u }{\partial t}=\frac{d f(t)}{dt}\cdot g(x),\ \frac{\partial^2u}{\partial x^2}=f(t)\cdot \frac{d^2g(x)}{dx^2}\cdot \frac{1}{g(x)} \) 
som innsatt ovenfor gir:

$$
\begin{equation*}
\frac{df(t)}{dt}\cdot g(x)=f(t)\cdot \frac{d^2g(x)}{dx^2}\to \frac{df(t)}{dt}\cdot \frac{1}{f(t)}=\frac{d^2g(x)}{dx^2}\cdot \frac{1}{g(x)}
\end{equation*}
$$

<p>
Den ene siden av ligningen er bare funksjon av \( t \), mens den andre bare er funksjon av \( x \). Da de to sidene skal være like for vilkårlige verdier 
av \( t \) og \( x \), er den eneste muligheten at hver av sidene er lik en konstant. Denne konstanten kalles separasjonskonstanten og vi velger den 
lik \( -\beta^2 \):

$$
\begin{align*}
&\frac{df(t)}{dt}\cdot \frac{1}{f(t)} = -\beta^2 \to \frac{df(t)}{dt}+\beta^2\cdot f(t)=0 \\ 
&\frac{d^2g(x)}{dx^2}\cdot \frac{1}{g(x)}=-\beta^2\to \frac{d^2g(x)}{dx^2}+\beta^2\cdot g(x)=0
\end{align*}
$$

<p>
Den første ligningen har løsning \( f(t)=e^{-\beta^2t} \) og den andre

$$
\begin{align*}
&g(x)=A\sin(\beta x)+B\cos(\beta x)\text{ slik at vi totalt får:}\\ 
&u(x,t)=e^{-\beta^2t}\cdot\left[A\sin(\beta x ) +B\cos(\beta x)\right]
\end{align*}
$$

<p>
Dette er en partikulær løsning, og da ligningen er lineær, vet vi at summen av slike løsninger også er en løsning:

$$
\begin{equation*}
u(x,t)= \sum^{m=\infty}_{m=0}e^{-\beta^2_mt}\cdot \left[A_m\sin(\beta_mx)+B_m\cos(\beta_mx) \right]
\end{equation*}
$$

<p>
I et gitt tilfelle bestemmes \( A_m,\ B_m \) og \( \beta_m \) av startbetingelsene og randbetingelsene. Dette er vist i detalj i appendiks G.6 i 
<a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>.

<p>
Vi har ikke bruk for den generelle løsningen, men greier oss med to partikulære løsninger:

$$
\begin{equation} \label{eq:5302}
u(x,t)=\left\{\begin{matrix}
e^{-\beta^2t}\sin(\beta x)\\ 
e^{-\beta^2t}\cos(\beta x)
\end{matrix}\right.
\end{equation}
$$

<p>
\eqref{eq:5302} kan skrives mer kompakt ved å bruke Eulers formel:

$$
\begin{equation} \label{eq:eq:5303}
e^{i\cdot x}=\cos(x)+i\cdot \sin(x),\ i=\sqrt{-1}
\end{equation}
$$

<p>
Følgende uttrykk er da en løsning av \eqref{eq:5301}:

$$
\begin{equation} \label{eq:5304}
u(x,t)=e^{-\beta^2t}\cdot e^{i\cdot \beta x}=e^{-\beta^2t+i\cdot \beta x}
\end{equation}
$$

<p>
<b>Merk</b>. Egentlig skal vi ta realdelen eller imaginærdelen av høyre side av \eqref{eq:5304} da \( u \) er reell. Men da både realdelen og imaginærdelen 
tilfredstiller \eqref{eq:5301}, tillater vi oss nå og senere litt juks i notasjonen.

<p>
Med notasjonen \( x_j=j\cdot \Delta x,\ j=0,1,2,\dots \) og \( t_n=n\cdot \Delta t,\ n=0,1,2,\dots \)
får vi fra \eqref{eq:5304}:

$$
\begin{equation} \label{eq:5305a}
u(x_j,t_n)=e^{-\beta^2t_n}\cdot e^{i\cdot \beta x_j}=e^{-\beta^2\cdot n\cdot \Delta t}\cdot e^{i\beta x_j}=(e^{-\beta^2\cdot \Delta t})^n\cdot e^{i\beta x_j}
\end{equation}
$$


$$
\begin{equation} \label{eq:5305b}
u(x_j,t_{n+1})=e^{-\beta^2t_{n+1}}\cdot e^{i\cdot \beta x_j}=e^{-\beta^2\cdot (n+1)\cdot \Delta t}\cdot e^{i\beta x_j}=(e^{-\beta^2\cdot \Delta t})^{n+1}\cdot e^{i\beta x_j}
\end{equation}
$$

<p>
Vi får amplitudeforholdet ved å dividere de to uttrykkene på hverandre:

$$
\begin{equation} \label{eq:5306}
G_a = \frac{u(x_j,t_{n+1})}{u(x_j,t_n)}=e^{-\beta^2\Delta t}
\end{equation}
$$

<p>
G$_a$  kalles ofte den \( analytiske \) forsterkningsfaktoren. (Se avsnitt 1.6.1 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>) I dette tilfellet ser vi at 
\( G_a < 1 \).

<p>
\eqref{eq:5305a} kan nå skrives:

$$
\begin{equation} \label{eq:5307}
u(x_j,t_n)=(G_a)^n\cdot e^{i\cdot \beta x_j}\equiv G_a^n\cdot e^{i\cdot \beta x_j}
\end{equation}
$$

<p>
Da \( G_a < 1 \), vil \( G^n_a\to 0 \) for \( n\to\infty \) for dette problemet.

<p>
Fra \eqref{eq:5228a} har vi følgende differanseligning for løsning av \eqref{eq:5301}:

$$
\begin{equation} \label{eq:5308}
u_j^{n+1}=r(u^n_{j+1}+u^n_{j-1})+(1-2r)u_j^n,\ r=\frac{\Delta t}{(\Delta x)^2}
\end{equation}
$$

<p>
For endelig verdier av \( \Delta x \) og \( \Delta t \) vet vi at løsningen av differanseligningen nødvendigvis må avvike fra den analytiske løsningen av 
differensialligningen.Avviket vil selvfølgelig bli større for økende verdier av \( \Delta x \) og \( \Delta t \) og vi har sett at når forholdet 
\( r > \frac{1}{2} \), blir differanseligningen ustabil: Stadig økende amplituder med vekslende fortegn. Da \eqref{eq:5307} er en løsning av 
differensialligningen, forsøker vi et tilsvarende uttrykk for differanseligningen \eqref{eq:5308}:

$$
\begin{equation} \label{eq:5309}
u^n_j\to E^n_j=G^n\cdot e^{i\cdot \beta x_j}
\end{equation}
$$

<p>
Her er den <em>numeriske</em> forsterkningsfaktoren \( G \) gitt ved:

$$
\begin{equation} \label{eq:53010a}
G=\frac{E^{n+1}_j}{E^n_j}
\end{equation}
$$

<p>
som gir:

$$
\begin{equation} \label{eq:53010b}
E^n_j=G^n\cdot E_j^0,\ E^0_j=e^{i\cdot \beta \cdot x_j}
\end{equation}
$$

<p>
der \( G \) er en funksjon av \( \Delta t \) og \( \beta \) og kan være kompleks. Den numeriske forsterkningsfaktoren  \( G \) vil selvfølgelig være forskjellig fra 
den analytiske faktoren \( G_a \). Merk: \( G^n=G \) i \( n \)'te potens.

<p>
Dersom amplitudeforholdet skal være begrenset, må \( G \) tilfredstille følgende betingelse:

$$
\begin{equation} \label{eq:53011}
|G|\leq1
\end{equation}
$$

<p>
\eqref{eq:53011} kalles von Neumanns strenge stabilitetskriterium. Det kalles det strenge kriteriet fordi det ikke tillater at amplitudeforholdet øker. 
Vi skal fjerne denne restriksjonen i avsnitt (<a href="#ch5:sec44">Von Neumanns generelle stabilitetsbetingelse</a>). Selv om vi har brukt den enkle diffusjonsligningen  som eksempel, gjelder fremgangsmåtem 
også i mer generelle tilfeller: Vi setter \eqref{eq:5309} inn i den aktuelle differanseligningen og forlanger at \eqref{eq:53011} skal være oppfylt.

<p>
Noen egenskaper for kriteriet:

<ol>
 <li> Den lineære differanseligningen må ha konstante koeffisienter. Ved variable koeffisienter, kan kriteriet brukes ved å "fryse" 
    koeffisientene lokalt. Praksis viser at kriteriet da gir en  nødvendig betingelse for stabilitet.</li>
 <li> Kriteriet tar ikke hensyn til randverdier da det er utledet for periodiske initialdata. Dersom vi ønsker å undersøke randverdienes innvirkning på 
    stabiliteten, må koeffisientmatrisa for ligningsystemet undersøkes. Eventuelt en mer generell teori.</li>
 <li> Kriteriet tar ikke hensyn til randverdier da det er utledet for periodiske initialdata. Dersom vi ønsker å undersøke randverdienes innvirkning på 
    stabiliteten, må koeffisientmatrisa for ligningsystemet undersøkes. Eventuelt en mer generell teori.</li>
</ol>

<!-- !split -->

<h2 id="ch5:sec31">Bruk av von Neumann kriteriet</h2>

<p>
Vi vil nå analysere det eksplisitte skjemaet i \eqref{eq:5228a} ved bruk av von Neumanns metode. Skriver differanseligningen på følgende form:

$$
\begin{equation} \label{eq:53112}
E^{n+1}_j=r(E^n_{j+1}+E^n_{j-1})+(1-2r)E^n_j
\end{equation}
$$

<p>
Fra \eqref{eq:5309}: \( E^n_j=G^n\cdot e^{i\cdot \beta \cdot y_j} \) (\( G^n \)  betyr \( G \) i \( n \)-te potens) som innsatt i \eqref{eq:53112} gir:

$$
\begin{equation*}
G^{n+1}e^{i\cdot \beta y_j}=r\cdot (G^n\cdot e^{i\cdot \beta y_{j+1}}+G^n\cdot e^{i\cdot \beta y_{j-1}}) + (1-2r)G^ne^{i\cdot \beta y_j}
\end{equation*}
$$

<p>
Dividerer med \( G^n\cdot e^{i\cdot \beta y_{j}} \): 

$$
\begin{equation} \label{eq:53113a}
G=r(e^{i\cdot \beta h}+e^{-i\cdot \beta h})+(1-2r)=r(e^{i\delta}+e^{-i\delta})+(1-2r)
\end{equation}
$$


$$
\begin{equation} \label{eq:53113b}
\text{der }     \delta = \beta h 
\end{equation}
$$

<p>
<b>Merk</b>. Dersom vi bruker terminologien for periodiske funksjoner, er \( \beta \) et bølgetall (vinkelfrekvens) , og \( \delta \) en fasevinkel. 
(Se appendiks A.3 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>)

<p>
Noen standardformler som brukes ofte:

$$
\begin{equation} \label{eq:53114}
\begin{array}{l}
2\cos(x)=e^{ix}+e^{-ix}\\ 
i\cdot 2\sin(x)=e^{ix}-e^{-ix}\\ 
\cos(x)=1-2\sin^2(\frac{x}{2})
\end{array}
\end{equation}
$$

<p>
\eqref{eq:53114} brukt i \eqref{eq:53113a} gir:

$$
\begin{equation} \label{eq:53115}
G=1-2r(1-\cos(\delta))=1-4r\sin^2\left(\frac{\delta}{2}\right)
\end{equation}
$$

<p>
Betingelsen \( |G|\leq 1 \)  betyr, da \( G \) er reell:

$$
\begin{align*}
-1\leq G\leq 1 \text{ eller } -1\leq 1-4r\sin^2\left(\frac{\delta}{2}\right)\leq 1
\end{align*}
$$

<p>
Høyre side er tilfredstilt med \( r\geq0 \).

<p>
Venstre side:
$$
\begin{equation*}
r\leq \frac{1}{2\sin^2(\frac{\delta}{2})}
\end{equation*}
$$

<p>
som er oppfylt for alle \( \delta \) med \( r\leq \frac{1}{2} \).

<p>
Generelt har vi  \( -\pi \leq \delta \leq \pi \)

<p>
For lineære, homogene differanseligninger blir \( G=1 \) for \( \delta = 0 \). Kan brukes som en sjekk på innsettingen.

<p>
Betingelsen for stabilitet for dette skjemaet blir da:

$$
\begin{equation} \label{eq:53116}
0 < r < \frac{1}{2}
\end{equation}
$$

<p>
med \( r=\frac{\Delta t}{(\Delta y)^2} \) fra \eqref{eq:5228b}

<p>
Da vi har et to-nivå skjema med konstante koeffisienter, er \eqref{eq:53116} en nødvendig og tilstrekkelig betingelse for stabilitet. Dette bekreftes 
av resultatet som vi fant tidligere ved bruk av det tilstrekkelige kriteriet i \eqref{eq:52310}. Resultatet betyr en kraftig begrensning på størrelsen 
av \( \Delta t \), noe som selvfølgelig vil influere sterkt på tidsforbruket. Et røft overslag for regnetiden ved bruk av FTCS-skjemaet gir:

$$
\begin{equation*}
\frac{T_2}{T_1}\approx \left(\frac{h_1}{h_2}\right)^3 \text{ med samme $r$-verdi}
\end{equation*}
$$

<p>
der \( T_1 \) er regnetiden for \( \Delta y=h_1 \) og \( T_2 \) er regnetiden for \( \Delta y=h_2 \).

<p>
Med \( h_1=0.1 \) og \( h_2=0.01 \) får vi \( \frac{T_2}{T_1}=1000 \).

<p>
<b>Bruk av derivasjon</b>

<p>
Et alternativ er å finne for hvilken verdi av \( \delta G \) har maksimum og minimum ved å beregne \( \frac{dG}{d\delta} \) og sette \( \frac{dG}{d\delta}=0 \).
Deretter brukes betingelsen \( |G| < 1 \).

<p>
Fra \eqref{eq:53115}:

$$
\begin{equation*}
G=1-2r(1-cos(\delta))\to \frac{dG}{d\delta}=-2r\sin(\delta)
\end{equation*}
$$

<p>
som gir max-min for \( \delta=0,\\ \delta=\pm \pi \), \( \delta = 0 \) gir \( G=1 \), mens \( \delta=\pm \pi \) gir \( G=1-4r \) som med betingelsen \( |G|\leq 1 \) blir

$$
\begin{equation*}
-1\leq 1-4r\leq1
\end{equation*}
$$

<p>
Høyre side av ulikheten er alltid oppfylt, mens venstre side gir \( r\leq \frac{1}{2} \) som før. Vi vil ofte finne at \( \delta = \pm\pi \) er kritisk, 
slik at det uansett kan være lurt å sjekke disse verdiene. Men husk at dette nødvendigvis ikke er tilstrekkelig til å påvise stabilitet. Derimot 
kan det være tilstrekkelig til å påvise instabilitet da betingelsen \( |G|\leq1 \)  må være oppfylt for alle \( \delta \) - verdier i intervallet 
\( [-\pi,\ \pi] \).

<p>
<b>Sammenligning av forsterkningsfaktorene</b>.

<p>
Det kan være interessant å sammenligne forsterkningsfaktoren \( G \) i \eqref{eq:53115} med den analytiske forsterkningsfaktoren \( G_a \)  i \eqref{eq:5306}.

<p>
Ved bruk av \eqref{eq:5308} og \eqref{eq:53113b} kan \eqref{eq:5306} skrives:

$$
\begin{equation} \label{eq:53117}
G_a=\exp(-\delta^2\cdot r)
\end{equation}
$$

<p>
Stabilitetsgrensa er \( 0 < r \leq 0.5 \)  for \( G \) med følgende verdier for spesielle verdier av \( r \):

<p>
\( r=0.025 \)

$$
\begin{equation} \label{eq:53118a}
G=\cos^2\left(\frac{\delta}{2}\right)\geq0\text{ med } G=0 \text{ for } \delta = \pi
\end{equation}
$$

<p>
\( r=0.5 \)

$$
\begin{equation} \label{eq:53118b}
G=\cos(\delta) \text{ med } G=0 \text{ for } \delta = \pi/2 \text{ og } G=-1 \text{ for } \delta = \pi
\end{equation}
$$

<p>
Figure <a href="#fig:59">81</a> viser \( G \) og \( G_a \)  som funksjon av \( \delta \in [0,\ \pi] \)  for forskjellige verdier av \( r \). Merk at de heltrukne linjene er den 
numeriske forsterknings-faktoren.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 81:  Forsterkningsfaktorer for diffusjonsligningen. <div id="fig:59"></div> </p></center>
<p><img src="fig-ch5/9.png" align="bottom" width=400></p>
</center>

<p>
For \( \delta \in [0^\circ, 90^\circ] \)  gir differanseskjemaet større dempning enn den analytiske løsningen; liten forskjell for små \( \delta \), men øker 
kraftig for økende \( \delta \).

<p>
For \( \delta \in [90^\circ,\ 180^\circ] \)  ser vi at amplituden endatil får feil fortegn i tillegg til stor avvik i størrelse. Når løsningen likevel er 
brukbar, skyldes dette at den analytiske løsningen har en amplitude \( G_a \)  som avtar sterkt med økende frekvens; se den analytiske løsningen i 
\eqref{eq:5226}. Denne glattingseffekten er typisk for parabolske ligninger. Likevel er effekten merkbar fordi vi i dette tilfellet har en diskontinuitet 
i randbetingelsen for  \( y=0 \), slik at løsningen inneholder mange høyfrekvente komponenter.

<p>
Feil i amplituden defineres ofte ved \( \varepsilon_D =\left|\frac{G}{G_a}\right| \)  og kalles diffusjonsfeil eller dissipasjonsfeil. 
(Ingen feil for \( \varepsilon_D=1 \) ). Begrepet dissipativt skjema brukes gjerne om skjema der amplituden avtar med økende \( t \).

<p>
I vårt tilfelle:

$$
\begin{equation} \label{eq:53119}
\varepsilon_D=\left|1-4r\sin^2(\delta/2)\right|\cdot \exp(\delta^2\cdot r)
\end{equation}
$$

<p>
Rekkeutviklet for små  \( \delta \):

$$
\begin{equation*}
\varepsilon_D=1-r^2\delta^4/2+r\delta^4/12+O(\delta^6)
\end{equation*}
$$

<p>
som for \( r\leq1/2 \)  viser at feilen er liten for lave frekvenser.
<!-- !split -->

<h1 id="ch5:sec4">Flere skjema for parabolske ligninger</h1>

<h2 id="ch5:sec41">Richardson-skjemaet (1910)</h2>

<p>
FTCS-skjemaet er av 1. ordens nøyaktighet i \( t \) og 2. orden i \( y \). Vi ønsker et skjema som også er av av 2. ordens nøyaktighet i \( t \). Dette oppnår vi 
ved å benytte sentraldifferanser for leddet \( \frac{\partial u}{\partial t} \):

$$
\begin{equation*}
\frac{\partial u }{\partial t}\bigg |^n_j\approx \frac{u^{n+1}_j-u_j^{n-1}}{2\Delta t}
\end{equation*}
$$

<p>
som gir følgende differanseligning:

$$
\begin{equation} \label{eq:5411}
u^{n+1}_j=u^{n-1}_j+2r\left( u^n_{j-1} -2u^n_{j}+u^n_{j+1} \right)
\end{equation}
$$

<p>
Dette er et eksplisitt, 3-nivå skjema som kalles <em>Richardson-skjemaet</em>; se Figure <a href="#fig:510">82</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 82:  <div id="fig:510"></div> </p></center>
<p><img src="fig-ch5/10.png" align="bottom" width=400></p>
</center>

<p>
<b>Stabilitetsanalyse</b>.

<p>
La oss først forsøke det tilstrekkelige kriteriet i \eqref{eq:52310}. Betingelsen om bare positive koeffisienter lar seg ikke oppfylle da koeffisienten 
foran \( u^n_j \)-leddet  alltid er negativt for \( r > 0 \). Vi prøver derfor med von Neumanns metode. \eqref{eq:5309} innsatt i \eqref{eq:5411} gir:

$$
\begin{equation*}
G^{n+1}e^{i\cdot \beta y_j} = G^{n-1}e^{i\cdot \beta y_{j}}+2r[G^ne^{i\cdot \beta y_{j-1}}-2G^ne^{i\cdot \beta y_j}+G^ne^{i\cdot \beta y_{j+1}}]
\end{equation*}
$$

<p>
Dividerer med  \( G^{n-1}e^{i\beta y_j} \) der \( y_j=j\cdot h: \)

$$
\begin{equation*}
\begin{array}{ll}
G^2&=1+2rG\cdot \left(e^{-i\delta}+e^{i\delta}-2\right)=1+4rG\cdot(\cos(\delta)-1)\\ 
&=1-8Gr\cdot\sin^2\left(\frac{\delta}{2}\right)
\end{array}
\end{equation*}
$$

hvor vi har brukt \eqref{eq:53113b} og \eqref{eq:53114}. Vi har fått en 2. gradsligning fordi vi har et 3-nivå skjema:

$$
\begin{equation*}
\begin{array}{l}
G^2+2bG-1=0 \text{ med løsning}\\ 
G_{1,2}=-b\pm \sqrt{b^2+1},\ b=4r\sin^2\left(\frac{\delta}{2}\right)\geq0
\end{array}
\end{equation*}
$$

<p>
\( |G|=1 \) for \( b =0  \). For alle andre verdier av \( b \) har vi   \( |G_2|>1 \). Skjemaet er følgelig ustabilt for alle aktuelle verdier av \( r \). Et slikt 
skjema betegnes som ubetinget ustabilt. Dette tilfellet viser at det ikke er noen sammenheng mellom nøyaktighet og stabilitet.

<p>
<b>Bruk av derivasjon</b>

<p>
Vi kan bruke derivasjon her også:

$$
\begin{equation*}
\begin{array}{l}
G^2=1+4rG\cdot (\cos(\delta)-1)\\ 
2G\frac{dG}{d\delta}=4r\left[   (\cos(\delta)-1)\frac{dG}{d\delta}-G\sin(\delta) \right], \text{ som med } \frac{dG}{d\delta}=0\\ 
\text{gir max-min for $\delta=0$, $\delta=\pm \pi$  som for FTCS-skjemaet.} \\ 
\delta = 0 \text{ gir } G_{1,2}=\pm 1 \text{ mens } \delta = \pm \pi \text{ gir } G_{1,2}=-4r\pm \sqrt{1+(4r)^2}
\end{array}
\end{equation*}
$$

<p>
med instabilitet for \( |G_2|>1 \)  som tidligere.

<p>
<!-- !split -->

<h2 id="ch5:sec42">Dufort-Frankel skjemaet (1953)</h2>

<p>
Richardson-skjemaet i \eqref{eq:5411} kan gjøres stabilt ved følgende modifikasjon:

$$
\begin{equation} \label{eq:5422}
u^n_j=\frac{1}{2}(u_j^{n+1}+u^{n-1}_j)
\end{equation}
$$

<p>
som innsatt i \eqref{eq:5411} gir:

$$
\begin{equation} \label{eq:5423}
u^{n+1}_j=\frac{1}{1+2r}\left[ (1-2r)u^{n-1}_j+2r(u^n_{j+1}+u^n_{j-1})\right]
\end{equation}
$$

<p>
Dette er et eksplisitt 3-nivå skjema som kalles DuFort-Frankel-skjemaet, se Figure <a href="#fig:511">83</a>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 83:  <div id="fig:511"></div> </p></center>
<p><img src="fig-ch5/11.png" align="bottom" width=400></p>
</center>

<p>
3-nivå skjema der leddet \( u^n_j \)-leddet mangler, kalles skjema av “Leap-frog”-typen. (Leap-frog: hoppe bukk). Det tilstrekkelige kriteriet om positive 
koeffisienter fra \eqref{eq:52310} krever \( r\leq \frac{1}{2} \)  for et stabilt skjema. Stabilitetsanalysen er her litt mer komplisert p.g.a. at vi også 
må drøfte komplekse verdier av \( G \).

<p>
Innsatt fra \eqref{eq:5309} og divisjon med \( G^{n-1}e^{e^{i\delta j}} \):

$$
\begin{equation*}
G^2= \frac{1}{1+2r}\left[(1-2r)+2r\cdot G\cdot (e^{i\delta}+e^{-i\delta})\right] = \frac{1}{1+2r}\left[(1-2r)+4r\cdot G\cdot \cos(\delta)\right]
\end{equation*}
$$

<p>
som gir følgende 2. grads ligning:

$$
\begin{equation*}
\begin{array}{c}
(1+2r)\cdot G^2-4r\cdot G\cos(\delta)-(1-2r)=0 \text{ med løsning:}\\ 
\\ 
G_{1,2}= \dfrac{4r\cos(\delta) \pm \sqrt{(4r\cos(\delta))^2 +4(1+2r)\cdot(1-2r)}}{2(1+2r)}\\ 
\\ 
=\dfrac{2r\cos(\delta)\pm \sqrt{1-r^2\sin^2(\delta)}}{1+2r}
\end{array}
\end{equation*}
$$

<p>
For stabilitet må begge røttene oppfylle betingelsen \( |G|\leq 1 \). Generelt må vi dessuten skille mellom reelle og komplekse røtter for
å ta vare på det tilfellet at \( G\leq 0 \)  når \( G \) er reell.

<ol>
 <li> Reelle røtter: \( 1-4r^2\sin(\delta)\geq0 \)
    <br />
    \( |G_{1,2}| \leq \dfrac{2r\cdot |\cos(\delta)|+\sqrt{1-4r^2\sin^2(\delta)}}{1+2r}\leq \dfrac{1+2r}{1+2r}\leq1 \)
    <br />
    <br /></li>
 <li> Komplekse røtter: \( 1-4r^2\sin^2(\delta) < 0 \to \sqrt{1-4r^2\sin^2(\delta)}=i\cdot \sqrt{4r^2\sin^2(\delta)-1} \)
    <br />
    <br />
    \( |G_{1,2}|^2= \bigg|\frac{\big(2r\cos(\delta)\big)^2+4r^2\sin^2(\delta)-1}{(1+2r)^2}\bigg|=\bigg|\frac{4r^2-1}{4r^2+4r+1}\bigg|=\bigg|\frac{2r-1}{2r+1}\bigg| < 1 \)</li>
</ol>

Analysen viser at \eqref{eq:5423} faktisk er ubetinget stabilt. DuFort-Frankel skjemaet er det eneste enkle kjente eksplisitte skjemaet med 2. ordens 
nøyaktighet som har denne egenskapen. Det har derfor vært en del brukt ved løsning av Navier-Stokes ligninger. I avsnitt (<a href="#ch5:sec5">Trunkeringsfeil, konsistens og konvergens</a>) skal vi se at 
forholdene ikke er så fullt så rosenrøde som analysen ovenfor kan tyde på. For å starte beregningen, kan FTCS-skjemaet brukes.

<p>
<!-- !split -->

<h2 id="ch5:sec43">Crank-Nicolson skjemaet. \( \theta \)-skjemaet</h2>

<p>
En av bakdelene ved DuFort-Frankel skjemaet er at det behøves et spesielt skjema for å starte regneprosessen. Vi forsøker derfor å finne en 
approksimasjon for \( \frac{\partial u}{\partial t} \)  av 2. ordens nøyaktighet der bare to tidsnivå inngår.

<p>
Bruker sentraldifferanser for halve tidsintervallet:

$$
\begin{equation} \label{eq:5434}
\frac{\partial u}{\partial t}\bigg|^{n+\frac{1}{2}}_j=\frac{u_j^{n+1}-u^n_j}{\Delta t}+O(\Delta t)^2
\end{equation}
$$

<p>
Problemet blir nå å approksimere \( \dfrac{\partial u}{\partial t}\Big|^{n+\frac{1}{2}}_j \)  uten at nivået  \( n+\frac{1}{2} \) eksplisitt inngår i skjemaet. 
Dette oppnås ved Crank-Nicolson

<p>
approksimasjonen (1947):

$$
\begin{equation} \label{eq:5435}
\frac{\partial^2 u}{\partial t^2}\bigg|^{n+\frac{1}{2}}_j=\frac{1}{2}\left[  \frac{u_{j+1}^{n+1}-2u_j^{n+1}+u_{j-1}^{n+1}}{(\Delta x)^2} +\frac{u_{j+1}^{n}-2u_j^{n}+u_{j-1}^{n}}{(\Delta x)^2}       \right]+O(\Delta x)^2
\end{equation}
$$

<p>
Differanseligningen blir nå:

$$
\begin{align} \label{eq:5436}
&u_{j-1}^{n+1}-2(1+\frac{1}{r})u_j^{n+1}+u_{j+1}^{n+1} = -u^n_{j-1}+2(1-\frac{1}{r})u^n_j-u^n_{j+1}\\ 
&\text{der } r= \dfrac{\Delta t}{(\delta x)^2} \text{ som før.} \nonumber
\end{align}
$$

<p>
Skjemaet er illustrert i Figure <a href="#fig:512">84</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 84:  <div id="fig:512"></div> </p></center>
<p><img src="fig-ch5/12.png" align="bottom" width=400></p>
</center>

<p>
Vi ser av \eqref{eq:5436} og Figure <a href="#fig:512">84</a> at skjemaet er implisitt. Dette betyr at vi må løse et ligningsystem. I dette tilfellet er systemet 
tridiagonalt, slik at Thomasalgoritmen og programmet <b>tdma</b> kan brukes. 
<!-- begin inline comment -->
<font color="red">(<b>Marie 13</b>: Henvisning til Matlab)</font>
<!-- end inline comment -->

<p>
Vi skal nå undersøke stabiliteten av \eqref{eq:5436}. For å slå flere fluer i et smekk, tar vi for oss følgende differanseligning som kalles  
\( \theta \)-skjemaet:

$$
\begin{equation} \label{eq:5437a}
u^{n+1}_j=u^n_j+r\left
  [\theta(u^{n+1}_{j+1}-2u_j^{n+1}+u^{n+1}_{j-1})+(1-\theta)(u^n_{j+1}-2u^n_j+u^n_{j-1})
  \right ]
\end{equation}
$$


$$
\begin{equation} \label{eq:5437b}
\text{der } 0\leq\theta\leq1
\end{equation}
$$

<p>
For \( \theta = 0 \)  får vi det eksplisitte FTCS-skjemaet. For \( \theta = \frac{1}{2} \)  får vi Crank-Nicolson skjemaet. For \( \theta = 1 \)  fås et implisitt 
skjema som ofte kalles Laasonen-skjemaet (1949). I strømningsmekanikken brukes gjerne betegnelsen BTCS-skjemaet. (Backward Time Central Space) eller 
det totalt implisitte skjemaet.

<p>
\eqref{eq:5309} innsatt i \eqref{eq:5437a} og divisjon med \( G^n\cdot e^{i\cdot \beta x_j} \) gir:

$$
\begin{equation*}
\begin{array}{llc}
G&=1+r[G\theta(e^{i\delta}+e^{-i\cdot \delta}-2)+(1-\theta)(e^{i\delta}+e^{-i\delta}-2)]&\\ 
&=1+r(e^{i\delta}+e^{-i\delta}-2)\cdot(G\theta+1-\theta)&\\ 
\end{array}
\end{equation*}
$$


$$
\begin{equation*}
\text{der } \delta = \beta \cdot h
\end{equation*}
$$

<p>
Med bruk av formlene i \eqref{eq:53114}:

$$
\begin{equation} \label{eq:5438}
G=\frac{1-4r(1-\theta)\sin^2(\frac{\delta}{2})}{1+4r\theta\sin^2(\frac{\delta}{2})}
\end{equation}
$$

<p>
Betingelsen for stabilitet er  \( |G|\leq1 \) eller siden \( G \) er reell: \( -1\leq G\leq1  \)

<p>
Da  \( 0\leq\theta\leq1 \) , er den høyre betingelsen tilfredstilt med \( r\geq0 \). For den venstre siden:

$$
\begin{align*}
2r\sin^2\left(\frac{\delta}{2}\right)(1-2\theta)\leq 1\text{ eller}\\ 
r(1-2\theta)\leq \frac{1}{2}\text{ da } \sin^2\left(\frac{\delta}{2}\right)\leq 1
\end{align*}
$$

<p>
For \( \frac{1}{2}\leq \theta \leq 1 \)  er betingelsen oppfylt for alle \( r\geq0 \), dvs.: Ubetinget stabil.

<p>
For \( 0\leq \theta \leq \frac{1}{2} \)  er skjemaet betinget stabilt.

<p>
Stabilitetsbetingelsen er da:

$$
\begin{equation} \label{eq:5439}
r(1-2\theta)\leq \frac{1}{2},\ 0\leq \theta \leq 1
\end{equation}
$$

<p>
<b>Bruk av derivasjon</b>

<p>
Vi skriver nå:

$$
\begin{equation*}
\begin{array}{l}
G=1+r(e^{i\delta}+e^{-i\delta}-2)\cdot(G\theta +1 -\theta)=1+2r\big(\cos(\delta)-1\big)\cdot(G\theta+1-\theta)\\ 
\dfrac{dG}{d\delta}=2r\left[(G\theta+1-\theta)\dfrac{d}{d\delta}\big(\cos(\delta)-1\big)+\big(\cos(\delta)-1\big)\theta\cdot \dfrac{dG}{d\delta}\right]
\end{array}
\end{equation*}
$$

<p>
Med \( \dfrac{dG}{d\delta}=0 \)  får vi igjen max-min for \( \delta =0,\ \delta=\pm\pi \)  (\( \delta=0 \)  gir \( G=1 \)  som ventet) \( \delta= \pm \delta \) gir 
\( G=\dfrac{1-4r(1-\theta)}{1+4r\theta} \) som er identisk med \eqref{eq:5438} innsatt for \( \frac{\delta}{2}=90^\circ \). Betingelsen \( |G|\leq1 \)  blir 
\( -1\leq \dfrac{1-4r(1-\theta)}{1+4r\theta}\leq1 \)  med samme resultat som tidligere.

<p>
<b>Nøyaktighet</b>

<p>
La oss se nærmere på nøyaktigheten av  -skjemaet som gitt i \eqref{eq:5437a}.

<p>
Skriver et enkelt Maple-program

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">&gt; eq1:= u(x+h,t+k) - 2*u(x,t+k) + u(x-h,t+k):
&gt; eq2:= u(x+h,t) - 2*u(x,t) + u(x-h,t):
&gt; eq:=  (u(x,t+k) - u(x,t))/k -(theta*eq1 + (1-theta)*eq2)/h^2:
&gt; Tnj:= mtaylor(eq,[h,k]):
&gt; Tnj:= simplify(Tnj):
&gt; Tnj:= convert(Tnj,diff);
</pre></div>
<p>
Vi har her brukt  \( h=\Delta x  \) og \( k=\Delta t \). \( Tnj \) er trunkeringsfeilen som er mer detaljert behandlet i avsnitt (<a href="#ch5:sec5">Trunkeringsfeil, konsistens og konvergens</a>). Anta nå at 
\( u(x,t) \)  er den analytiske løsningen av diff.-ligningen \( \dfrac{\partial u}{\partial t}=\dfrac{\partial ^2 u}{\partial x^2} \)  slik at vi kan sette 
\( \dfrac{\partial}{\partial t}()=\dfrac{\partial^2}{\partial x^2} \)  osv. Dersom vi bruker
disse relasjonene i utskriften av \( Tnj \), får vi følgende resultat: 
<!-- %% div maple skrift -->

$$
\begin{equation} \label{eq:54310}
T^n_j=\left[\bigg(\frac{1}{2}-\theta\bigg)\cdot \Delta t-\frac{1}{12}(\Delta x)^2\right]\cdot \frac{\partial^4u}{\partial x^4}+\frac{1}{6}(\Delta t)^2(1-3\theta)\cdot \frac{\partial^6u}{\partial x^6}+\dots
\end{equation}
$$

<p>
Vi ser at \( T^n_j=O(\Delta t)+O(\Delta x)^2 \)  for \( \theta=0 \) og 1, altså for henholdsvis Euler-skjemaet og Laasonen-skjemaet, mens 
\( T^n_j=O(\Delta t)^2+O(\Delta x)^2 \)  for \( \theta=\frac{1}{2} \) som er Crank-Nicolson skjemaet.

<p>
Dersom vi legger til en linje 
<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Tnj:= simplify(subs(theta =(1-h^2/(6*k))/2,Tnj));
</pre></div>
<p>
i programmet ovenfor, finner vi at  \( T^n_j=O(\Delta t)^2+O(\Delta x)^4 \) dersom vi velger \( r=\dfrac{1}{6(1-2\theta)} \)  når 
\( r\leq \dfrac{1}{2(1-2\theta)} \).

<p>
<b>Mer om stabiliteten.</b>

<p>
Vi har funnet at skjemaet er ubetinget stabilt for \( \frac{1}{2}\leq \theta \leq 1 \). I praksis viser det seg at skjemaet kan gi oscillasjoner rundt 
diskontinuiteter for \( \theta=\frac{1}{2} \). En  \( \theta \)-verdi \( > 0.5 \) vil dempe disse oscillasjonene og denne dempningen er sterkest for  \( \theta=1 \). 
La oss se på et eksempel der vi bruker varmeledningsligningen på dimensjonell form.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 85:  <div id="fig:513"></div> </p></center>
<p><img src="fig-ch5/13.png" align="bottom" width=400></p>
</center>

<p>
Figuren viser en tynn aluminiumstang med lengde 300 mm.

<p>
Varmeledningsligningen er som vanlig gitt ved:

$$
\begin{equation*}
\frac{\partial T}{\partial t}=\alpha \frac{\partial^2T}{\partial x^2},\ T=T(x,t)
\end{equation*}
$$

<p>
Randbetingelser:

$$
\begin{equation*}
T(0,t)=T(300, t)=20^\circ C
\end{equation*}
$$

<p>
Startbetingelser:

$$
\begin{equation*}
\begin{array}{l}
T(x,0)=270^\circ C\text{ for } x\in (100,200)\\ 
T(x,0)=20^\circ C\text{ for } x\in (0,100) \text{ og } x\in(200,300)
\end{array}
\end{equation*}
$$

<p>
Termisk diffusivitet:

$$
\begin{equation*}
\alpha =100 mm^2/s
\end{equation*}
$$

<p>
Det numeriske Fourier-tallet:

$$
\begin{equation*}
r=\alpha \frac{\Delta t}{(\Delta x)^2}
\end{equation*}
$$

<p>
Velger \( \Delta t=0.25 \) s  slik at \( \Delta x=5/\sqrt{r} \). Ved å velge \( r=4 \), får vi \( \Delta x = 2.5 \) mm. Figurene på neste side viser en beregning med 
\( \theta= \frac{1}{2} \)  og en med \( \theta=1 \); altså Crank-Nicolson skjemaet og Laasonen-skjemaet.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 86:  <div id="fig:514"></div> </p></center>
<p><img src="fig-ch5/14.png" align="bottom" width=400></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 87:  <div id="fig:515"></div> </p></center>
<p><img src="fig-ch5/15.png" align="bottom" width=400></p>
</center>

<p>
Vi ser at C-N-skjemaet gir kraftige oscillasjoner ved diskontinuitetene \( x=100 \) of \( x=200 \) for startprofilet. Etter \( t=4 \) s  er disse oscillajonene 
nesten borte. For Laasonen-skjemaet har vi ingen oscillasjoner selv rundt \( t=0 \). For å finne årsaken til dette, må vi gå tilbake til lign. \eqref{eq:5438}:

$$
\begin{equation*}
G=\frac{1-4r(1-\theta)\sin^2(\frac{\delta}{2})}{1+4r\sin^2(\frac{\delta}{2})}
\end{equation*}
$$

<p>
For \( \theta=\frac{1}{2} \)  får vi:

$$
\begin{equation*}
G=\frac{1-2r\sin^2(\frac{\delta}{2})}{1+2r\sin^2(\frac{\delta}{2})}
\end{equation*}
$$

<p>
For \( \delta \)  i nærheten av  \( \pi \), vil \( G \) ligge rundt  \( -1 \) for store verdier av \( r \).
Dette ser vi tydeligst ved å velge \( \delta = \pi=\beta \cdot h \)  som gir  \( G=\dfrac{1-2r}{1+2r} \).

<p>
Fra \eqref{eq:53010b} har vi:

$$
\begin{equation*}
E^n_j=G^n\cdot E^0_j,\ E^0_j=e^{i\cdot \beta x_j}
\end{equation*}
$$

<p>
Derfor ser vi at vi vil få oscillasjoner for \( \delta \)  i nærheten av \( \pi \). Disse høye bølgetallene vil dø ut for økende \( t \) fordi startprofilet 
blir utglattet av dissipasjonen. Dersom vi setter \( r=4 \)  som brukt i eksemplet, vil vi etter 16 tidsteg med  $\Delta t=0.25$s få  
\( G^{16}=\left(-\dfrac{7}{8}\right)^{16}\approx 0.12 \), mens vi med \( r=1 \)  ville fått  \( G^{16}=2.3\cdot 10^{-8} \). Dette betyr at de høye bølgetallene 
avtar langsomt for store verdier av \( r \). Mye likt Gibbs-fenomenet ved Fourierutvikling av diskontinuerlige funksjoner. (Se appendiks A.3, 
tilfelle 1 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>).

<p>
For Laasonen-skjemaet med \( \theta=1 \)  får vi derimot:

$$
\begin{equation*}
G=\dfrac{1}{1+4r\sin^2\left(\dfrac{\delta}{2}\right)}
\end{equation*}
$$

<p>
Vi får her ingen oscillasjoner for noen av bølgetallene.

<p>
Dersom vi bruker uttrykk fra stabilitet av ordinære differential-ligninger, kan vi si at  \( \theta \)-skjemaet er absolutt stabilt (A-stabilt) for  
\( \theta=\frac{1}{2} \) og strengt absolutt stabilt (eller \( L \)-stabilt) for \( \theta=1 \) . (Se avsnitt 1.6.1 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>)

<p>
Dersom vi bruker  \( \theta \)-skjemaet på et varmeledningsproblem  av den typen som vist ovenfor med foreskrevet temperatur på begge rendene 
(Dirichlet-betingelser), vet vi at den maksimale temperaturen til enhver tid må ligge mellom den største som er gitt i startprofilet og den minste 
som er gitt på randen, eller \( T_{min}\leq T^n_j\leq T_{max} \). For eksemplet ovenfor, er  \( T_{min}=20^\circ C \) og \( T_{max}=270^\circ C \). Men da 
oppfyller vi kravene til PK-kriteriet .

<p>
Skriver \eqref{eq:5437a} løst med hensyn på \( u_j^{n+1} \):

$$
\begin{equation} \label{eq:54311}
u^{n+1}_j=\frac{1}{1+2\theta r}\left[\theta r(u^{n+1}_{j-1}+u^{n+1}_{j+1})+(1-\theta) r(u^{n}_{j-1}+u^{n}_{j+1}) +\big(1-(1-\theta) 2r \big)\right]
\end{equation}
$$

<p>
Ved å summere koeffisientene på høyre side, finner vi at summen er lik 1. Deretter må vi forlange at koeffisientene er positive. Dette betyr at 
\( 0 < \theta < 1 \) og \( 1-(1-\theta)\cdot 2r > 0 \). Den siste ulikheten er oppfylt for \( r\cdot(1-\theta) < \frac{1}{2} \). Ved å sette \( \theta=0 \) og 
\( \theta=1 \), finner vi at summen er lik 1 også for disse verdiene, slik at vi får følgende betingelse for oppfyllelse av PK-kriteriet:

$$
\begin{equation} \label{eq:54312}
r\cdot (1-\theta)\leq \frac{1}{2}
\end{equation}
$$

<p>
Fra von Neumann-analysen fant vi følgende betingelse fra \eqref{eq:5439}:

$$
\begin{equation} \label{eq:54313}
r\cdot (1-2\theta)\leq \frac{1}{2}
\end{equation}
$$

<p>
Vi ser at \eqref{eq:54312} er vesentlig strengere enn \eqref{eq:54313}. Mens C-N-skjemaet med \( \theta=\frac{1}{2} \) er ubetinget stabil i følge 
von Neumann-analysen, må vi ha \( r\leq 1 \) ifølge PK-kriteriet. PK-kriteriet gir her en sikker betingelse forat det fysiske max-min-kriteriet også 
oppfylles for differanseligningen. En test med eksemplet ovenfor, bekrefter dette kriteriet. Finnes det da et kriterium som er både nødvendig og 
tilstrekkelig for dennne enkle modell-ligningen? Kraaijevanger fant i 1992 følgende nødvendige og tilstrekkelige kriterium:

$$
\begin{equation} \label{eq:54314}
r\cdot (1-\theta)\leq \frac{2-\theta}{4(1-\theta)}
\end{equation}
$$

<p>
Vi ser at for \( \theta = \frac{1}{2} \)  gir dette kriteriet betingelsen \( r\leq \frac{3}{2} \). For \( \theta = \frac{3}{4} \)  gir \eqref{eq:54314} \( r\leq 5 \)  
mens PK-kriteriet gir  \( r\leq 2 \).

<p>
Hensikten med store \( r \)-verdier er for å kunne bruke forholdsvis store tidskritt når vi ønsker å følge hele tidsforløpet mot en stasjonær tilstand. 
Men vi må selvfølgelig tenke på nøyaktigheten også. Husk dessuten at dette er en enkel endimensjonal differanseligning med konstante koeffisienter som
kan løses meget raskt med en moderne PC nærmest uavhengig at \( \Delta t \) og \( \Delta x \)  så lenge vi holder oss innfor stabilitetsområdet. Ikke-stasjonære 
problem i tre dimensjoner krever fremdeles mye regnetid.

<p>
<!-- !split -->

<h2 id="ch5:sec44">Von Neumanns generelle stabilitetsbetingelse</h2>

<p>
Vi har omtalt stabilitetsbetingelsen \( |G|\leq1 \) som von Neumanns strenge stabilitetsbetingelse. Årsaken til denne betegnelsen, er at dersom \( |G|\leq 1 \)  
er oppfylt, kan ikke amplituden øke. I mange tilfeller har vi selvfølgelig fysikalske problemer der amplituden vokser med \( t \). ( \( t \) begrenset ). Et 
enkelt eksempel er varmeledningsligningen med et kildeledd:

$$
\begin{equation} \label{eq:54415}
\frac{\partial T}{\partial t}= \alpha\frac{\partial^2 T}{\partial x^2}+bT,\ b= \text{konstant},\ t < t_{maks}
\end{equation}
$$

<p>
Med \( b < 0 \)  har vi et varmesluk, mens for \( b > 0 \)  har vi en varmekilde. I det første tilfellet kan vi bruke det strenge kriteriet, men for det andre 
tilfellet er det nødvendig å tillate \( |G|>1 \).

<p>
En partikulær løsning av \eqref{eq:54415} er gitt ved:

$$
\begin{equation} \label{eq:54416}
T(x,t)=e^{bt}\cdot e^{-\alpha\beta^2\cdot t}\cos(\beta x)=e^{(b-\alpha\beta^2)\cdot t}\cos(\beta x)
\end{equation}
$$

<p>
La oss bruke \eqref{eq:54416} til å bestemme en analytisk forsterkningsfaktor, se \eqref{eq:5306}:

$$
\begin{equation} \label{eq:54417}
G_a=\frac{T(x_j,\ t_{n+1})}{T(x_j,\ t_n)}=\exp\left[(b-\alpha\beta^2)\cdot t_{n+1}-(b-\alpha\beta^2)\cdot t_n\right]=e^{b\Delta t}\cdot e^{-\alpha\beta^2\Delta t}
\end{equation}
$$

<p>
Vi ser at det er leddet \( e^{b\cdot \Delta t} \)  som får amplituden til å øke med positiv \( b \).

<p>
En rekkeutvikling for små  \( \Delta t \):

$$
\begin{equation} \label{eq:54418}
e^{b\Delta t}=1+b\cdot \Delta t+ \frac{b^2}{2}(\Delta t)^2+\dots
\end{equation}
$$

<p>
Dersom vi bruker FTCS-skjemaet, får vi:

$$
\begin{equation} \label{eq:54419a}
T^{n+1}_{j}=r(T^{n}_{j+1}+T^{n}_{j-1})+(1-2r)T^{n}_{j}+\Delta t bT^{n}_{j}
\end{equation}
$$

<p>
med
$$
\begin{equation} \label{eq:54419b}
r=\alpha \frac{\Delta t}{(\Delta x)^2}
\end{equation}
$$

<p>
Dersom vi bruker PK-kriteriet, finner vi at summen av koeffisientene er lik  \( 1+b\cdot \Delta t \), slik at dette kriteriet bare kan brukes for  \( b < 0 \).

<p>
Får ved å bruke von Neumanns metode på \eqref{eq:54419a}:

$$
\begin{equation} \label{eq:54420}
G=1-4r\sin^2\Big(\frac{\delta}{2}\Big)+\Delta t\cdot b
\end{equation}
$$

<p>
Ved å sette  \( r=\frac{1}{2} \), får vi:

$$
\begin{equation*}
|G|\leq \left|1-2\sin^2\Big(\frac{\delta}{2}\Big)\right|+|\Delta t\cdot b|\leq 1+\Delta t\cdot b,\ b > 0
\end{equation*}
$$

<p>
Dersom vi sammenligner med \eqref{eq:54418}, ser vi at vi får god overenstemmelse mellom den analytiske og den numeriske forsterkningsfaktoren i dette 
tilfellet.

<p>
Innfører von Neumanns generelle betingelsen ved:

$$
\begin{equation} \label{eq:54421}
|G|\leq 1+K\cdot \Delta t
\end{equation}
$$

<p>
der \( K \) er en positiv konstant.

<p>
Dette betyr at vi tillater amplituden å øke eksponentsielt for \( t < t_{maks } \). I dette tilfellet kan vi bruke den strenge betingelsen dersom 
vi resonnerer på følgende måte:

<p>
Da kildeleddet i \eqref{eq:54415} ikke inneholder noen derivert størrelse, kan vi se bort fra dette leddet ved stabilitetsundersøkelsen. Vi har her samme 
type problemstilling som i avsnitt 1.6 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>, der vi diskuterer stive, ordinære differensialligninger. 
(Se f.eks. lign. 
<!-- \eqref{eq:1618} -->
(1.6.8) i avsnitt 1.6.1 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>).

<p>
For en voksende amplitude må vi minske skrittlengden for den uavhengige variable dersom vi skal oppnå en foreskrevet nøyaktighet. For en minskende 
amplitude må vi derimot holde oss under en maksimum skrittlengde for å få en stabil regneprosess.

<p>
La oss se på et annet eksempel med bruk av FTCS-skjemaet.

$$
\begin{equation} \label{eq:54422}
\frac{\partial u}{\partial t}=\alpha \frac{\partial^2 u}{\partial x^2}+a_0\frac{\partial u}{\partial x},\ \alpha > 0
\end{equation}
$$

<p>
Denne ligningen som kalles adveksjon-diffusjonsligningen, er fremdeles en parabolsk ligning ifølge klassifiseringskjemaet i avsnitt 4.3 i 
<a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>.

<p>
Ved bruk av FTCS-skjemaet på \eqref{eq:54422} med sentraldifferanser for  \( \dfrac{\partial u}{\partial x} \):

$$
\begin{equation*}
u_j^{n+1}=u^n_{j}+r\cdot(u^n_{j+1}-2u^n_{j}+u^n_{j-1})+a_0\frac{\Delta t}{2\Delta x}(u^n_{j+1}-u^n_{j-1}),\ r=\alpha \frac{\Delta t}{(\Delta x)^2}
\end{equation*}
$$

<p>
Bruker von Neumanns metode:

$$
\begin{equation*}
G=1-4r\sin^2\Big(\frac{\delta}{2}\Big) +i\cdot a_0 \frac{\Delta t}{\Delta x}\sin(\delta)
\end{equation*}
$$

<p>
som videre gir:

$$
\begin{equation*}
|G|^2=\left(1-4r\sin^2\Big(\frac{\delta}{2}\Big)\right)^2+\left(a_0\frac{\Delta t}{\Delta x}\sin(\delta)\right)^2=\left(1-4r\sin^2\Big(\frac{\delta}{2}\Big)\right)^2+\frac{a_0^2\cdot r}{\alpha}\cdot \Delta t\sin^2(\delta )
\end{equation*}
$$

<p>
Velger igjen  \( r=\frac{1}{2} \):

$$
\begin{equation*}
|G|=\sqrt{\left(1-2\sin^2\Big(\frac{\delta}{2}\Big)\right)^2+\frac{a_0^2}{2\alpha}\cdot\Delta t\cdot \sin^2(\delta)} \leq 1+\frac{a_0^2}{2\alpha}\cdot \Delta t
\end{equation*}
$$

<p>
Vi har her brukt  \( \sqrt{x^2+y^2}\leq |x|+|y| \)

<p>
Med \( K=\frac{a_0^2}{2\alpha} \), ser vi at den generelle betingelsen i \eqref{eq:54421} er oppfylt.

<p>
Adveksjon-diffusjonsligningen  er behandlet mer detaljert i avsnitt 6.10 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>.
<!-- !split -->

<h1 id="ch5:sec5">Trunkeringsfeil, konsistens og konvergens</h1>

<p>
La \( U(x,t) \) være den eksakte løsningen av en PDL, skrevet  \( L(U)=0 \), og \( u \) den eksakte løsningen av den tilhørende differanseligningen, skrevet
\( F(u)=0 \). Den eksakte løsningen i \( (x_i,\ t_n) \)  er gitt ved:

$$
\begin{equation*}
\begin{array}{r}
U^n_i\equiv U(x_i,t_n)\text{ der }x_i=i\cdot \Delta x=i\cdot h,\ i=0,1,2,\dots\\ 
t_n=n\cdot \Delta t=n\cdot k,\ n=0,1,2,\dots
\end{array}
\end{equation*}
$$

<p>
For den lokale trunkeringsfeilen \( T^n_i \)  får vi da følgende uttrykk:

$$
\begin{equation} \label{eq:5501}
T^n_i=F(U^n_i)-L(U^n_i)=F(U^n_i)
\end{equation}
$$

<p>
\( T^n_i \)  finnes ved Taylor-utvikling.

<p>
Noen rekkeutviklinger:

$$
\begin{equation} \label{eq:5502a}
U^n_{i\pm1}\equiv U(x_{i\pm h},t_n)=U^n_i\pm h\cdot \frac{\partial U}{\partial x}\bigg|^n_i+\frac{h^2}{2}\cdot \frac{\partial^2U}{\partial x^2}\bigg|^n_i\pm \frac{h^3}{6}\cdot \frac{\partial^3U}{\partial x^3}\bigg|^n_i+\dots
\end{equation}
$$


$$
\begin{equation} \label{eq:5502b}
U^{n\pm1}_{i}\equiv U(x_{i},t_{n\pm k})=U^n_i\pm k\cdot \frac{\partial U}{\partial t}\bigg|^n_i+\frac{k^2}{2}\cdot \frac{\partial^2U}{\partial t^2}\bigg|^n_i\pm \frac{k^3}{6}\cdot \frac{\partial^3U}{\partial t^3}\bigg|^n_i+\dots
\end{equation}
$$

<p>
La oss som eksempel finne den lokale trunkeringsfeilen \( T^n_i \)  for FTCS-metoden anvendt på diffusjonsligningen \( L(U)=0 \) der

$$
\begin{equation*}
L(U)=\frac{\partial U}{\partial t}-\frac{\partial^2U}{\partial x^2}=0
\end{equation*}
$$


$$
\begin{equation} \label{eq:5503}
T^n_i=F(U^n_i)=\frac{U^{n+1}_i-U^n_i}{k}-\frac{U^n_{i-1}-2U^n_i+U^n_{i+1}}{h^2}
\end{equation}
$$

<p>
Innsatt fra \eqref{eq:5502a} i \eqref{eq:5503}:

$$
\begin{equation*}
\begin{array}{c}
T^n_i=\left(    \dfrac{\partial U}{\partial t}-\dfrac{\partial^2U}{\partial x^2}\right)^n_i +\left(\dfrac{k}{2}\dfrac{\partial^2U}{\partial t^2}-\dfrac{h^2}{12}\dfrac{\partial^4U}{\partial x^4}\right)^n_i +\dfrac{k^2}{6}\dfrac{\partial^3U}{\partial t^3}\bigg|^n_i+O(k^3,h^4)\\ 
\text{Da } \dfrac{\partial U}{\partial t}-\dfrac{\partial^2U}{\partial x^2}=0
\end{array}
\end{equation*}
$$


$$
\begin{equation} \label{eq:5504}
T^n_i=\left(\dfrac{k}{2}\dfrac{\partial^2U}{\partial t^2}-\dfrac{h^2}{12}\dfrac{\partial^4U}{\partial x^4}\right)^n_i +\text{ høyere ordens ledd}
\end{equation}
$$

<p>
\eqref{eq:5504} viser at \( T^n_i=O(k)+O(h^2) \)  som ventet.

<p>
\eqref{eq:5504} kan også skrives:

$$
\begin{equation*}
T^n_i=\frac{h^2}{12}\cdot\left(6\dfrac{k}{h^2}\dfrac{\partial^2U}{\partial t^2}-\dfrac{\partial^4U}{\partial x^4}\right)^n_i+O(k^2)+O(h^4)
\end{equation*}
$$

<p>
Ved å velge  \( r=\dfrac{k}{h^2}=\dfrac{1}{6} \), får vi:

$$
\begin{equation} \label{eq:5505}
T^n_i=O(k^2)+O(h^4)
\end{equation}
$$

<p>
\( \Delta t \) blir svært liten for \( r=1/6 \), men med dagens PC-er er dette ikke noen problem, bortsett fra eventuell akkumulering av avrundingsfeil.
<!-- (Se også side 211) %%%%% SIDE REFERANSE !!!!!!!!! sideref side ref -->

<p>
<b>Konsistens</b>

<p>
Vi sier at differanseligningen er konsistent med den gitte differensial-ligningen dersom den lokale trunkeringsfeilen \( T^n_i\to 0 \) når \( \Delta x \) og 
\( \Delta t\to 0 \) uavhengig av hverandre.

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">

<h2 id="___sec94">Example </h2>

<p>
Fra \eqref{eq:5504}

$$
\begin{equation*}
T^n_i=\left(\dfrac{k}{2}\dfrac{\partial^2U}{\partial t^2}-\dfrac{h^2}{12}\dfrac{\partial^4U}{\partial x^4}\right)^n_i \to 0 \text{ for } h \text{ og } k\to 0
\end{equation*}
$$

<p>
Dette betyr at FTCS -skjemaet er konsistent med diffusjonsligningen .

<p>
</div>
<!-- end box -->


<p>
<br />

<p>
La oss se nærmere på DuFort-Frankel skjemaet fra avsnitt (<a href="#ch5:sec42">Dufort-Frankel skjemaet (1953)</a>):

$$
\begin{equation*}
T^n_i=\dfrac{U_i^{n+1}-U^{n-1}_i}{2k}-\dfrac{\left[U_{i-1}^n+U_{i+1}^n-(U^{n+1}_i+U_i^{n-1})    \right]}{h^2}
\end{equation*}
$$

<p>
Med bruk av rekkeutviklingene i \eqref{eq:5502a} og \eqref{eq:5502b}:

$$
\begin{equation} \label{eq:5506}
T^n_i=\left[ \frac{\partial U}{\partial t}-\frac{\partial^2 U}{\partial x^2}+\left(\frac{k}{h}\right)^2\frac{\partial^2U}{\partial t^2} \right]^n_i+\left[ \frac{k^2}{6}\frac{\partial^3U}{\partial t^3}-\frac{h^2}{12}\frac{\partial^4U}{\partial x^4}\right]^n_i + O\left(\frac{k^4}{h^2},k^4,h^4\right)
\end{equation}
$$

<p>
P.g.a faktoren \( \left(\dfrac{k}{h}\right)^2 \)  er det viktig å spesifisere hvordan \( k \) og \( h\to0 \). Skjemaet er ikke uten videre konsistent med den gitte 
ligningen. Et slikt skjema betegnes gjerne som betinget konsistent.

<p>
<b>Tilfelle 1</b>

<p>
Setter  \( r_0=\dfrac{k}{h}\to k=r_0\cdot h,\ r_0 \)  en konstant \( >  \) 0.

<p>
Innsatt for \( k \) i \eqref{eq:5506}:

$$
\begin{equation*}
T^n_i=\left( \frac{\partial U}{\partial t}-\frac{\partial^2U}{\partial x^2}+r_0^2\cdot \frac{\partial^2U}{\partial t^2} \right)^n_i+O(h^2)
\end{equation*}
$$

<p>
For \( h\to0 \), ser vi at DuFort-Frankel skjemaet  nå er konsistent med den hyperbolske ligningen 
\( \dfrac{\partial U}{\partial t}+r_0^2 \dfrac{\partial^2U}{\partial t^2}=\dfrac{\partial^2U}{\partial x^2} \)  og ikke den opprinnelige diffusjonsligningen.

<p>
<b>Tilfelle 2</b>

<p>
Setter \( r_0=\dfrac{k}{h^2}\to k =r_0\cdot h^2 \). Innsatt for \( k \) i \eqref{eq:5506}:

$$
\begin{equation*}
\begin{array}{ll}
T^n_i&=\left[\frac{\partial U}{\partial t}-\frac{\partial^2U}{\partial x^2} \right]^n_i+\left[r_0^2h^2\frac{\partial^2U}{\partial t^2}+ \frac{k^2}{6}\frac{\partial^3U}{\partial t^3}-\frac{h^2}{12}\frac{\partial^4U}{\partial x^4}\right]^n_i+O\left(\frac{k^4}{h^2},k^4,h^4\right)\\ 
&= \left[ r_0^2h^2 \frac{\partial^2U}{\partial t^2}+\frac{k^2}{6}\frac{\partial^3U}{\partial t^3}-\frac{h^2}{12}\frac{\partial^4U}{\partial x^4}\right]^n_i+O\left(r_0^4h^6,\ k^4,\ h^4 \right)\\ 
\end{array}
\end{equation*}
$$


$$
\begin{equation*}
\text{da } \left[ \frac{\partial U}{\partial T}-\frac{\partial^2U}{\partial x^2}\right]^n_i=0
\end{equation*}
$$

<p>
Vi ser at  \( T^n_i\to 0 \) for \( h \) og  \( t\to0 \) med \( T^n_i=O(k^2)+O(h^2) \).

<p>
Skjemaet er nå konsistent med diffusjonsligningen. D-F-skjemaet kan derfor brukes med \( k=r_0\cdot h^2 \). Men da har vi fått en begrensning på  
\( \Delta t \), ikke som et stabilitetskrav, men ved kravet til konsistens. Ikke-konsistente skjema oppstår vanligvis når vi trikser med skjemaene etter 
at vi har Taylor-utviklet dem på vanlig måte.

<p>
<b>Konvergens</b>

<p>
Med \( U \) som den eksakte løsningen av differensialligningen og \( u \) som den eksakte løsningen av den tilhørende differanseligningen, sier vi at 
differanseligningen er konvergent dersom

$$
\begin{equation*}
\lim_{\Delta x, \Delta t \to 0} \to U \text{ for gitt $t_n$ og $x_i$}
\end{equation*}
$$

<p>
Det er generelt vanskelig å bevise konvergensen  av et differanseskjema. Derfor har det vært gjort mange forsøk på å erstatte definisjonen ovenfor med 
betingelser som er lettere å bevise hver for seg, men som tilsammen er tilstrekkelig for konvergens.

<p>
Det mest kjente av disse teoremene er <em>Lax's teorem</em>:

<p>
<div class="alert alert-block alert-success alert-text-normal"><b></b>
Dersom det lineære initialverdiproblemet er velformulert og den tilhørende differanseligningen er konsistent, er stabilitet en nødvendig og tilstrekkelig 
betingelse for konvergens.
</div>


<p>
Se avsnitt 4.3 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a> angående begrepet velformulert. Når vi ser alle betingelsene 
som må oppfylles forat Lax's teorem skal kunne anvendes, skjønner vi vanskelighetene med å bevise konvergens i mer generelle problemstillinger.
<!-- !split -->

<h1 id="ch5:sec6">Eksempler med radiell symmetri</h1>

<p>
Dersom vi transformerer diffusjonsligningen 
\( \frac{\partial u}{\partial t}=\frac{\partial^2 u}{\partial x^2}+\frac{\partial^2 u}{\partial y^2}+\frac{\partial^2 u}{\partial z^2} \)  til henholdsvis 
sylinder- og kule-koordinater og forlanger at \( u \) bare skal være funksjon av tiden \( t \) og radien \( r \), får vi:

<p>
Sylinder:

$$
\begin{equation*}
\frac{\partial u}{\partial t}= \frac{\partial^2 u}{\partial r^2}+\frac{1}{r}\frac{\partial u }{\partial r}
\end{equation*}
$$

<p>
Kule:

$$
\begin{equation*}
\frac{\partial u}{\partial t}= \frac{\partial^2 u}{\partial r^2}+\frac{2}{r}\frac{\partial u }{\partial r}
\end{equation*}
$$

<p>
Ligningene kan da skrives:

$$
\begin{equation} \label{eq:5601}
\frac{\partial u}{\partial t}= \frac{\partial^2 u}{\partial r^2}+\frac{\lambda}{r}\frac{\partial u }{\partial r},\ \lambda=0,1,2
\end{equation}
$$

<p>
\( \lambda=0 \) med \( r\to x \)  gir det velkjente kartesiske tilfellet.

<p>
\eqref{eq:5601} er en partiell diff. ligning med variable koeffisienter. Vi vil nå forsøke en von Neumann-analyse av denne ligningen med  
\( \theta \)-skjemaet fra avsnitt (<a href="#ch5:sec43">Crank-Nicolson skjemaet. \( \theta \)-skjemaet</a>).

<p>
<b>Stabilitetsanalyse med bruk av</b>  \( \theta \) <b>-skjemaet for radius</b> \( r > 0  \)

<p>
Setter \( r_j=\Delta r\cdot j,\ j=0,1,\dots \)  og innfører \( D=\frac{\Delta t}{(\Delta r)^2} \)

<p>
For \( r > 0 \):

$$
\begin{equation} \label{eq:5602}
\begin{array}{ll}
u^{n+1}_j=      &u^n_j+D\left[\theta(u^{n+1}_{j+1}-2u_j^{n+1}+u^{n+1}_{j-1})+(1-\theta)(u^n_{j+1}-2u^n_j+u^n_{j-1})\right]\\ 
\\ 
                &+\frac{\lambda D}{2j} \left[\theta(u^{n+1}_{j+1}-u^{n+1}_{j-1})+(1-\theta)(u^n_{j+1}-u^n_{j-1}) \right]
\end{array}
\end{equation}
$$

<p>
Utførerer en von Neumann-analyse ved å sette inn \( E^n_j=G^n\cdot e^{i\cdot \beta r_j}=G^ne^{i\cdot \delta\cdot j } \) med \( \delta=\beta\cdot \Delta r \) 
og bruk av de vanlige formlene  \eqref{eq:53114} og \eqref{eq:53115}.

<p>
Vi får:

$$
\begin{equation*}
G\cdot \left( 1+4\theta D\sin^2\Big(\frac{\delta}{2}\Big)-i\cdot \frac{\theta\lambda D}{j}\sin(\delta)\right)=1-4(1-\theta)D\cdot \sin^2\Big(\frac{\delta}{2}\Big) +i \frac{(1-\theta)\lambda D}{j}\sin(\delta)
\end{equation*}
$$

<p>
som ved bruk av formelen \( \sin(\delta)=2\sin\Big(\dfrac{\delta}{2}\Big)\cos\Big(\dfrac{\delta}{2}\Big) \)  og betingelsen \( |G|\leq1 \) blir:

$$
\begin{equation*}
\left(  1-4(1-\theta) D\sin^2\Big(\frac{\delta}{2}\Big)\right)^2+\frac{(1-\theta)^2\lambda^2D^2}{j^2}\sin^2(\delta)\leq \left(1+4\theta D\sin^2\Big(\frac{\delta}{2}\Big) \right)^2 +\frac{\theta^2\lambda^2D^2}{j^2}\sin^2(\delta)
\end{equation*}
$$

<p>
og som videre gir:

$$
\begin{equation} \label{eq:5603}
D\cdot(1-2\theta)\cdot \left( \sin^2\Big(\frac{\delta}{2}\Big)\cdot\Big(4-\frac{\lambda^2}{j^2}\Big)+\frac{\lambda^2}{j^2} \right)\leq 2,\ j\geq1
\end{equation}
$$

<p>
Det er ikke vanskelig å se at leddet i parentesen har sin største verdi for \( \sin^2\Big(\dfrac{\delta}{2}\Big)=1 \); dvs. for \( \delta = \pi \). 
(Kan også finnes ved å derivere leddet m.h.p. \( \delta \) som gir maksimum for \( \delta = \pi \)). Faktoren \( \dfrac{\lambda^2}{j^2} \)  faller da ut.

<p>
Vi får:

$$
\begin{equation} \label{eq:5604}
D\cdot (1-2\theta)\cdot 2\leq 1
\end{equation}
$$

<p>
Som i avsnitt (<a href="#ch5:sec43">Crank-Nicolson skjemaet. \( \theta \)-skjemaet</a>), må vi skille mellom to tilfeller.

<p>
<b>1</b>.
$$
\begin{equation*} 
0\leq \theta  \leq \frac{1}{2}
\end{equation*}
$$


$$
\begin{equation} \label{eq:5605}
D= \frac{\Delta t}{(\Delta r)^2} \leq \frac{1}{2(1-2\theta)}
\end{equation}
$$

<p>
<b>2</b>.
$$
\begin{equation*} 
\frac{1}{2}\leq \theta \leq 1
\end{equation*}
$$

<p>
Skifter fortegn i \eqref{eq:5604}:

$$
\begin{equation*}
D\cdot (2\theta-1)\cdot 2 \geq -1
\end{equation*}
$$

<p>
Denne betingelsen er alltid oppfylt, slik at differanseligningen er ubetinget stabil for disse  \( \theta \)-verdiene.

<p>
Vi har med andre ord fått de samme stabilitetsbetingelsene som for ligningen med konstante koeffisienter: 
\( \dfrac{\partial u}{\partial t}=\dfrac{\partial^2u}{\partial r^2} \)  der vi har FTCS-skjemaet for \( \theta=0 \), Crank-Nicolson-skjemaet for  \( \theta=1/2 \), 
og Laasonen-skjemaet for  \( \theta=1 \).

<p>
Merk at denne analysen bare gjelder for \( r > 0 \).

<p>
Vi må da se på ligningen for \( r=0 \).

<p>
Leddet \( \dfrac{\lambda}{r}\dfrac{\partial u}{\partial r} \)  må behandles spesielt for \( r=0 \).

<p>
L'Hospitals regel:

$$
\begin{equation} \label{eq:5606}
\lim_{x\to 0}\frac{\lambda}{r}\frac{\partial u}{\partial r} = \lambda \frac{\partial^2u}{\partial r^2}\to \frac{\partial u}{\partial t}= (1+\lambda)\frac{\partial^2u}{\partial r^2} \text{ for }r=0
\end{equation}
$$

<p>
Vi har funnet at ved bruk av FTCS-skjemaet, har vi den vanlige begrensningen  \( D\leq 1/2 \). La oss derfor undersøke om randbetingelsene gir begrensninger 
når vi bruker FTCS-skjemaet.

<p>
<b>Versjon 1</b>

<p>
Diskretiserer \eqref{eq:5606} for \( r=0 \)  og utnytter symmetribetingelsen  \( \frac{\partial u}{\partial r}(0)=0 \):

$$
\begin{equation} \label{eq:5607}
u^{n+1}_0=[1-2(1+\lambda)D]\cdot u_0^n+2(1+\lambda)D\cdot u^n_1
\end{equation}
$$

<p>
Dersom vi bruker PK-kriteriet på \eqref{eq:5607}, får vi: 
$$
\begin{equation} \label{eq:5608}
D\leq \frac{1}{2(1+\lambda)}
\end{equation}
$$

<p>
For \( \lambda = 0 \)  får vi den velkjente betingelsen \( D\leq 1/2 \), mens vi for sylinderen med \( \lambda=1 \)  får \( D\leq 1/4 \) og for kule med \( \lambda =2 \) 
får \( D\leq 1/6 \). Spørsmålet er om disse betingelsen for sylinder og kule er nødvendige. Vi vet at  \( D\leq 1/2 \) er både tilstrekkelig og nødvendig for 
\( \lambda=0 \).

<p>
Det er vanskelig å finne et nødvendig og tilstrekkelig kriterium i dette tilfellet. Ser derfor på et eksempel med oppstart av strømning i et rør, 
gitt som eksempel (<a href="#ex:51">Example: Oppstart av rørstrømning</a>).

<p>
<b>Versjon 2</b>

<p>
For å unngå å bruke en separat ligning for \( r=0 \) , diskretiserer vi symmetribetingelsen \( \dfrac{\partial u}{\partial r}(0)=0 \)  med 2. ordens 
foroverdifferanser:

$$
\begin{equation} \label{eq:5609}
\frac{\partial u }{\partial r}(0)=0\to \frac{-3u_0^n+4u^n_1-u_2^n}{2\Delta r}\to u^n_0=\frac{1}{3}(4u_1^n-u_2^n)
\end{equation}
$$

<p>
For kula finnes det en detaljert analyse av Dennis Eisen i tidskriftet Numerische Mathematik vol. 10, 1967, side 397-409. Han viser at 
<!-- %%% bokreferanse bok ref tidskrift -->
en nødvendig og tilstrekkelig betingelse for løsning av \eqref{eq:5602} sammen med \eqref{eq:5607} (for \( \lambda = 2 \) og \( \theta = 0 \)) er at  \( D < 1/3 \). 
Dessuten viser han at ved å unngå å bruke \eqref{eq:5607}, får vi stabilitet for FTCS-skjemaet når \( D < 1/2 \).

<p>
Vi beregner nå to tilfeller for å se hvilke stabilitetskrav vi får i praksis når vi bruker begge versjonene av randbetingelsene.

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">

<h2 id="ex:51">Example: Oppstart av rørstrømning</h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 88:  <div id="fig:516"></div> </p></center>
<p><img src="fig-ch5/16transp.png" align="bottom" width=400></p>
</center>

<p>
Figuren viser hastighetsprofilet ved strømning i et rør av en inkompressibel fluid ved et gitt tidspunkt. Vi tenker oss at profilet har utviklet seg fra 
null ved å sette på en konstant trykkgradient \( \frac{dp}{dz} < 0 \), slik at hastighetsprofilet for det stasjonære tilfellet er det velkjente parabolske 
profilet for Poiseuille-strømning.

<p>
Bevegelsesligning:

$$
\begin{equation} \label{eq:56010}
\frac{\partial U}{\partial \tau}= -\frac{1}{\rho}\frac{dp}{dz}+\nu \left( \frac{\partial^2 U}{\partial R^2}+\frac{1}{R}\frac{\partial U}{\partial R} \right)
\end{equation}
$$

<p>
der hastighetsprofilet \( U=U(R,\ \tau).\ 0\leq R \leq R_0, \)  og \( \tau \)  er den fysikalske tiden.

<p>
Dimensjonsløse variable:

$$
\begin{equation} \label{eq:56011}
t=\nu \frac{\tau}{R^2_0},\ r= \frac{R}{R_0},\ u = \frac{U}{k},\ u_s= \frac{U_s}{k} \text{ der } k=-\frac{R_0^2}{4\mu}\frac{dp}{dz}
\end{equation}
$$

<p>
som innført i \eqref{eq:56010} gir:

$$
\begin{equation} \label{56012a}
\frac{\partial u}{\partial t }=4+ \frac{\partial^2u}{\partial r^2}+ \frac{1}{r}\frac{\partial u}{\partial r}
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{equation} \label{56012b}
u(\pm1,t)=0,\ \frac{\partial u}{\partial r}(0,t)=0
\end{equation}
$$

<p>
Den siste er en symmetribetingelse. Finner stasjonær løsning \( u_s \)  for  \( \frac{\partial u}{\partial t}=0 \):

$$
\begin{equation*}
\frac{d^2u_s}{dr^2}+\frac{1}{r}\frac{du_s}{dr}=-4 \to \frac{1}{r}\frac{d}{dr}\left( r \frac{du_s}{dr}\right)=-4\text{ som gir:}
\end{equation*}
$$


$$
\begin{equation*}
\frac{du_s}{dr}=-2r+\frac{C_1}{r} \text{ med } C_1=0 \text{ da } \frac{du_s(0)}{dr}=0
\end{equation*}
$$

<p>
Etter en ny integrasjon og bruk av randbetingelsene, får vi den velkjente parabolske hastighetsfordelingen:

$$
\begin{equation} \label{eq:56013}
u_s=1-r^2
\end{equation}
$$

<p>
Vi antar nå at vi har et tilfelle med fullt utviklet profil som gitt i \eqref{eq:56013}. Plutselig fjerner vi trykkgradienten. Fra \eqref{eq:56010} ser 
vi at dette gir en enklere ligning. Hastigheten \( \omega(r,t) \)  for dette tilfellet er gitt ved:

$$
\begin{equation} \label{eq:56014}
\omega(r,t)=u_s-u(r,t)\text{ med } \omega = \frac{W}{k}
\end{equation}
$$

<p>
Vi skal nå løse følgende problem:

$$
\begin{equation} \label{eq:56015a}
\frac{\partial \omega}{\partial t}= \frac{\partial^2\omega}{\partial r^2}+ \frac{1}{r} \frac{\partial \omega}{\partial r}
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{equation} \label{eq:56015b}
\omega(\pm1,t)=0,\ \frac{\partial \omega}{\partial r}(0,t)=0
\end{equation}
$$

<p>
Startbetingelse:

$$
\begin{equation} \label{eq:56015c}
\omega(r,0)=u_s=1-r^2
\end{equation}
$$

<p>
Det opprinnelige problemet er da:

$$
\begin{equation} \label{eq:56016}
u(r,t)=1-r^2-\omega(r,t)
\end{equation}
$$

<p>
Den analytiske løsningen av \eqref{eq:56015a}, \eqref{eq:56016}, først gitt av Szymanski i 1932, finnes
i appendiks G.8 i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a>.

<p>
La oss se spesielt på FTCS-skjemaet.

<p>
Fra \eqref{eq:5602}, med \( \lambda = 1 \),  \( \theta =0 \) og  \( j\geq0 \):

$$
\begin{equation} \label{eq:56017a}
\omega_j^{n+1}=\omega^n_j+D\cdot(\omega^n_{j+1}-2\omega^n_j+\omega^n_{j-1})+\frac{D}{2j}\cdot (\omega^n_{j+1}-\omega^n_{j-1})
\end{equation}
$$

<p>
For  \( j=0 \) får vi fra \eqref{eq:5607}:

$$
\begin{equation} \label{eq:56017b}
\omega_0^{n+1}=(1-4D)\cdot \omega^n_0+4D\cdot \omega^n_1
\end{equation}
$$

<p>
Fra \eqref{eq:5605} får vi stabilitetsintervallet \( 0 < D\leq \frac{1}{2} \)  for \( r > 0 \)  og \( 0 < D\leq \frac{1}{4} \)

<p>
fra \eqref{eq:5608} for \( r=0 \)  som er en tilstrekkelig betingelse.

<p>
Ved å løse \eqref{eq:56017a}, får vi følgende tabell for stabilitetsgrensa:

<p>

<div class="row">
  <div class="col-xs-2">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="left">\( \Delta r \)</td> <td align="left"><b>  D  </b></td> </tr>
</thead>
<tbody>
<tr><td align="left">   0.02              </td> <td align="left">   0.413    </td> </tr>
<tr><td align="left">   0.05              </td> <td align="left">   0.414    </td> </tr>
<tr><td align="left">   0.1               </td> <td align="left">   0.413    </td> </tr>
<tr><td align="left">   0.2               </td> <td align="left">   0.402    </td> </tr>
<tr><td align="left">   0.25              </td> <td align="left">   0.394    </td> </tr>
<tr><td align="left">   0.5               </td> <td align="left">   0.341    </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-2 -->
<p>
For tilfredstillende nøyaktighet bør vi her ha  \( \Delta r \leq 0.1 \). Av tabellen ovenfor ser vi at da er betingelsen \( D < 0.4 \)  er tilstrekkelig. 
Med andre ord en slags midlere verdi av  \( D=\frac{1}{2} \) og \( D=\frac{1}{4} \).

<p>
Det er ligningen i \eqref{eq:56017b} som skaper problemer. Vi kan unngå denne ved isteden å bruke \eqref{eq:5609}:

$$
\begin{equation} \label{eq:56018}
\omega^n_0=\frac{1}{3}(4\omega^n_1-\omega^n_2),\ n=0,1,\dots
\end{equation}
$$

<p>
Beregningen viser da at grensa for hele systemet er gitt ved \( 0 < D\leq \frac{1}{2} \)  for FTCS-skjemaet. Figuren nedenfor viser \( u \)-profilet for \( D=0.45 \)  
med \( \Delta r=0.1 \) etter 60 tidskritt med bruk av \eqref{eq:56017b}. Tydelig utvikling av instabilitet for  \( r=0 \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 89:  <div id="fig:517"></div> </p></center>
<p><img src="fig-ch5/17transp.png" align="bottom" width=400></p>
</center>

<p>
<b>Programmering av  \( \theta \)-skjemaet</b>:

<p>
<b>Randbetingelse gitt i</b> \eqref{eq:56017b}

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 90:  <div id="fig:518"></div> </p></center>
<p><img src="fig-ch5/18transp.png" align="bottom" width=400></p>
</center>

<p>
Da 1 er det laveste matrise-indekset i Matlab, setter vi \( r_j=\Delta r\cdot (j-1),\ \Delta r=\frac{1}{N},\ j=1,2,\dots,N+1 \)  som vist på figuren ovenfor
Ligningsystem fra \eqref{eq:5602} samt \eqref{eq:5606}:

<p>
For \( j=1 \):

$$
\begin{equation} \label{eq:56019}
(1+4D\cdot \theta)\cdot \omega^{n+1}_1-4D\cdot \theta \cdot \omega_2^{n+1}=\omega_1^n+4D(1-\theta)\cdot(\omega^n_2-\omega_1^n)
\end{equation}
$$

<p>
For  \( j=2,\dots,N \):

$$
\begin{equation} \label{eq:56020}
\begin{array}{l}
-D\theta\cdot\left(1-\frac{1}{2(j-1)}\right)\cdot \omega^{n+1}_{j-1}+(1+2D\theta)\cdot \omega_j^{n+1}-D\theta \cdot\left(1+\frac{1}{2(j-1)}\right)\cdot \omega^{n+1}_{j+1}\\ 
= D(1-\theta)\cdot \left(1-\frac{1}{2(j-1)}\right)\cdot \omega^n_{j-1}+[1-2D(1-\theta)]\cdot\omega^n_j\\ 
+D(1-\theta)\cdot\left(1+\frac{1}{2(j-1)}\right)\cdot\omega^n_{j+1}
\end{array}
\end{equation}
$$

<p>
Får da følgende koeffisienter for bruk i <b>tdma</b>:

$$
\begin{equation} \label{eq:56021}
\left.\begin{matrix}
&a_j=-D\theta\left(1-\frac{1}{2(j-1)}\right),\ j=2,\dots,N\\ 
&b_1=1+4D\theta \\ 
&b_j=1+2D\theta, j=2,\dots,N\\ 
&c_1=-4D\theta  \\ 
&c_j=-D\theta\left( 1+\frac{1}{2(j-1)}  \right),\ j=2,\dots,N-1 \\ 
&d_1=\omega^n_1+4D(1-\theta)\cdot(\omega^n_2-\omega_1^n),\ n=1,\dots\\ 
&d_j=D(1-\theta)\bigg\{\left(1-\frac{1}{2(j-1)}\right)\cdot \omega^n_{j-1}+\left(1+\frac{1}{2(j-1)}\right)\cdot \omega^n_{n+1}\bigg\}\\ 
&+ [1-2D(1-\theta)]\cdot \omega^n_{j},\ j=2,\dots, N+1
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Startverdier:

$$
\begin{equation} \label{eq:56022}
\omega^0_j=1-r^2_j=1-[\Delta r\cdot(j-1)]^2,\ j=1,\dots,N+1
\end{equation}
$$

<p>
Dessuten har vi at \( \omega_{N+1} \)  for alle \( n \)-verdier.

<p>
Merk at vi også kan bruke <b>tdma</b> for \( \theta=0 \)  (FTCS-skjemaet). I dette tilfellet forsvinner både \( a \)- og \( c \)-vektoren. Determinanten av matrisa er 
nå produktet av elementene i \( b \)-vektoren. Betingelsen for at matrisa er ikke-singulær er da at alle \( b \)-elementene \( \neq 0 \) , noe som er oppfylt for 
alle verdier av \( D \) og \( \theta \).

<p>
La oss også undersøke den numeriske stabiliteten av <b>tdma</b> for dette systemet.

<p>
Fra lign. (3.1.4) i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a> 
<!-- (ref {eq:3104}), -->
har vi følgende tre betingelser: 
<!-- %% referanse til kap 3 -->

$$
\begin{align}
&|b_1| > |c_1| > 0
\label{_auto70}\\ 
&|b_j|\geq |a_j|+|c_j|,\ a_j\cdot c_j\neq 0,\ j=2,3,\dots,N-1 \label{eq:56023} \\ 
&|b_N| > |a_N| > 0
\label{_auto71}
\end{align}
$$

<p>
Ulikhet 1:

$$
\begin{equation*}
|1+4D\theta| > |4D\theta|\text{ som alltid er oppfylt.}
\end{equation*}
$$

<p>
Ulikhet 2:

$$
\begin{equation*}
|1+2D\theta|\geq D\theta\bigg|1-\frac{1}{2(j-1)}\bigg|+D\theta \bigg|1-\frac{1}{2(j+1)} \bigg|
\end{equation*}
$$

<p>
Da alle leddene er positive:

$$
\begin{align*}
&1+2D\theta\geq D\theta\left(1-\frac{1}{2(j-1)}\right)+D\theta\left(1-\frac{1}{2(j+1)}\right)\\ 
&\to 1+2D\theta\geq 2D\theta \text{ som alltid er oppfylt}
\end{align*}
$$

<p>
Ulikhet 3:

$$
\begin{align*}
&|1+2D\theta|\geq D\theta \bigg|1-\frac{1}{2(j-1)} \bigg| \to 1+2D\theta\geq D\theta \left(1-\frac{1}{2(j-1)}\right)\\ 
&\text{som alltid er oppfylt}
\end{align*}
$$

<p>
Vi kan derfor bruke <b>tdma</b> som løsningsrutine.

<p>
Løsningen av dette systemet er gitt i programmet <b>startup</b> som løser systemet for \( \theta=0,\ \theta= 1/2 \) og \( \theta=1 \). Utskrift er gitt under. Vi har 
valgt \( D=0.4 \) og \( \Delta r=0.02 \)  slik at vi er i det stabile området for FTCS-skjemaet. Utskriften gir \( u_s \), ikke \( \omega \) .

<p>
Legg merke til at det bare er høyresiden av systemet, dvs. \( d \)-vektoren, som er tidsavhengig. Vi kan derfor bruke en versjon av <b>tdma</b> der vi utfører 
elimineringen kun en gang, mens innsettingen utføres for hvert tidskritt.

<p>
En slik versjon er gitt i lign. \eqref{eq:56018}, appendiks I i <a href="./NumeriskeBeregninger.pdf" target="_self">kompendiet</a> og er programmert i <b>startupv3</b> som er 2-3 
ganger raskere enn <b>startup</b>.

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">      *****************************************
      *    Impulsive start of pipeflow        *
      *    theta = 0:   FTCS-scheme           *
      *    theta = 1:   Laasonen              *
      *    theta = 1/2: Crank-Nicolson        *
      *****************************************

 No. of time-steps................ 500
 r-step length.....................0.020
 Diffusion-number D............... 0.400
 Timestep.......................   1.600e-004
 Elapsed time...................   8.000e-002

           r           u( )         u( )            u( )        analytisk 

      0.000   3.1452e-001   3.1436e-001   3.1444e-001   3.1448e-001
   0.100   3.1368e-001   3.1351e-001   3.1360e-001   3.1363e-001
   0.200   3.1091e-001   3.1073e-001   3.1082e-001   3.1086e-001
   0.300   3.0548e-001   3.0528e-001   3.0538e-001   3.0542e-001
   0.400   2.9606e-001   2.9584e-001   2.9595e-001   2.9600e-001
   0.500   2.8069e-001   2.8047e-001   2.8058e-001   2.8063e-001
   0.600   2.5671e-001   2.5650e-001   2.5661e-001   2.5666e-001
   0.700   2.2078e-001   2.2060e-001   2.2069e-001   2.2073e-001
   0.800   1.6893e-001   1.6880e-001   1.6886e-001   1.6889e-001
   0.900   9.6816e-002   9.6748e-002   9.6782e-002   9.6798e-002
   1.000   0.0000e+000   0.0000e+000   0.0000e+000   0.0000e+000
</pre></div>
<p>
Vi ser at det ikke er stor forskjell mellom resultatene for de ulike  \( \theta \)-verdiene da vi har en valgt en forholdsvis liten verdi for \( D \).

<p>
<b>Randbetingelse gitt i</b> \eqref{eq:5609}

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 91:  <div id="fig:519"></div> </p></center>
<p><img src="fig-ch5/19transp.png" align="bottom" width=400></p>
</center>

<p>
Vi velger å renummere som vist på figuren:

$$
\begin{equation*}
r_j=\Delta r\cdot j,\ \Delta r= \frac{1}{N+1},\ j=0,1,\dots,N+1
\end{equation*}
$$

<p>
Ved å renummerere, kan vi også bruke <b>tdma</b> for tilfellet  \( \theta=0 \) (FTCS) slik som vi gjorde i den foregående beregningen. Uten renummerering, vil
vi få \( b_1=4D\theta \)  slik at \( b_1=0 \)  for \( \theta = 0 \). Dette vil føre til at determinanten av koeffisientmatrisa blir lik null.

<p>
Gjentar randbetingelsen gitt i \eqref{eq:5609}:

$$
\begin{equation}\label{eq:56024}
\omega^n_0=\frac{1}{3}(4\omega^n_1-\omega_2^n),\ n=0,1,2\dots
\end{equation}
$$

<p>
Ligningsystemet blir nå som gitt i \eqref{eq:56017a} når vi lar \( \frac{1}{2(j-1)} \to \frac{1}{2j} \) og \( j=1,2,\dots \)  
For  \( j=1,\dots,N \): 

$$
\begin{align}
&-D\theta\cdot\left(1-\frac{1}{2j}\right)\cdot \omega^{n+1}_{j-1}+(1+2D\theta)\cdot \omega_j^{n+1}-D\theta \cdot\left(1+\frac{1}{2j}\right)\cdot \omega^{n+1}_{j+1}
\label{_auto72}\\ 
&= D(1-\theta)\cdot \left(1-\frac{1}{2j}\right)\cdot \omega^n_{j-1}+[1-2D(1-\theta)]\cdot\omega^n_j \label{eq:56025} \\ 
&+D(1-\theta)\cdot\left(1+\frac{1}{2j}\right)\cdot\omega^n_{j+1}
\label{_auto73}
\end{align}
$$

<p>
\eqref{eq:56025} utskrevet for  \( j=1 \), innsatt fra \eqref{eq:56024} og sammentrukket:

$$
\begin{equation} \label{eq:56026}
(1+\frac{4}{3}D\theta)\cdot \omega^{n+1}_1-\frac{4}{3}D\theta \omega_2^{n+1}=[1-\frac{4}{3}D(1-\theta)]\cdot \omega^n_1+\frac{4}{3}D(1-\theta)\omega_2^n
\end{equation}
$$

<p>
Etter at \( \omega_1,\omega_2,\dots \)  er funnet, beregnes \( \omega_0 \)  fra \eqref{eq:56024}, og lagres separat.

<p>
Startverdiene er som i \eqref{eq:56022}, men med følgende indeksering:

$$
\begin{equation} \label{eq:56027}
\omega^0_j  = 1-r_j^2 = 1 -(\Delta r \cdot j)^2,\ j=0,\dots,N+1
\end{equation}
$$

<p>
Får da følgende koeffisienter for bruk i <b>tdma</b>:

$$
\begin{equation} \label{eq:56028}
\left.\begin{matrix}
a_j=&-D\theta \left( 1-\frac{1}{2j}\right),\ j=2,\dots,N\\ 
b_1=&1+\frac{4}{3}D\theta\\ 
b_j=&1+2D\theta,\ j=2,\dots,N\\ 
c_1=&-\frac{4}{3}D\theta\\ 
c_j=&-D\theta\left(1+\frac{1}{2j}\right),\ j=2,\dots,N-1 \\ 
d_1=&[1-\frac{4}{3}D(1-\theta)]\cdot\omega^n_1+\frac{4}{3}D(1-\theta)\omega^n_2,\ n=1,\dots\\ 
d_j=&D(1-\theta)\Bigg\{\left(1-\frac{1}{2j}\right)\cdot\omega^n_{j-1}+\left(1+\frac{1}{2j}\right)\cdot \omega^n_{j+1}\Bigg\}\\ 
&+[1-2D(1-\theta)]\cdot \omega^n_j,\ j=2,\dots,N,\ n=1,\dots
\end{matrix}\right.\ 
\end{equation}
$$

<p>
Løsningen av dette systemet er gitt i programmet <b>startupv2</b>. Ulikhetene i \eqref{eq:56023} er oppfylt og <b>tdma</b> kan brukes.

<p>
Med samme datasett, gir <b>startupv2</b> samme resultat som <b>startup</b>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 92:  resultat fra test av stabilitet av de to forskjellige variantene av FTCS samt Crank og Laasonen. Ser at versjon 1 av FTCS utvikler innstabilitet før D=0.5, og at instabiliteten starter ved r=0. For versjon 2 oppstår innstabilitet ved D=0.5 og for alle r, som ventet. </p></center>
<p><img src="fig-ch5/startup_stability_transparent1.png" align="bottom" width=800></p>
</center>

<p>

<div>
<video  loop controls width='600' height='400' preload='none'>
    <source src='mov-ch5/startup.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-ch5/startup.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-ch5/startup.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em>Animasjon av eksepelet med bruk av tre \( \theta \)-skjemaene samt analytisk øsning.</em></p>

<p>
</div>
<!-- end box -->


<p>
<!-- !split  -->

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">

<h2 id="ex:52">Example: Avkjøling av kule</h2>

<p>
<center><p><img src="fig-ch5/20transp.png" align="bottom" width=300></p></center>
<div id="fig:520"></div>

<p>
Figuren viser en kule som blir avkjølt i vann. Kula har radius  \( b=5 \) og har temperatur \( T_k \)  før den senkes i vannet. Vannet holder en konstant
temperatur \( T_v \)  under hele prosessen. Vi ser bort fra varmetap til omgivelsene.

<p>
Andre data:

$$
\begin{align}
&Varmeledningstall:     k=0.1W/(cm\cdot^\circ C)        \label{eq:56029a} \\ 
&Varmeovergangstall:    \bar h  =0.2W/(cm\cdot^\circ C) \label{eq:56029b} \\ 
&Termisk diffusitivitet:  \alpha=0.04 cm^2/s            \label{eq:56029c}
\end{align}
$$

<p>
Vi har valgt verdiene slik at forholdet  \( \dfrac{\bar h \cdot b}{k}=1 \), noe som fører til en enklere analytisk løsning. Verdiene som er angitt i 
\eqref{eq:56029a}, \eqref{eq:56029b} og \eqref{eq:56029c}, passer bra for nikkel-legeringer.

<p>
Vi skal nå løse følgende problem med  \( T=T(r,t) \):

$$
\begin{equation} \label{eq:56030a}
\frac{\partial T}{\partial t}=\alpha \left(\frac{\partial^2T}{\partial r^2}+\frac{2}{r}\frac{\partial T}{\partial r} \right)
\end{equation}
$$

<p>
Randbetingelser:

$$
\begin{equation} \label{eq:56030b}
\frac{\partial T}{\partial r}(0,t)=0,\ \text{(symmetribetingelse)}
\end{equation}
$$

<p>
For \( r=b: \)

$$
\begin{equation} \label{eq:56030c}
k\frac{\partial T}{\partial r}= \bar h \cdot (T_v-T_b)
\end{equation}
$$

<p>
Startbetingelse:

$$
\begin{equation} \label{eq:56030d}
T(r,0)=T_k
\end{equation}
$$

<p>
I dette eksemplet nøyer vi oss med bruk av FTCS-skjemaet, men beregningen kan lett utvides til  \( \theta \)-skjemaet som vist i eksempel (<a href="#ex:51">Example: Oppstart av rørstrømning</a>).
Med \( r_j=\Delta r\cdot j,\ \Delta r= \frac{1}{N+1},\ j=0,1,\dots,N+1 \)   og \( D=\alpha \frac{\Delta t}{(\Delta r)^2} \)  får vi fra \eqref{eq:5602} når 
\( u(r,t)\to T(r,t),\ \theta=0 \) og  \( \lambda = 2 \):

$$
\begin{equation} \label{eq:56031}
T^{n+1}_j=(1-2D)\cdot T^n_j+D[(1-1/j)\cdot T^n_{j-1}+(1+1/j)\cdot T^n_{j+1}],\ j=1,2,\dots
\end{equation}
$$

<p>
Som i eksempel (<a href="#ex:51">Example: Oppstart av rørstrømning</a>), bruker vi to versjoner for symmetribetingelsen for  \( r=0 \).
<b>1)</b>

<p>
Fra \eqref{eq:5607} med  \( \lambda = 2 \):

$$
\begin{equation} \label{eq:56032}
T^{n+1}_0=(1-6D)\cdot T^n_0+6D\cdot T^n_1
\end{equation}
$$

<p>
<b>2)</b>   Fra \eqref{eq:5609}:

$$
\begin{equation} \label{eq:56033}
T^n_0=\frac{1}{3}(4T^n_1-T_2^n),\ \text{alle } n
\end{equation}
$$

<p>
<b>Randbetingelsen for</b>  \( r=b \).

<p>
Diskretiserer \eqref{eq:56030b} med bruk av 2. ordens bakoverdifferanser:

$$
\begin{equation*}
k\cdot \left( \frac{3T^n_{N+1}-4T^n_N+T^n_{N-1}}{2\cdot\Delta r} \right) = \bar h\cdot (T_v-T_b) \text{ som løst m.h.p $T^n_{N+1}$  gir:}
\end{equation*}
$$


$$
\begin{equation} \label{eq:56034a}
T^n_{N+1}=\frac{4T^n_N-T^n_{N-1}+2\delta\cdot T_v}{3+2\delta}
\end{equation}
$$


$$
\begin{equation} \label{eq:56034b}
\text{der } \delta = \frac{\Delta r\cdot \bar h}{k}
\end{equation}
$$

<p>
Vi har tidligere vist at vi må ha \( D < 1/3 \)  når vi bruker randbetingelsen i \eqref{eq:56032}). I eksempel (<a href="#ex:51">Example: Oppstart av rørstrømning</a>) for sylinderen, fant vi at 
stabilitetsgrensen for \( D \) økte når vi minsket \( \Delta r \)  ved bruk av FTCS-skjemaet. For kula derimot viser det seg at betingelsen \( D < 1/3 \) er 
uavhengig av \( \Delta r \). Årsaken til dette finner vi når vi skriver ut \eqref{eq:56031} for \( j=1 \):

$$
\begin{equation*}
T^{n+1}_1=(1-2D)\cdot T^n_1+2D\cdot T^n_2
\end{equation*}
$$

<p>
Leddet \( (1-1/j)\cdot T^n_{j-1}=(1-1)\cdot T^n_0 \)  forsvinner for  \( j=1 \), slik at temperaturen i kulas sentrum ikke influerer på noen av de andre verdiene.
Dette forklarer hvorfor stabilitetsgrensa er uavhengig av  \( \Delta r \). Vi kan da faktisk løse \eqref{eq:56021} for \( j=1,2,\dots,N \)  uten å bry oss om 
randbetingelsene i \eqref{eq:56032} og \eqref{eq:56033}. Randbetingelsen i \eqref{eq:56033} trenger vi bare for å finne temperaturen \( T^n_0 \)  i sentrum av 
kula.

<p>
Neumann-analysen som ikke tar hensyn til rendene, viste at \eqref{eq:56031} er stabil for \( D\leq 1/2 \).
Dessuten viste analysen at innflytelsen av den variable koeffisienten forsvant både for sylinderen og kula. (Se diskusjonen i forbindelse med 
\eqref{eq:5603}). Vi har ikke vist at  \( D\leq 1/2 \) er en tilstrekkelig betingelse for hele systemet, siden vi da også må ta med randbetingelsen i 
\eqref{eq:56034a}.

<p>
Vi kan da oppsummerer for bruk av FTCS-skjemaet for kula:

<p>
Skjemaet i \eqref{eq:56034a} er stabilt for \( D < 1/2 \)  for \( j=1,2,\dots \)

<p>
Dersom sentrumstemperaturen også beregnes, må vi ha \( D < 1/3 \)  når \eqref{eq:56032} brukes.

<p>
Med bruk av \eqref{eq:56033}, kan sentrumstemperaturen beregnes for \( D < 1/2 \).

<p>
Dette passer godt med Eisens analyse, omtalt i forbindelse med \eqref{eq:5609}.

<p>
Nedenfor er vist utskrift fra programmet <b>kule</b> av en beregning med \( D=0.4 \) og $\Delta r=0.1$cm. \( T_k=300^\circ C \) og \( T_v=20^\circ C \) og beregningen 
varer i 10 min. med tidskritt 1 sekund. De analytiske verdiene er beregnet av funksjonen <b>kanalyt</b>. Vi ser at det er god overenstemmelse mellom de 
numeriske og de analytiske verdiene. (Analytisk løsning i appendiks G.9)

<p>

<div class="row">
  <div class="col-xs-7">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="left"><b>r(cm)</b></td> <td align="left">T (\( ^\circ C \))</td> <td align="left">\( T_a \)</td> <td align="center"><b></b></td> <td align="left"><b>r(cm)</b></td> <td align="left">T (\( ^\circ C \))</td> <td align="left">\( T_a \)</td> </tr>
</thead>
<tbody>
<tr><td align="left">   0.00     </td> <td align="left">   53.38                 </td> <td align="left">   53.37        </td> <td align="center">       </td> <td align="left">   2.60     </td> <td align="left">   49.79                 </td> <td align="left">   49.78        </td> </tr>
<tr><td align="left">   0.10     </td> <td align="left">   53.37                 </td> <td align="left">   53.36        </td> <td align="center">       </td> <td align="left">   2.70     </td> <td align="left">   49.52                 </td> <td align="left">   49.51        </td> </tr>
<tr><td align="left">   0.20     </td> <td align="left">   53.36                 </td> <td align="left">   53.35        </td> <td align="center">       </td> <td align="left">   2.80     </td> <td align="left">   49.24                 </td> <td align="left">   49.23        </td> </tr>
<tr><td align="left">   0.30     </td> <td align="left">   53.33                 </td> <td align="left">   53.32        </td> <td align="center">       </td> <td align="left">   2.90     </td> <td align="left">   48.95                 </td> <td align="left">   48.94        </td> </tr>
<tr><td align="left">   0.40     </td> <td align="left">   53.29                 </td> <td align="left">   53.28        </td> <td align="center">       </td> <td align="left">   3.00     </td> <td align="left">   48.65                 </td> <td align="left">   48.64        </td> </tr>
<tr><td align="left">   0.50     </td> <td align="left">   53.24                 </td> <td align="left">   53.23        </td> <td align="center">       </td> <td align="left">   3.10     </td> <td align="left">   48.35                 </td> <td align="left">   48.34        </td> </tr>
<tr><td align="left">   0.60     </td> <td align="left">   53.18                 </td> <td align="left">   53.17        </td> <td align="center">       </td> <td align="left">   3.20     </td> <td align="left">   48.03                 </td> <td align="left">   48.03        </td> </tr>
<tr><td align="left">   0.70     </td> <td align="left">   53.11                 </td> <td align="left">   53.10        </td> <td align="center">       </td> <td align="left">   3.30     </td> <td align="left">   47.71                 </td> <td align="left">   47.71        </td> </tr>
<tr><td align="left">   0.80     </td> <td align="left">   53.03                 </td> <td align="left">   53.02        </td> <td align="center">       </td> <td align="left">   3.40     </td> <td align="left">   47.38                 </td> <td align="left">   47.38        </td> </tr>
<tr><td align="left">   0.90     </td> <td align="left">   52.93                 </td> <td align="left">   52.93        </td> <td align="center">       </td> <td align="left">   3.50     </td> <td align="left">   47.05                 </td> <td align="left">   47.04        </td> </tr>
<tr><td align="left">   1.00     </td> <td align="left">   52.83                 </td> <td align="left">   52.82        </td> <td align="center">       </td> <td align="left">   3.60     </td> <td align="left">   46.70                 </td> <td align="left">   46.70        </td> </tr>
<tr><td align="left">   1.10     </td> <td align="left">   52.72                 </td> <td align="left">   52.71        </td> <td align="center">       </td> <td align="left">   3.70     </td> <td align="left">   46.35                 </td> <td align="left">   46.35        </td> </tr>
<tr><td align="left">   1.20     </td> <td align="left">   52.59                 </td> <td align="left">   52.58        </td> <td align="center">       </td> <td align="left">   3.80     </td> <td align="left">   46.00                 </td> <td align="left">   45.99        </td> </tr>
<tr><td align="left">   1.30     </td> <td align="left">   52.46                 </td> <td align="left">   52.45        </td> <td align="center">       </td> <td align="left">   3.90     </td> <td align="left">   45.63                 </td> <td align="left">   45.63        </td> </tr>
<tr><td align="left">   1.40     </td> <td align="left">   52.31                 </td> <td align="left">   52.30        </td> <td align="center">       </td> <td align="left">   4.00     </td> <td align="left">   45.26                 </td> <td align="left">   45.26        </td> </tr>
<tr><td align="left">   1.50     </td> <td align="left">   52.16                 </td> <td align="left">   52.15        </td> <td align="center">       </td> <td align="left">   4.10     </td> <td align="left">   44.89                 </td> <td align="left">   44.88        </td> </tr>
<tr><td align="left">   1.60     </td> <td align="left">   51.99                 </td> <td align="left">   51.98        </td> <td align="center">       </td> <td align="left">   4.20     </td> <td align="left">   44.50                 </td> <td align="left">   44.50        </td> </tr>
<tr><td align="left">   1.70     </td> <td align="left">   51.81                 </td> <td align="left">   51.81        </td> <td align="center">       </td> <td align="left">   4.30     </td> <td align="left">   44.11                 </td> <td align="left">   44.11        </td> </tr>
<tr><td align="left">   1.80     </td> <td align="left">   51.63                 </td> <td align="left">   51.62        </td> <td align="center">       </td> <td align="left">   4.40     </td> <td align="left">   43.72                 </td> <td align="left">   43.71        </td> </tr>
<tr><td align="left">   1.90     </td> <td align="left">   51.43                 </td> <td align="left">   51.42        </td> <td align="center">       </td> <td align="left">   4.50     </td> <td align="left">   43.32                 </td> <td align="left">   43.31        </td> </tr>
<tr><td align="left">   2.00     </td> <td align="left">   51.22                 </td> <td align="left">   51.22        </td> <td align="center">       </td> <td align="left">   4.60     </td> <td align="left">   42.92                 </td> <td align="left">   42.91        </td> </tr>
<tr><td align="left">   2.10     </td> <td align="left">   51.01                 </td> <td align="left">   51.00        </td> <td align="center">       </td> <td align="left">   4.70     </td> <td align="left">   42.51                 </td> <td align="left">   42.50        </td> </tr>
<tr><td align="left">   2.20     </td> <td align="left">   50.78                 </td> <td align="left">   50.78        </td> <td align="center">       </td> <td align="left">   4.80     </td> <td align="left">   42.09                 </td> <td align="left">   42.09        </td> </tr>
<tr><td align="left">   2.30     </td> <td align="left">   50.55                 </td> <td align="left">   50.54        </td> <td align="center">       </td> <td align="left">   4.90     </td> <td align="left">   41.67                 </td> <td align="left">   41.67        </td> </tr>
<tr><td align="left">   2.40     </td> <td align="left">   50.30                 </td> <td align="left">   50.30        </td> <td align="center">       </td> <td align="left">   5.00     </td> <td align="left">   41.25                 </td> <td align="left">   41.24        </td> </tr>
<tr><td align="left">   2.50     </td> <td align="left">   50.05                 </td> <td align="left">   50.04        </td> <td align="center">       </td> <td align="left">            </td> <td align="left">                         </td> <td align="left">                </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-7 -->
<p>

<div>
<video  loop controls width='600' height='400' preload='none'>
    <source src='mov-ch5/sphere.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-ch5/sphere.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-ch5/sphere.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em>Animasjon av eksepelet med bruk av tre \( \theta \)-skjemaene samt analytisk øsning.</em></p>

<p>
</div>
<!-- end box -->

<!-- !split -->

<center><h1 id="ch:6">Convection problems and hyperbolic PDEs</h1></center> <!-- chapter heading -->

<h1 id="section:advection">The advection equation</h1>

<p>
The classical advection equation is very often used as an example of a hyperbolic partial differential equation which illustrates many features of convection problems, while still being linear:
$$
\begin{equation}
\label{eq:6101}
\frac{\partial u}{\partial t} + a_0 \frac{\partial u}{\partial x} = 0
\end{equation}
$$

<p>
Another convenient feature of the model equation \eqref{eq:6101} is
that is has an analytical solution:
$$
\begin{equation}\label{eq:hyp_analytical}
u = u_0 \, f(x-a_0\,t )
\end{equation}
$$

and represents a wave propagating with a constant velocity \( a_0 \) with
unchanged shape. When \( a_0 > 0 \), the wave propagates in the positive
x-direction, whereas for \( a_0 < 0 \), the wave propagates in the negative
x-direction.

<p>
Equation \eqref{eq:6101} may serve as a model-equation for a
compressible fluid, e.g if \( u \) denote pressure it represents a
pressure wave propagating with the velocity \( a_0 \). The advection
equation may also be used to model the propgation of pressure or flow
in a compliant pipe, such as a blood vessel.

<p>
To allow for generalization we will also when appropriate write \eqref{eq:6101} on the following form:
$$
\begin{equation}
\frac{\partial u}{\partial t} +  \frac{\partial F}{\partial x} = 0
\label{eq:generic_linear}
\end{equation}
$$

where for the linear advection equation \( F(u) = a_0\; u \).

<h2 id="ch6:sec2">Forward in time central in space discretization</h2>

<p>
We may discretize \eqref{eq:6101} with a forward difference in time and
a central difference in space, normally abberviated as the FTCS-scheme:
$$
\begin{equation*}
\label{eq:FTCS_comp}
\frac{\partial u}{\partial t} \approx \frac{u_j^{n+1}-u_j^n}{\Delta t}, \qquad  \frac{\partial u}{\partial x}\approx \frac{u_{j+1}^n-u_{j-1}^n}{2 \Delta x}
\end{equation*}
$$

and we may substitute the approximations \eqref{eq:FTCS_comp} into the advection equation \eqref{eq:6101} to yield:
$$
\begin{equation}
\label{eq:6201}
u_j^{n+1} = u_j^n - \frac{C}{2}(u_{j+1}^n-u_{j-1}^n)
\end{equation}
$$

For convenience we have introduced the non-dimensional <a href="http://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition" target="_self">Courant-Friedrich-Lewy</a> number (or CFL-number for short): 
$$
\begin{equation}
\label{eq:CFL}
C = a_0\frac{\Delta t}{\Delta x}
\end{equation}
$$

<p>
The scheme in (ref{eq:6201} is first order in time and second order in space (i.e. \( (O(\Delta t) + O(\Delta x^2)) \)), and explicit in time as can bee seen both from Figure <a href="#fig:FTCS">93</a> and (ref{eq:6201}.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 93:  Illustration of the first order in time central in space scheme. <div id="fig:FTCS"></div> </p></center>
<p><img src="fig-ch6/fig01.png" align="bottom" width=400></p>
</center>

<p>
We will try to solve model equation \eqref{eq:6101} with the scheme \eqref{eq:6201} and initial conditions illustrated in Fig (<a href="#fig:FTCS_init">94</a>) with the mathematical representation:
$$
\begin{equation*}
\begin{array}{c}
u(x,0) = 1 \text{ for } x < 0.5\\ 
u(x,0) = 0 \text{ for } x > 0.5
\end{array}
\end{equation*}
$$

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 94:  Initial values for the advection equaution \eqref{eq:6101}. <div id="fig:FTCS_init"></div> </p></center>
<p><img src="fig-ch6/fig02.png" align="bottom" width=400></p>
</center>

<p>
Solutions for three CFL-numbers: C=0.25, 0.5 and 1.0 are illustrated
in Figure <a href="#fig:FTCS_sol">95</a>.  Large oscillations are observed for all
values of the CFL-number, even though they seem to be sligtly reduced
for smaller C-values,; thus we have indications of an unstable scheme.
As a first approach observe that the coefficient for \( u^n_{j+1} \) in
\eqref{eq:6201} always will be negative, and thus the criterion of
positive coefficients (PC-criterion) may not be satisfied for any
value of \( C \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 95:  Computed solutions with the \eqref{eq:6201}. Dotted line: analytical solution, solid line: computed soultion. <div id="fig:FTCS_sol"></div> </p></center>
<p><img src="fig-ch6/fig03.png" align="bottom" width=400></p>
</center>

<p>
However, as we know that the PC-criterion may be too
strict in some cases, we proceed with a von Neumann analysis by introducing the numerical amplification factor \( G^n \) for the error \( E^n_j \) in the numerical scheme to be analyzed
$$
\begin{equation}
\label{eq:5309_local}
u^n_j\to E^n_j=G^n\cdot e^{i\cdot \beta x_j}
\end{equation}
$$

Substitution of \eqref{eq:5309_local} into \eqref{eq:6201} yields:
$$
\begin{equation*}
G^{n+1}e^{i\cdot \beta \cdot x_j} = G^ne^{i \cdot \beta \cdot x_j}-\frac{C}{2}\left(G^ne^{i\cdot \beta x_{j+1}}- G^ne^{i\cdot \beta x_{j-1}}\right)
\end{equation*}
$$

which after division with  \( G^ne^{i\cdot \beta \cdot x_j} \) and introduction of the simplified notation \( \delta = \beta \cdot h \)  yields:
$$
\begin{equation*}
G = 1 - \frac{C}{2}\left(e^{i\cdot \beta h}-e^{-i \cdot \beta h}\right) = 1 - i \cdot C \sin(\delta)
\end{equation*}
$$

where the trigonometric relations:
$$
\begin{align} \label{eq:53114_local}
&2\cos(x)=e^{ix}+e^{-ix}\\ 
&i\cdot 2\sin(x)=e^{ix}-e^{-ix}
\label{_auto74}\\ 
&\cos(x)=1-2\sin^2(\frac{x}{2})
\label{_auto75}
\end{align}
$$

<p>
have been introduced for convenience. Finally, we get the following
expression for the numerical ampliciation factor:

$$
\begin{equation*}
|G|=\sqrt{1+C^2\sin^2(\delta)} \geq 1 \text{ for all } C \text{ and } \delta
\end{equation*}
$$

and concequently the FTCS-scheme is unconditionally unstable for the advection equation and is thus not a viable scheme. Even a very small value of C will not suffice to dampe the oscillations.

<h2 id="___sec101">ftbs/upwind </h2>

<p>

<!-- begin inline comment -->
<font color="red">(<b>Fredrik 14</b>: add ftbs/upwind. check if ftbs is the same as upwind.)</font>
<!-- end inline comment -->

<h2 id="___sec102">The Lax-Friedrich Scheme </h2>

<p>
Lax-Friedrichs scheme is an explicit, first order scheme, using
forward difference in time and central difference in space.  However,
the scheme is stabilized by averaging  \( u^n_i \) over the neighbour cells in the in the temporal approximation:
$$
\begin{equation}
\frac{u_i^{n+1}-\frac{1}{2}(u^n_{i+1}+u^n_{i-1})}{\Delta t} = -\frac{F^n_{i+1}-F^n_{i-1}}{2 \Delta x}
\label{eq:LF-1}
\end{equation}
$$

The Lax-Friedrich scheme is the obtained by isolation \( u^{n+1}_i \) at the right hand side:
$$
\begin{equation}
u_i^{n+1} = \frac{1}{2}(u^n_{i+1}+u^n_{i-1}) - \frac{\Delta t}{2 \Delta x}(F^n_{i+1}-F^n_{i-1})
\label{}
\end{equation}
$$

<p>
By assuming a linear flux \( F=a_0 \, u \) it may be shown that the Lax-Friedrich scheme takes the form:
$$
\begin{equation}
u_i^{n+1} = \frac{1}{2}(u^n_{i+1}+u^n_{i-1}) - \frac{C}{2}(u^n_{i+1}-u^n_{i-1})
\label{}
\end{equation}
$$

where we have introduced the CFL-number as given by \eqref{eq:CFL} and have the simple python-implementation:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">lax_friedrich</span>(u):
    u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> (u[:<span style="color: #666666">-2</span>] <span style="color: #666666">+</span>u[<span style="color: #666666">2</span>:])<span style="color: #666666">/2.0</span> <span style="color: #666666">-</span>  c<span style="color: #666666">*</span>(u[<span style="color: #666666">2</span>:] <span style="color: #666666">-</span> u[:<span style="color: #666666">-2</span>])<span style="color: #666666">/2.0</span>
    <span style="color: #008000; font-weight: bold">return</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
</pre></div>
<p>
whereas a more generic flux implementation is implemented as:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">lax_friedrich_Flux</span>(u):
    u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> (u[:<span style="color: #666666">-2</span>] <span style="color: #666666">+</span>u[<span style="color: #666666">2</span>:])<span style="color: #666666">/2.0</span> <span style="color: #666666">-</span>  dt<span style="color: #666666">*</span>(F(u[<span style="color: #666666">2</span>:])<span style="color: #666666">-</span>F(u[:<span style="color: #666666">-2</span>]))<span style="color: #666666">/</span>(<span style="color: #666666">2.0*</span>dx)
    <span style="color: #008000; font-weight: bold">return</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
</pre></div>
<p>
<!-- !split -->

<h2 id="___sec103">Lax Wendroff Schemes </h2>

<p>
These schemes were proposed in 1960 by P.D. Lax and B. Wendroff
<a href="#lax73">[20]</a> for solving, approximately, systems of hyperbolic
conservation laws on the generic form given in
\eqref{eq:generic_linear}.

<p>
A large class of numerical methods for solving
\eqref{eq:generic_linear} are the so-called conservative methods:

$$
\begin{equation}
u_j^{n+1} = u_j^{n} + \frac{\Delta t}{\Delta x} \left ( F_{i-1/2} - F_{i+1/2} \right ) 
\label{eq:conservative_methods}
\end{equation}
$$

<p>

<!-- begin inline comment -->
<font color="red">(<b>Fredrik 15</b>: mix of i and j indices in the above equation?)</font>
<!-- end inline comment -->

<p>
<b>Linear advection.</b>

<p>
The Lax–Wendroff method belongs to the class of conservative schemes
\eqref{eq:generic_linear} and can be derived in various ways. For
simplicity, we will derive the method by using a simple model equation
for \eqref{eq:generic_linear}, namely the linear advection equation
with \( F(u)=a\,u \) as in \eqref{eq:6101}, where \( a \) is a constant
propagation velocity. The Lax-Wendroff outset is a Taylor approximation of \( u_j^{n+1} \):
$$
\begin{equation}
u_j^{n+1}=u_j^n+\Delta t \frac{\partial u}{\partial t}\Bigg|_j^n + \frac{(\Delta t)}{2}\frac{\partial^2u}{\partial t^2}\Bigg|_j^n+\cdots
\label{eq:taylor_lw}
\end{equation}
$$

From the differential equation \eqref{eq:generic_linear} we get by differentiation 
$$
\begin{equation}
\begin{array}{c}
\dfrac{\partial u}{\partial t}\Bigg|_j^n = -a_0\dfrac{\partial u}{\partial x}\Bigg|_j^n 
 \qquad \text{ and} \qquad
\dfrac{\partial^2u}{\partial t^2}\Bigg|_j^n = a_0^2\dfrac{\partial^2u}{\partial x^2}\Bigg|_j^n
\end{array}
\label{eq:6501}
\end{equation}
$$

Before substitution of \eqref{eq:6501} in the Taylor expansion \eqref{eq:taylor_lw} we approximate the spatial derivatives by central differences:
$$
\begin{equation}
\dfrac{\partial u}{\partial x}\Bigg|_j^n  \approx \dfrac{u_{j+1}^n-u_{j-1}^n}{(2\Delta x)}
\qquad \text{ and } 
\qquad \dfrac{\partial^2u}{\partial x^2}\Bigg|_j^n \approx \dfrac{u_{j+1}^n -2u_j^n + u_{j-1}^n}{(\Delta x)^2}
\label{eq:lw_cd}
\end{equation}
$$

and then the Lax-Wendroff scheme follows by substitution:
$$
\begin{equation}
\label{eq:6503}
u_j^{n+1}=u_j^n-\frac{C}{2}\left( u_{j+1}^n-u_{j-1}^n \right) + \frac{C^2}{2}\left( u_{j+1}^n - 2u_j^n+u_{j-1}^n \right)
\end{equation}
$$

with the local truncation error  \( T_j^n \):
$$
\begin{equation}
T_j^n = \frac{1}{6}\cdot \left[ (\Delta t)^2 \frac{\partial^3u}{\partial t^3} + a_0(\Delta x)^2 \frac{\partial^3u}{\partial x^3}\right]_j^n = O[(\Delta t)^2,(\Delta x)^2]
\label{}
\end{equation}
$$

The resulting difference equation in \eqref{eq:6503} may also be formulated as:
$$
\begin{equation}
\label{eq:6505}
u_j^{n+1} = \frac{C}{2}(1+C)u_{j-1}^n + (1-C^2)u_j^n - \frac{C}{2}(1-C)u_{j+1}^n
\end{equation}
$$

<p>
The explicit Lax Wendroff stenticl is illustrated in Figure <a href="#fig:LW">96</a>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 96:  Schematic of the Lax-Wendroff scheme. <div id="fig:LW"></div> </p></center>
<p><img src="fig-ch6/fig06.png" align="bottom" width=400></p>
</center>

<p>
An example of how to implement the Lax-Wendroff scheme is given as follows:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">lax_wendroff</span>(u): 
    u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> c<span style="color: #666666">/2.0*</span>(<span style="color: #666666">1+</span>c)<span style="color: #666666">*</span>u[:<span style="color: #666666">-2</span>] <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>c<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> c<span style="color: #666666">/2.0*</span>(<span style="color: #666666">1-</span>c)<span style="color: #666666">*</span>u[<span style="color: #666666">2</span>:]
    <span style="color: #008000; font-weight: bold">return</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
</pre></div>

<h2 id="ch:6_Lax-Wendroff_nonlin">Lax-Wendroff for non-linear systems of hyperbolic PDEs</h2>
For non-linear equations \eqref{eq:generic_linear} the Lax–Wendroff
method is no longer unique and naturally various methods have been
suggested. The challenge for a non-linear \( F(u) \) is that the substitution of
temporal derivatives with spatial derivatives (as we did in \eqref{eq:6501}) is
not straightforward and unique.

<p>
<b>Ricthmyer Scheme.</b>

One of the earliest extensions of the scheme is the <a href="http://www.encyclopediaofmath.org/index.php/Lax-Wendroff_method" target="_self">Richtmyer two-step
Lax–Wendroff method</a>, which is on the conservative form \eqref{eq:conservative_methods} with the numerical fluxes computed as follows:

$$
\begin{align}
&u_{j+1/2}^{n+1/2} = \frac{1}{2} \left (u_{j}^{n} + u_{j+1}^{n} \right ) +
\frac{1}{2} \frac{\Delta t}{\Delta x} \left (F_j^n - F_{j+1}^n \right )
\label{_auto76}\\ 
& F_{j+1/2} = F(u_{j+1/2}^{n+1/2})
\label{_auto77}
\end{align}
$$

<p>
<b>Lax-Wendroff two step.</b>

<p>
A <a href="http://en.wikipedia.org/wiki/Lax%E2%80%93Wendroff_method" target="_self">Lax-Wendroff two step
method</a> is
outlined in the following. In the first step \( u(x, t) \) is evaluated at
half time steps \( n + 1/2 \) and half grid points \( j+1/2 \). In the
second step values at the next time step \( n + 1 \) are calculated using the data for \( n \) and
\( n + 1/2 \).

<p>
First step:
$$
\begin{align}
& u_{j+1/2}^{n+1/2} = \frac{1}{2} \left (u_{j+1}^{n} + u_{j}^{n} \right )
 - \frac{\Delta t}{2 \Delta x} \left (F(u_{j+1}^{n}) - F(u_{j}^{n}) \right ) 
\label{_auto78}\\ 
& u_{j-1/2}^{n+1/2} = \frac{1}{2} \left (u_{j}^{n} + u_{j-1}^{n} \right )
 - \frac{\Delta t}{2 \Delta x} \left (F(u_{j}^{n}) - F(u_{j-1}^{n}) \right ) 
\label{eq:lw_1st}
\end{align}
$$

<p>
Second step:
$$
\begin{equation}
u_{j}^{n+1} = u_{j}^{n} - \frac{\Delta t}{\Delta x} 
\left ( F(u_{j+1/2}^{n+1/2}) - F(u_{j-1/2}^{n+1/2}) \right )
\label{eq:lw_2nd}
\end{equation}
$$

<p>
Notice that for a linear flux \( F=a_0 \, u \), the two-step Lax-Wendroff
method (\eqref{eq:lw_1st} and \eqref{eq:lw_2nd}) may be shown to reduce
to the one-step Lax-Wendroff method outlined in \eqref{eq:6503} or
\eqref{eq:6505}.

<p>
<b>MacCormack Scheme.</b>

<p>
A simpler and popular extension/variant of Lax-Wendroff schemes like
in the previous section, is the MacCormack scheme
<a href="#maccormack69">[21]</a>:

$$
\begin{align}
& u_j^p =u_j^n + \frac{\Delta t}{\Delta x} \left (F_{j}^{n} - F_{j+1}^{n} \right ) 
\label{_auto79}\\ 
& u_j^{n+1} =\frac{1}{2} \left (u_{j}^{n} + u_{j}^{p} \right ) + 
  \frac{1}{2} \frac{\Delta t}{\Delta x} \left (F_{j-1}^{p} - F_{j}^{p} \right ) 
\label{_auto80}\\ 
\label{eq:maccormack}
\end{align}
$$

<p>
where we have introduced the convention \( F_{j}^{p}=F(u_{j}^{p}) \).

<p>
Note that in the predictor step we employ the conservative formula
\eqref{eq:conservative_methods} for a time \( \Delta t \) with forward
differencing, i.e. . \( F_{j+1/2} = F^n_{j+1}=F(u^n_{j+1}) \). The
corrector step may be interpreted as using
\eqref{eq:conservative_methods} for a time \( \Delta t/2 \) with initial
condition \( \frac{1}{2} \left (u_{j}^{n} + u_{j+1}^{p} \right ) \) and
backward differencing.

<p>
Another MacCormack scheme may be obtained by reversing the predictor and
corrector steps. Note that the MacCormack scheme \eqref{eq:maccormack}  is not written
in conservative form \eqref{eq:conservative_methods}. However, it easy to express the scheme in
conservative form by expressing the flux in \eqref{eq:conservative_methods} as:
$$
\begin{equation}
F_{j+1}^{m} = \frac{1}{2} \left (F_j^p + F_{j+1}^n \right ) 
\label{}
\end{equation}
$$

<p>
For a linear flux \( F(u) = a_0 \, u \), one may show that the MacCormack scheme in 
\eqref{eq:maccormack} reduces to a two-step scheme:
$$
\begin{align}
& u_j^p = u_j^n  + C \left ( u_j^n - u_{j+1}^n \right ) \label{eq:macC1}\\ 
& u_j^{n+1} = \frac{1}{2} \left ( u_j^n + u_j^p \right )+ \frac{C}{2} \left ( u_{j-1}^p - u_{j}^p \right ) \label{eq:macC2}
\end{align}
$$

<p>
and substitution of \eqref{eq:macC1} into \eqref{eq:macC2} shows that
the MacCormack scheme is identical to the Lax-Wendroff scheme \eqref{eq:6505} for the
linear advection flux. A python implementation is given by:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">macCormack</span>(u):
    up <span style="color: #666666">=</span> u<span style="color: #666666">.</span>copy()
    up[:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u[:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> c<span style="color: #666666">*</span>(u[<span style="color: #666666">1</span>:]<span style="color: #666666">-</span>u[:<span style="color: #666666">-1</span>])
    u[<span style="color: #666666">1</span>:] <span style="color: #666666">=</span> <span style="color: #666666">.5*</span>(u[<span style="color: #666666">1</span>:]<span style="color: #666666">+</span>up[<span style="color: #666666">1</span>:] <span style="color: #666666">-</span>  c<span style="color: #666666">*</span>(up[<span style="color: #666666">1</span>:]<span style="color: #666666">-</span>up[:<span style="color: #666666">-1</span>]))
    <span style="color: #008000; font-weight: bold">return</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
</pre></div>

<h2 id="___sec105">Code example for various schemes for the advection equation </h2>
A complete example showing how a range of hyperbolic schemes are
implemented and applied to a particular example:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># ../Kap6/advection_schemes.py</span>

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> animation
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scipy</span> <span style="color: #008000; font-weight: bold">import</span> interpolate
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> where
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sin

LNWDT<span style="color: #666666">=2</span>; FNT<span style="color: #666666">=15</span>
plt<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; plt<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT

a <span style="color: #666666">=</span> <span style="color: #666666">1.0</span> <span style="color: #408080; font-style: italic"># wave speed</span>
tmin, tmax <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>, <span style="color: #666666">1.0</span> <span style="color: #408080; font-style: italic"># start and stop time of simulation</span>
xmin, xmax <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>, <span style="color: #666666">2.0</span> <span style="color: #408080; font-style: italic"># start and end of spatial domain</span>
Nx <span style="color: #666666">=</span> <span style="color: #666666">80</span> <span style="color: #408080; font-style: italic"># number of spatial points</span>
c <span style="color: #666666">=</span> <span style="color: #666666">0.9</span> <span style="color: #408080; font-style: italic"># courant number, need c&lt;=1 for stability</span>

init_func<span style="color: #666666">=1</span>   <span style="color: #408080; font-style: italic"># Select stair case function (0) or sin^2 function (1)</span>

<span style="color: #408080; font-style: italic"># function defining the initial condition</span>
<span style="color: #008000; font-weight: bold">if</span> (init_func<span style="color: #666666">==0</span>):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Assigning a value of 1.0 for values less than 0.1&quot;&quot;&quot;</span>
        f <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(x)
        f[np<span style="color: #666666">.</span>where(x <span style="color: #666666">&lt;=</span> <span style="color: #666666">0.1</span>)] <span style="color: #666666">=</span> <span style="color: #666666">1.0</span>
        <span style="color: #008000; font-weight: bold">return</span> f
<span style="color: #008000; font-weight: bold">elif</span>(init_func<span style="color: #666666">==1</span>):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;A smooth sin^2 function between x_left and x_right&quot;&quot;&quot;</span>
        f <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(x)
        x_left <span style="color: #666666">=</span> <span style="color: #666666">0.25</span>
        x_right <span style="color: #666666">=</span> <span style="color: #666666">0.75</span>
        xm <span style="color: #666666">=</span> (x_right<span style="color: #666666">-</span>x_left)<span style="color: #666666">/2.0</span>
        f <span style="color: #666666">=</span> where((x<span style="color: #666666">&gt;</span>x_left) <span style="color: #666666">&amp;</span> (x<span style="color: #666666">&lt;</span>x_right), np<span style="color: #666666">.</span>sin(np<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>(x<span style="color: #666666">-</span>x_left)<span style="color: #666666">/</span>(x_right<span style="color: #666666">-</span>x_left))<span style="color: #666666">**4</span>,f) 
        <span style="color: #008000; font-weight: bold">return</span> f

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ftbs</span>(u): <span style="color: #408080; font-style: italic"># forward time backward space</span>
    u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> (<span style="color: #666666">1-</span>c)<span style="color: #666666">*</span>u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> c<span style="color: #666666">*</span>u[:<span style="color: #666666">-2</span>]
    <span style="color: #008000; font-weight: bold">return</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]

<span style="color: #408080; font-style: italic"># Lax-Wendroff</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">lax_wendroff</span>(u): 
    u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> c<span style="color: #666666">/2.0*</span>(<span style="color: #666666">1+</span>c)<span style="color: #666666">*</span>u[:<span style="color: #666666">-2</span>] <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>c<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> c<span style="color: #666666">/2.0*</span>(<span style="color: #666666">1-</span>c)<span style="color: #666666">*</span>u[<span style="color: #666666">2</span>:]
    <span style="color: #008000; font-weight: bold">return</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]

<span style="color: #408080; font-style: italic"># Lax-Friedrich Flux formulation</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">lax_friedrich_Flux</span>(u):
    u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> (u[:<span style="color: #666666">-2</span>] <span style="color: #666666">+</span>u[<span style="color: #666666">2</span>:])<span style="color: #666666">/2.0</span> <span style="color: #666666">-</span>  dt<span style="color: #666666">*</span>(F(u[<span style="color: #666666">2</span>:])<span style="color: #666666">-</span>F(u[:<span style="color: #666666">-2</span>]))<span style="color: #666666">/</span>(<span style="color: #666666">2.0*</span>dx)
    <span style="color: #008000; font-weight: bold">return</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] 

<span style="color: #408080; font-style: italic"># Lax-Friedrich Advection</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">lax_friedrich</span>(u):
    u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> (u[:<span style="color: #666666">-2</span>] <span style="color: #666666">+</span>u[<span style="color: #666666">2</span>:])<span style="color: #666666">/2.0</span> <span style="color: #666666">-</span>  c<span style="color: #666666">*</span>(u[<span style="color: #666666">2</span>:] <span style="color: #666666">-</span> u[:<span style="color: #666666">-2</span>])<span style="color: #666666">/2.0</span>
    <span style="color: #008000; font-weight: bold">return</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] 

<span style="color: #408080; font-style: italic"># macCormack for advection quation</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">macCormack</span>(u):
    up <span style="color: #666666">=</span> u<span style="color: #666666">.</span>copy()
    up[:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u[:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> c<span style="color: #666666">*</span>(u[<span style="color: #666666">1</span>:]<span style="color: #666666">-</span>u[:<span style="color: #666666">-1</span>])
    u[<span style="color: #666666">1</span>:] <span style="color: #666666">=</span> <span style="color: #666666">.5*</span>(u[<span style="color: #666666">1</span>:]<span style="color: #666666">+</span>up[<span style="color: #666666">1</span>:] <span style="color: #666666">-</span>  c<span style="color: #666666">*</span>(up[<span style="color: #666666">1</span>:]<span style="color: #666666">-</span>up[:<span style="color: #666666">-1</span>]))
    <span style="color: #008000; font-weight: bold">return</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] 

<span style="color: #408080; font-style: italic"># Discretize</span>
x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(xmin, xmax, Nx<span style="color: #666666">+1</span>) <span style="color: #408080; font-style: italic"># discretization of space</span>
dx <span style="color: #666666">=</span> <span style="color: #008000">float</span>((xmax<span style="color: #666666">-</span>xmin)<span style="color: #666666">/</span>Nx) <span style="color: #408080; font-style: italic"># spatial step size</span>
dt <span style="color: #666666">=</span> c<span style="color: #666666">/</span>a<span style="color: #666666">*</span>dx <span style="color: #408080; font-style: italic"># stable time step calculated from stability requirement</span>
Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>((tmax<span style="color: #666666">-</span>tmin)<span style="color: #666666">/</span>dt) <span style="color: #408080; font-style: italic"># number of time steps</span>
time <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(tmin, tmax, Nt) <span style="color: #408080; font-style: italic"># discretization of time</span>

<span style="color: #408080; font-style: italic"># solve from tmin to tmax</span>

<span style="color: #408080; font-style: italic">#solvers = [ftbs,lax_wendroff,lax_friedrich,macCormack]</span>
<span style="color: #408080; font-style: italic">#solvers = [ftbs,lax_wendroff,macCormack]</span>
<span style="color: #408080; font-style: italic">#solvers = [ftbs,lax_wendroff]</span>
solvers <span style="color: #666666">=</span> [lax_wendroff]


u_solutions<span style="color: #666666">=</span>np<span style="color: #666666">.</span>zeros((<span style="color: #008000">len</span>(solvers),<span style="color: #008000">len</span>(time),<span style="color: #008000">len</span>(x)))
uanalytical <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((<span style="color: #008000">len</span>(time), <span style="color: #008000">len</span>(x))) <span style="color: #408080; font-style: italic"># holds the analytical solution</span>


    
<span style="color: #008000; font-weight: bold">for</span> k, solver <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(solvers): <span style="color: #408080; font-style: italic"># Solve for all solvers in list</span>
    u <span style="color: #666666">=</span> f(x)
    un <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((<span style="color: #008000">len</span>(time), <span style="color: #008000">len</span>(x))) <span style="color: #408080; font-style: italic"># holds the numerical solution</span>

    <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">1</span>:]):
        
        <span style="color: #008000; font-weight: bold">if</span> k<span style="color: #666666">==0</span>:
            uanalytical[i,:] <span style="color: #666666">=</span> f(x<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t) <span style="color: #408080; font-style: italic"># compute analytical solution for this time step</span>
            
        u_bc <span style="color: #666666">=</span> interpolate<span style="color: #666666">.</span>interp1d(x[<span style="color: #666666">-2</span>:], u[<span style="color: #666666">-2</span>:]) <span style="color: #408080; font-style: italic"># interplate at right bndry</span>
        
        u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> solver(u[:]) <span style="color: #408080; font-style: italic"># calculate numerical solution of interior</span>
        u[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u_bc(x[<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> a<span style="color: #666666">*</span>dt) <span style="color: #408080; font-style: italic"># interpolate along a characteristic to find the boundary value</span>
        
        un[i,:] <span style="color: #666666">=</span> u[:] <span style="color: #408080; font-style: italic"># storing the solution for plotting</span>
    
    u_solutions[k,:,:] <span style="color: #666666">=</span> un



<span style="color: #408080; font-style: italic">### Animation </span>
 
<span style="color: #408080; font-style: italic"># First set up the figure, the axis, and the plot element we want to animate</span>
fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
ax <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>axes(xlim<span style="color: #666666">=</span>(xmin,xmax), ylim<span style="color: #666666">=</span>(np<span style="color: #666666">.</span>min(un), np<span style="color: #666666">.</span>max(un)<span style="color: #666666">*1.1</span>))

lines<span style="color: #666666">=</span>[]     <span style="color: #408080; font-style: italic"># list for plot lines for solvers and analytical solutions</span>
legends<span style="color: #666666">=</span>[]   <span style="color: #408080; font-style: italic"># list for legends for solvers and analytical solutions</span>

<span style="color: #008000; font-weight: bold">for</span> solver <span style="color: #AA22FF; font-weight: bold">in</span> solvers:
    line, <span style="color: #666666">=</span> ax<span style="color: #666666">.</span>plot([], [])
    lines<span style="color: #666666">.</span>append(line)
    legends<span style="color: #666666">.</span>append(solver<span style="color: #666666">.</span>func_name)

line, <span style="color: #666666">=</span> ax<span style="color: #666666">.</span>plot([], []) <span style="color: #408080; font-style: italic">#add extra plot line for analytical solution</span>
lines<span style="color: #666666">.</span>append(line)
legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;Analytical&#39;</span>)

plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;x-coordinate [-]&#39;</span>)
plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;Amplitude [-]&#39;</span>)
plt<span style="color: #666666">.</span>legend(legends, loc<span style="color: #666666">=3</span>, frameon<span style="color: #666666">=</span><span style="color: #008000">False</span>)
 
<span style="color: #408080; font-style: italic"># initialization function: plot the background of each frame</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">init</span>():
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> lines:
        line<span style="color: #666666">.</span>set_data([], [])
    <span style="color: #008000; font-weight: bold">return</span> lines,

<span style="color: #408080; font-style: italic"># animation function.  This is called sequentially</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">animate</span>(i):
    <span style="color: #008000; font-weight: bold">for</span> k, line <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(lines):
        <span style="color: #008000; font-weight: bold">if</span> (k<span style="color: #666666">==0</span>):
            line<span style="color: #666666">.</span>set_data(x, un[i,:])
        <span style="color: #008000; font-weight: bold">else</span>:
            line<span style="color: #666666">.</span>set_data(x, uanalytical[i,:])
    <span style="color: #008000; font-weight: bold">return</span> lines,

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">animate_alt</span>(i):
    <span style="color: #008000; font-weight: bold">for</span> k, line <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(lines):
        <span style="color: #008000; font-weight: bold">if</span> (k<span style="color: #666666">==</span><span style="color: #008000">len</span>(lines)<span style="color: #666666">-1</span>):
            line<span style="color: #666666">.</span>set_data(x, uanalytical[i,:])
        <span style="color: #008000; font-weight: bold">else</span>:
            line<span style="color: #666666">.</span>set_data(x, u_solutions[k,i,:])
    <span style="color: #008000; font-weight: bold">return</span> lines,

 
<span style="color: #408080; font-style: italic"># call the animator.  blit=True means only re-draw the parts that have changed.</span>
anim <span style="color: #666666">=</span> animation<span style="color: #666666">.</span>FuncAnimation(fig, animate_alt, init_func<span style="color: #666666">=</span>init, frames<span style="color: #666666">=</span>Nt, interval<span style="color: #666666">=100</span>, blit<span style="color: #666666">=</span><span style="color: #008000">False</span>)
 
 
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>

<div>
<video  loop controls width='400' height='300' preload='none'>
    <source src='mov-ch6/step.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-ch6/step.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-ch6/step.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em>Result from code example above using a step function as the initial value</em></p>

<p>

<div>
<video  loop controls width='400' height='300' preload='none'>
    <source src='mov-ch6/sine.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-ch6/sine.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-ch6/sine.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em>Result from code example above using a sine squared function as the initial value <div id="video:sine"></div></em></p>

<p>
<!-- !split -->

<h2 id="___sec106">Order analysis on various schemes for the advection equation </h2>
The schemes presented have different theoretical order; <b>ftbs</b>: \( \mathcal{O}\left(\Delta x, \Delta t\right) \), 
<b>Lax-Friedrich</b>: \( \mathcal{O}\left(\Delta x^2, \Delta t\right) \), <b>Lax-Wendroff</b>:  
\( \mathcal{O}\left(\Delta x^2, \Delta t^2\right) \), <b>MacCormack</b>: \( \mathcal{O}\left(\Delta x^2, \Delta t^2\right) \).
For the linear advection equation the MacCormack and Lax-Wendroff schemes are identical, 
and we will thus only consider Lax-Wendroff in this section. Assuming the wavespeed 
\( a_0 \) is not very big, nor very small we will have \( \Delta t=\mathcal{O}\left(\Delta x\right) \), because of the
cfl constraint condition. Thus for the advection schemes the discretization error \( \epsilon \) will be of order min(\( p, q \)). Where
\( p \) is the spatial order, and \( q \) the temporal order. Thus we could say that ftbs, and Lax-Friedrich are both first order, 
and Lax-Wendroff is of second order. In order to determine the observed (dominating) order of accuracy of our schemes
we could adapt the same procedure outlined in Example [XXXX] in chapter 1, where we determined the observed order of accuracy of
ODEschemes. For the schemes solving the Advection equation the discretization error will be a combination of \( \Delta x \) and \( \Delta t \), 
however since \( \Delta t=\mathcal{O}\left(\Delta x\right) \), we may still assume the following expression for the discretization
error:
$$
\begin{align}
\label{eq:discretization__error_gen}
 \epsilon \approx Ch^p 
\end{align}
$$

where \( h \) is either \( \Delta x \) or \( \Delta t \), and \( p \) is the dominating order. Further we can calculate the discretization error,
observed for our schemes by successively refining \( h \) with a ratio \( r \), keeping the cfl-number constant. Thus refining \( \Delta x \)
and \( \Delta t \) with the same ratio \( r \).
Now dividing \( \epsilon_{n-1} \) by \( \epsilon_{n} \) and taking the log on both sides and rearranging lead to the following expression
for the observed order of accuracy:
$$
\begin{align}
 p = \frac{log\left(\frac{{\epsilon}_{n-1}}{{\epsilon}_n} \right)}{log\left(r \right)} = log_r\left(\frac{\epsilon_{n-1}}{\epsilon_n} \right)
 \nonumber
\end{align}
$$

To determine the observed discretization error we will use the root mean square error of all
our discrete soultions:
$$
\begin{align}
 E = \sqrt{\frac{1}{N}\sum\limits_{i=1}^N\left(\hat{f}-f\right)^2} 
 \nonumber
\end{align}
$$

where N is the number of sampling points, \( \hat f \) is the numerical-, and \( f \) is the analytical solution.
A code example performing this test on selected advections schemes, is showed below. As can be seen in 
Figure <a href="#fig:convergence_rate_Advection">97</a>, the Lax Wendroff scheme quickly converge to it's theoretical order, whereas 
the ftbs and Lax Friedrich scheme converges to their theoretical order more slowly.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 97:  The root mean square error \( E \) for the various advection schemes as a function of the number of spatial nodes (top), and corresponding observed convergence rates (bottom). <div id="fig:convergence_rate_Advection"></div> </p></center>
<p><img src="fig-ch6/Advection_Schemes_Convergence.png" align="bottom" width=600></p>
</center>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_convergence_MES</span>():
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> log 
        <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> sqrt
        <span style="color: #008000; font-weight: bold">global</span> c, dt, dx, a
        
        <span style="color: #408080; font-style: italic"># Change default values on plots</span>
        LNWDT<span style="color: #666666">=2</span>; FNT<span style="color: #666666">=13</span>
        plt<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;lines.linewidth&#39;</span>] <span style="color: #666666">=</span> LNWDT; plt<span style="color: #666666">.</span>rcParams[<span style="color: #BA2121">&#39;font.size&#39;</span>] <span style="color: #666666">=</span> FNT
        
        a <span style="color: #666666">=</span> <span style="color: #666666">1.0</span> <span style="color: #408080; font-style: italic"># wave speed</span>
        tmin, tmax <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>, <span style="color: #666666">1</span> <span style="color: #408080; font-style: italic"># start and stop time of simulation</span>
        xmin, xmax <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>, <span style="color: #666666">2.0</span> <span style="color: #408080; font-style: italic"># start and end of spatial domain</span>
        Nx <span style="color: #666666">=</span> <span style="color: #666666">160</span> <span style="color: #408080; font-style: italic"># number of spatial points</span>
        c <span style="color: #666666">=</span> <span style="color: #666666">0.8</span> <span style="color: #408080; font-style: italic"># courant number, need c&lt;=1 for stability</span>
    
        <span style="color: #408080; font-style: italic"># Discretize</span>
        x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(xmin, xmax, Nx <span style="color: #666666">+</span> <span style="color: #666666">1</span>) <span style="color: #408080; font-style: italic"># discretization of space</span>
        dx <span style="color: #666666">=</span> <span style="color: #008000">float</span>((xmax<span style="color: #666666">-</span>xmin)<span style="color: #666666">/</span>Nx) <span style="color: #408080; font-style: italic"># spatial step size</span>
        dt <span style="color: #666666">=</span> c<span style="color: #666666">/</span>a<span style="color: #666666">*</span>dx <span style="color: #408080; font-style: italic"># stable time step calculated from stability requirement</span>
        time <span style="color: #666666">=</span> np<span style="color: #666666">.</span>arange(tmin, tmax <span style="color: #666666">+</span> dt, dt) <span style="color: #408080; font-style: italic"># discretization of time</span>
        
        init_funcs <span style="color: #666666">=</span> [init_step, init_sine4] <span style="color: #408080; font-style: italic"># Select stair case function (0) or sin^4 function (1)</span>
        f <span style="color: #666666">=</span> init_funcs[<span style="color: #666666">1</span>]
        
        solvers <span style="color: #666666">=</span> [ftbs, lax_friedrich, lax_wendroff]
        
        errorDict <span style="color: #666666">=</span> {} <span style="color: #408080; font-style: italic"># empty dictionary to be filled in with lists of errors</span>
        orderDict <span style="color: #666666">=</span> {}
        
        <span style="color: #008000; font-weight: bold">for</span> solver <span style="color: #AA22FF; font-weight: bold">in</span> solvers:
            errorDict[solver<span style="color: #666666">.</span>func_name] <span style="color: #666666">=</span> [] <span style="color: #408080; font-style: italic"># for each  solver(key) assign it with value=[], an empty list (e.g: &#39;ftbs&#39;=[])</span>
            orderDict[solver<span style="color: #666666">.</span>func_name] <span style="color: #666666">=</span> []
            
        hx <span style="color: #666666">=</span> [] <span style="color: #408080; font-style: italic"># empty list of spatial step-length</span>
        ht <span style="color: #666666">=</span> [] <span style="color: #408080; font-style: italic"># empty list of temporal step-length</span>
        
        Ntds <span style="color: #666666">=</span> <span style="color: #666666">5</span> <span style="color: #408080; font-style: italic"># number of grid/dt refinements</span>
        <span style="color: #408080; font-style: italic"># iterate Ntds times:</span>
        <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Ntds):
            hx<span style="color: #666666">.</span>append(dx)
            ht<span style="color: #666666">.</span>append(dt)
            
            <span style="color: #008000; font-weight: bold">for</span> k, solver <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(solvers): <span style="color: #408080; font-style: italic"># Solve for all solvers in list</span>
                u <span style="color: #666666">=</span> f(x) <span style="color: #408080; font-style: italic"># initial value of u is init_func(x)</span>
                error <span style="color: #666666">=</span> <span style="color: #666666">0</span> 
                samplePoints <span style="color: #666666">=</span> <span style="color: #666666">0</span>
                
                <span style="color: #008000; font-weight: bold">for</span> i, t <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(time[<span style="color: #666666">1</span>:]):
                    u_bc <span style="color: #666666">=</span> interpolate<span style="color: #666666">.</span>interp1d(x[<span style="color: #666666">-2</span>:], u[<span style="color: #666666">-2</span>:]) <span style="color: #408080; font-style: italic"># interplate at right bndry</span>
                    u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> solver(u[:]) <span style="color: #408080; font-style: italic"># calculate numerical solution of interior</span>
                    u[<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u_bc(x[<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> a<span style="color: #666666">*</span>dt) <span style="color: #408080; font-style: italic"># interpolate along a characteristic to find the boundary value</span>

                    error <span style="color: #666666">+=</span> np<span style="color: #666666">.</span>sum((u <span style="color: #666666">-</span> f(x<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t))<span style="color: #666666">**2</span>) <span style="color: #408080; font-style: italic"># add error from this timestep</span>
                    samplePoints <span style="color: #666666">+=</span> <span style="color: #008000">len</span>(u)

                error <span style="color: #666666">=</span> sqrt(error<span style="color: #666666">/</span>samplePoints) <span style="color: #408080; font-style: italic"># calculate rms-error</span>
                errorDict[solver<span style="color: #666666">.</span>func_name]<span style="color: #666666">.</span>append(error)
                
                <span style="color: #008000; font-weight: bold">if</span> n<span style="color: #666666">&gt;0</span>:
                    previousError <span style="color: #666666">=</span> errorDict[solver<span style="color: #666666">.</span>func_name][n<span style="color: #666666">-1</span>]
                    orderDict[solver<span style="color: #666666">.</span>func_name]<span style="color: #666666">.</span>append(log(previousError<span style="color: #666666">/</span>error)<span style="color: #666666">/</span>log(<span style="color: #666666">2</span>))            
            
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&quot; finished iteration {0} of {1}, dx = {2}, dt = {3}, tsample = {4}&quot;</span><span style="color: #666666">.</span>format(n<span style="color: #666666">+1</span>, Ntds, dx, dt, t)
            <span style="color: #408080; font-style: italic"># refine grid and dt:   </span>
            Nx <span style="color: #666666">*=</span> <span style="color: #666666">2</span>
            x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(xmin, xmax, Nx<span style="color: #666666">+1</span>) <span style="color: #408080; font-style: italic"># new x-array, twice as big as the previous</span>
            dx <span style="color: #666666">=</span> <span style="color: #008000">float</span>((xmax<span style="color: #666666">-</span>xmin)<span style="color: #666666">/</span>Nx) <span style="color: #408080; font-style: italic"># new spatial step size, half the value of the previous</span>
            dt <span style="color: #666666">=</span> c<span style="color: #666666">/</span>a<span style="color: #666666">*</span>dx <span style="color: #408080; font-style: italic"># new stable time step </span>
            time <span style="color: #666666">=</span> np<span style="color: #666666">.</span>arange(tmin, tmax <span style="color: #666666">+</span> dt, dt) <span style="color: #408080; font-style: italic"># discretization of time</span>
        
        <span style="color: #408080; font-style: italic"># Plot error-values and corresponding order-estimates:</span>
        fig , axarr <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>subplots(<span style="color: #666666">2</span>, <span style="color: #666666">1</span>, squeeze<span style="color: #666666">=</span><span style="color: #008000">False</span>)
        lstyle <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;b&#39;</span>, <span style="color: #BA2121">&#39;r&#39;</span>, <span style="color: #BA2121">&#39;g&#39;</span>, <span style="color: #BA2121">&#39;m&#39;</span>]
        legendList <span style="color: #666666">=</span> []
        
        N <span style="color: #666666">=</span> Nx<span style="color: #666666">/2**</span>(Ntds <span style="color: #666666">+</span> <span style="color: #666666">1</span>)
        N_list <span style="color: #666666">=</span> [N<span style="color: #666666">*2**</span>i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Ntds<span style="color: #666666">+1</span>)]
        N_list <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(N_list)
        
        epsilonN <span style="color: #666666">=</span> [i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Ntds)]
        epsilonlist <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;$\epsilon_{0} , \epsilon_{1}$&#39;</span><span style="color: #666666">.</span>format(<span style="color: #008000">str</span>(i), <span style="color: #008000">str</span>(i<span style="color: #666666">+1</span>)) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Ntds)]
        
        <span style="color: #008000; font-weight: bold">for</span> k, solver <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(solvers):
            axarr[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>plot(N_list, np<span style="color: #666666">.</span>log10(np<span style="color: #666666">.</span>asarray(errorDict[solver<span style="color: #666666">.</span>func_name])),lstyle[k])
            axarr[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>plot(epsilonN, orderDict[solver<span style="color: #666666">.</span>func_name],lstyle[k])
            
            legendList<span style="color: #666666">.</span>append(solver<span style="color: #666666">.</span>func_name)
        
        
        
        axarr[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>axhline(<span style="color: #666666">1.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>Ntds<span style="color: #666666">-2</span>, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
        axarr[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>axhline(<span style="color: #666666">2.0</span>, xmin<span style="color: #666666">=0</span>, xmax<span style="color: #666666">=</span>Ntds<span style="color: #666666">-2</span>, linestyle<span style="color: #666666">=</span><span style="color: #BA2121">&#39;:&#39;</span>, color<span style="color: #666666">=</span><span style="color: #BA2121">&#39;k&#39;</span>)
</pre></div>

<h3 id="___sec107">Separating spatial and temporal discretization error </h3>

<p>
The test performed in the previous example verify the dominating order of accuracy of the advection schemes. 
However in order to verify our implementations of the various schemes we would like to ensure that both the 
observed temporal- and spatial order are close to the theoretical orders. The expression for the discretization error in 
\eqref{eq:discretization__error_gen} is a simplification of the more general expression
$$
\begin{align}
\label{eq:discretization__error_gen_hxht}
 \epsilon \approx C_x \: h_x^p + C_t \: h_t^q 
\end{align}
$$

where \( C_x \), and \( C_t \) are constants, \( h_x \) and \( h_t \) are the spatial- and temporal step lengths and \( p \) and \( q \) are the 
spatial- and temporal orders respectively. We are interested in confirming that \( p \) is close to the theoretical spatial 
order of the scheme, and that \( q \) is close to the theoretical temporal order of the scheme. The method of doing this is 
not necessarily straight forward, especially since \( h_t \) and \( h_x \) are coupled through the cfl-constraint condition. 
In chapter one we showed that we were able to verify \( C \) and \( p \) in the case of only one step-length dependency 
(time or space), by solving two nonlinear equations for two unknowns using a Newton-Rhapson solver. To expand this method
would now involve solving four nonlinear algebraic equations for the four unknowns \( C_x, C_t, p, q \). 
However since it is unlikely that the observed discretization error match the expression in 
\eqref{eq:discretization__error_gen_hxht} exactly, we now sugest a method based on optimization and curve-fitting.  
From the previous code example we calculated the root mean square error \( E(h_x, h_t) \) of the schemes by succecively refining
\( hx \) and  \( ht \) by a ratio \( r \). We now assume that \( E \) is related to \( C_x, C_t, p, q \) as in 
\eqref{eq:discretization__error_gen_hxht}. In other words we would like to find the parameters \( C_x, C_t, p, q \), 
so that the difference between our caluclated errors \( E(hx, ht) \), and the function 
\( \epsilon\left(h_x, h_t;C_x, p, C_t, q\right) = C_x \: h_x^p + C_t \: h_t^q \) is as small as possible. This may be done by
minimizing the sum (\( S \)) of squared residuals of \( E \) and \( \epsilon \):
$$
\begin{align}
 S = \sum\limits_{i=1}^N r_i^2, \quad r_i= E_i - \epsilon\left(h_x, h_t;C_x, p, C_t, q\right)_i
 \nonumber
\end{align}
$$

The python module scipy.optimize has many methods for parameter optimization and curve-fitting. In the code example below
we use scipy.optimize.curve_fit which fits a function "f(x;params)" to a set of data "y-data" using a 
Levenberg-Marquardt algorithmwith a least square minimization criteria. In the code example below we start by 
loading the calculated root mean square errors \( E\left(h_{x}, h_{t}\right) \) of the schemes from  "advection_scheme_errors.txt", 
which where calculated in the same manner as in the previous example. As can be seen by Figure 
<a href="#fig:convergence_rate_Advection">97</a> the ftbs, and Lax Friedriech scheme takes a while before they are in their 
asymptotic range (area where they converge at a constant rate). In "advection_scheme_errors.txt"
we have computed \( E\left(h_{x}, h_{t}\right) \) up to \( N_x = 89120 \) in which all schemes should be close to their asymptotic range. 
This procedure is demonstrated in the code example below in which the following expressions for the errors are obtained: 
$$
\begin{align}
\label{eq:discretization__error_opt_hxht}
 ftbs \rightarrow \epsilon = 1.3 \: h_x^{0.98} + 6.5 \: h_t^{0.98} \\ 
 lax Friedrich \rightarrow \epsilon = - 1484 \: h_x^{1.9} + 26 \: h_t^{1.0} 
\label{_auto81}\\ 
 lax Wendroff \rightarrow \epsilon = - 148 \: h_x^{2.0} + 364. \: h_t^{2.0} 
\label{_auto82}
\end{align}
$$

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scipy.optimize</span> <span style="color: #008000; font-weight: bold">import</span> curve_fit
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> symbols, lambdify, latex

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">optimize_error_cxct</span>(errorList, hxList, 
                        htList, p<span style="color: #666666">=1.0</span>, q<span style="color: #666666">=1.0</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Function that optimimze the values Cx and Ct in the expression</span>
<span style="color: #BA2121; font-style: italic">        E = epsilon = Cx hx^p + Ct ht^q, assuming p and q are known, </span>
<span style="color: #BA2121; font-style: italic">        using scipy&#39;s optimization tool curve_fit</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">        Args:</span>
<span style="color: #BA2121; font-style: italic">            errorList(array): array of calculated numerical discretization errors E</span>
<span style="color: #BA2121; font-style: italic">            hxList(array): array of spatial step lengths corresponding to errorList</span>
<span style="color: #BA2121; font-style: italic">            htList(array): array of temporal step lengths corresponding to errorList</span>
<span style="color: #BA2121; font-style: italic">            p (Optional[float]): spatial order. Assumed to be equal to theoretical value</span>
<span style="color: #BA2121; font-style: italic">            q (Optional[float]): temporal order. Assumed to be equal to theoretical value</span>

<span style="color: #BA2121; font-style: italic">        Returns:</span>
<span style="color: #BA2121; font-style: italic">            Cx0(float): the optimized values of Cx</span>
<span style="color: #BA2121; font-style: italic">            Ct0(float): the optimized values of Ct</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">func</span>(h, Cx, Ct):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; function to be matched with ydata:</span>
<span style="color: #BA2121; font-style: italic">            The function has to be on the form func(x, parameter1, parameter2,...,parametern)</span>
<span style="color: #BA2121; font-style: italic">            where where x is the independent variable(s), and parameter1-n are the parameters to be optimized.</span>
<span style="color: #BA2121; font-style: italic">        &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> Cx<span style="color: #666666">*</span>h[<span style="color: #666666">0</span>]<span style="color: #666666">**</span>p <span style="color: #666666">+</span> Ct<span style="color: #666666">*</span>h[<span style="color: #666666">1</span>]<span style="color: #666666">**</span>q
    
    
    x0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">1</span>,<span style="color: #666666">2</span>]) <span style="color: #408080; font-style: italic"># initial guessed values for Cx and Ct</span>
    xdata <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([hxList, htList])<span style="color: #408080; font-style: italic"># independent variables</span>
    ydata <span style="color: #666666">=</span> errorList <span style="color: #408080; font-style: italic"># data to be matched with expression in func</span>
    Cx0, Ct0 <span style="color: #666666">=</span> curve_fit(func, xdata, ydata, x0)[<span style="color: #666666">0</span>] <span style="color: #408080; font-style: italic"># call scipy optimization tool curvefit</span>

    <span style="color: #008000; font-weight: bold">return</span> Cx0, Ct0

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">optimize_error</span>(errorList, hxList, htList, 
                   Cx0, p0, Ct0, q0):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Function that optimimze the values Cx, p Ct and q in the expression</span>
<span style="color: #BA2121; font-style: italic">        E = epsilon = Cx hx^p + Ct ht^q, assuming p and q are known, </span>
<span style="color: #BA2121; font-style: italic">        using scipy&#39;s optimization tool curve_fit</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">        Args:</span>
<span style="color: #BA2121; font-style: italic">            errorList(array): array of calculated numerical discretization errors E</span>
<span style="color: #BA2121; font-style: italic">            hxList(array): array of spatial step lengths corresponding to errorList</span>
<span style="color: #BA2121; font-style: italic">            htList(array): array of temporal step lengths corresponding to errorList</span>
<span style="color: #BA2121; font-style: italic">            Cx0 (float): initial guessed value of Cx</span>
<span style="color: #BA2121; font-style: italic">            p (float): initial guessed value of p</span>
<span style="color: #BA2121; font-style: italic">            Ct0 (float): initial guessed value of Ct</span>
<span style="color: #BA2121; font-style: italic">            q (float): initial guessed value of q</span>

<span style="color: #BA2121; font-style: italic">        Returns:</span>
<span style="color: #BA2121; font-style: italic">            Cx(float): the optimized values of Cx</span>
<span style="color: #BA2121; font-style: italic">            p (float): the optimized values of p</span>
<span style="color: #BA2121; font-style: italic">            Ct(float): the optimized values of Ct</span>
<span style="color: #BA2121; font-style: italic">            q (float): the optimized values of q</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    
    
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">func</span>(h, gx, p, gt, q):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; function to be matched with ydata:</span>
<span style="color: #BA2121; font-style: italic">            The function has to be on the form func(x, parameter1, parameter2,...,parametern)</span>
<span style="color: #BA2121; font-style: italic">            where where x is the independent variable(s), and parameter1-n are the parameters to be optimized.</span>
<span style="color: #BA2121; font-style: italic">        &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">return</span> gx<span style="color: #666666">*</span>h[<span style="color: #666666">0</span>]<span style="color: #666666">**</span>p <span style="color: #666666">+</span> gt<span style="color: #666666">*</span>h[<span style="color: #666666">1</span>]<span style="color: #666666">**</span>q
    
    
    x0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([Cx0, p0, Ct0, q0]) <span style="color: #408080; font-style: italic"># initial guessed values for Cx, p, Ct and q</span>
    xdata <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([hxList, htList]) <span style="color: #408080; font-style: italic"># independent variables</span>
    ydata <span style="color: #666666">=</span> errorList <span style="color: #408080; font-style: italic"># data to be matched with expression in func</span>
    
    gx, p, gt, q <span style="color: #666666">=</span> curve_fit(func, xdata, ydata, x0)[<span style="color: #666666">0</span>] <span style="color: #408080; font-style: italic"># call scipy optimization tool curvefit</span>
    gx, p, gt, q <span style="color: #666666">=</span> <span style="color: #008000">round</span>(gx,<span style="color: #666666">2</span>), <span style="color: #008000">round</span>(p, <span style="color: #666666">2</span>), <span style="color: #008000">round</span>(gt,<span style="color: #666666">2</span>), <span style="color: #008000">round</span>(q, <span style="color: #666666">2</span>)
    
    <span style="color: #008000; font-weight: bold">return</span> gx, p, gt, q

<span style="color: #408080; font-style: italic"># Program starts here:</span>

<span style="color: #408080; font-style: italic"># empty lists, to be filled in with values from &#39;advection_scheme_errors.txt&#39;</span>
hxList <span style="color: #666666">=</span> [] 
htList <span style="color: #666666">=</span> []

E_ftbs <span style="color: #666666">=</span> []
E_lax_friedrich <span style="color: #666666">=</span> []
E_lax_wendroff <span style="color: #666666">=</span> []

lineNumber <span style="color: #666666">=</span> <span style="color: #666666">1</span>

<span style="color: #008000; font-weight: bold">with</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;advection_scheme_errors.txt&#39;</span>, <span style="color: #BA2121">&#39;r&#39;</span>) <span style="color: #008000; font-weight: bold">as</span> FILENAME:
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; Open advection_scheme_errors.txt for reading.</span>
<span style="color: #BA2121; font-style: italic">        structure of file:</span>
<span style="color: #BA2121; font-style: italic">        hx    ht    E_ftbs    E_lax_friedrich    E_lax_wendroff</span>
<span style="color: #BA2121; font-style: italic">        </span>
<span style="color: #BA2121; font-style: italic">        with the first line containing these headers, and the next lines containing</span>
<span style="color: #BA2121; font-style: italic">        the corresponding values.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># iterate all lines in FILENAME:</span>
    <span style="color: #008000; font-weight: bold">for</span> line <span style="color: #AA22FF; font-weight: bold">in</span> FILENAME:
        <span style="color: #008000; font-weight: bold">if</span> lineNumber <span style="color: #666666">==1</span>:
            <span style="color: #408080; font-style: italic"># skip first line which contain headers</span>
            lineNumber <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
        <span style="color: #008000; font-weight: bold">else</span>:
            lineList <span style="color: #666666">=</span> line<span style="color: #666666">.</span>split() <span style="color: #408080; font-style: italic"># sort each line in a list: lineList = [hx, ht, E_ftbs, E_lax_friedrich, E_lax_wendroff]</span>
            
            <span style="color: #408080; font-style: italic"># add values from this line to the lists</span>
            hxList<span style="color: #666666">.</span>append(<span style="color: #008000">float</span>(lineList[<span style="color: #666666">0</span>]))
            htList<span style="color: #666666">.</span>append(<span style="color: #008000">float</span>(lineList[<span style="color: #666666">1</span>]))
            
            E_ftbs<span style="color: #666666">.</span>append(<span style="color: #008000">float</span>(lineList[<span style="color: #666666">2</span>]))
            E_lax_friedrich<span style="color: #666666">.</span>append(<span style="color: #008000">float</span>(lineList[<span style="color: #666666">3</span>]))
            E_lax_wendroff<span style="color: #666666">.</span>append(<span style="color: #008000">float</span>(lineList[<span style="color: #666666">4</span>]))
            
            lineNumber <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
      
FILENAME<span style="color: #666666">.</span>close()

<span style="color: #408080; font-style: italic"># convert lists to numpy arrays:</span>
hxList <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(hxList) 
htList <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(htList) 

E_ftbs <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(E_ftbs) 
E_lax_friedrich <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(E_lax_friedrich) 
E_lax_wendroff <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(E_lax_wendroff) 


ErrorList <span style="color: #666666">=</span> [E_ftbs, E_lax_friedrich, E_lax_wendroff]
schemes <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;ftbs&#39;</span>, <span style="color: #BA2121">&#39;lax_friedrich&#39;</span>, <span style="color: #BA2121">&#39;lax_wendroff&#39;</span>]

p_theoretical <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">2</span>, <span style="color: #666666">2</span>] <span style="color: #408080; font-style: italic"># theoretical spatial orders</span>
q_theoretical <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>] <span style="color: #408080; font-style: italic"># theoretical temporal orders</span>

h_x, h_t <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;h_x h_t&#39;</span>)

XtickList <span style="color: #666666">=</span> [i <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(hxList)<span style="color: #666666">+1</span>)]
Xticknames <span style="color: #666666">=</span> [<span style="color: #BA2121">r&#39;$(h_x , h_t)_{0}$&#39;</span><span style="color: #666666">.</span>format(<span style="color: #008000">str</span>(i)) <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(hxList)<span style="color: #666666">+1</span>)]
lstyle <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;b&#39;</span>, <span style="color: #BA2121">&#39;r&#39;</span>, <span style="color: #BA2121">&#39;g&#39;</span>, <span style="color: #BA2121">&#39;m&#39;</span>]
legendList <span style="color: #666666">=</span> []

<span style="color: #408080; font-style: italic"># Optimize Cx, p, Ct, q for every scheme</span>
<span style="color: #008000; font-weight: bold">for</span> k, E <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(ErrorList):
    
    <span style="color: #408080; font-style: italic"># optimize using only last 5 values of E and h for the scheme, as the first values may be outside asymptotic range:</span>
    
    Cx0, Ct0 <span style="color: #666666">=</span> optimize_error_cxct(E[<span style="color: #666666">-5</span>:], hxList[<span style="color: #666666">-5</span>:], htList[<span style="color: #666666">-5</span>:], 
                                   p<span style="color: #666666">=</span>p_theoretical[k], q<span style="color: #666666">=</span>q_theoretical[k]) <span style="color: #408080; font-style: italic"># Find appropriate initial guesses for Cx and Ct </span>
    
    Cx, p, Ct, q <span style="color: #666666">=</span> optimize_error(E[<span style="color: #666666">-5</span>:], hxList[<span style="color: #666666">-5</span>:], htList[<span style="color: #666666">-5</span>:], 
                                  Cx0, p_theoretical[k], Ct0, q_theoretical[k]) <span style="color: #408080; font-style: italic"># Optimize for all parameters Cx, p, Ct, q</span>

    <span style="color: #408080; font-style: italic"># create sympy expressions of e, ex and et:</span>
    errorExpr <span style="color: #666666">=</span> Cx<span style="color: #666666">*</span>h_x<span style="color: #666666">**</span>p <span style="color: #666666">+</span> Ct<span style="color: #666666">*</span>h_t<span style="color: #666666">**</span>q
    
    <span style="color: #008000; font-weight: bold">print</span> errorExpr
    errorExprHx <span style="color: #666666">=</span> Cx<span style="color: #666666">*</span>h_x<span style="color: #666666">**</span>p 
    errorExprHt <span style="color: #666666">=</span> Ct<span style="color: #666666">*</span>h_t<span style="color: #666666">**</span>q
    
    <span style="color: #408080; font-style: italic"># convert e, ex and et to python functions:</span>
    errorFunc <span style="color: #666666">=</span> lambdify([h_x, h_t], errorExpr)
    errorFuncHx <span style="color: #666666">=</span> lambdify([h_x], errorExprHx)
    errorFuncHt <span style="color: #666666">=</span> lambdify([h_t], errorExprHt)
    
    <span style="color: #408080; font-style: italic"># plotting:</span>
    fig , ax <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>subplots(<span style="color: #666666">2</span>, <span style="color: #666666">1</span>, squeeze<span style="color: #666666">=</span><span style="color: #008000">False</span>)
    
    ax[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>plot(XtickList, np<span style="color: #666666">.</span>log10(E),lstyle[k])
    ax[<span style="color: #666666">0</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>plot(XtickList, np<span style="color: #666666">.</span>log10(errorFunc(hxList, htList)),lstyle[k] <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;--&#39;</span>)
    
    ax[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>plot(XtickList[<span style="color: #666666">-5</span>:], E[<span style="color: #666666">-5</span>:],lstyle[k])
    ax[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>plot(XtickList[<span style="color: #666666">-5</span>:], errorFunc(hxList, htList)[<span style="color: #666666">-5</span>:],lstyle[k] <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;--&#39;</span>)
    ax[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>plot(XtickList[<span style="color: #666666">-5</span>:], errorFuncHx(hxList[<span style="color: #666666">-5</span>:]), lstyle[k] <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;-.&#39;</span>)
    ax[<span style="color: #666666">1</span>][<span style="color: #666666">0</span>]<span style="color: #666666">.</span>plot(XtickList[<span style="color: #666666">-5</span>:], errorFuncHt(htList[<span style="color: #666666">-5</span>:]),lstyle[k] <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;:&#39;</span>)
</pre></div>
<p>
<!-- FIGURE:[fig-ch6/Optimize_errors_ftbs.png, width=600] Optimized error expressions for ftbs scheme -->

<p>
<!-- FIGURE:[fig-ch6/Optimize_errors_lax_friedrich.png, width=600] Optimized error expressions for the Lax Friedrich scheme -->

<p>
<!-- FIGURE:[fig-ch6/Optimize_errors_lax_wendroff.png, width=600] Optimized error expressions for the Lax Wendroff scheme -->

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 98:  Optimized error expressions for all schemes. Test using doconce combine images </p></center>
<p><img src="fig-ch6/Combined_Transparant.png" align="bottom" width=1100 height=400></p>
</center>

<p>
<!-- FIGURE:[fig-ch6/sine_it/Combined.png, width=1100 height=400] The solutions at time t=T=1 for different grids corresponding to the code-example above. A \( sin^4 \) wave with period \( T= 0.4 \) travelling with wavespeed \( a \) = 1. The solutions were calculated with a cfl-number of 0.8 -->

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 99:  The solutions at time t=T=1 for different grids corresponding to the code-example above. A \( sin^4 \) wave with period \( T= 0.4 \) travelling with wavespeed \( a \) = 1. The solutions were calculated with a cfl-number of 0.8 <div id="fig:sine_iterate"></div> </p></center>
<p><img src="fig-ch6/sine_it/Combined_transparent.png" align="bottom" width=1100 height=400></p>
</center>

<p>
<!-- !split -->

<h2 id="___sec108">Flux limiters </h2>

<p>
Looking at the previous examples and especially Figure <a href="#fig:sine_iterate">99</a> we clearly see the difference between 
first and second order schemes. Using a first order scheme require a very high resolution (and/or a cfl number close to one) 
in order to get a satisfying solution. What characterizes the first order schemes is that they are highly diffusive 
(loss of amplitude). Unless the resolution is very high or the cfl-number is very close to one, the first order solutions 
will lose amplitude as time passes. This is evident in the animation (<a href="#video:sine">video:sine</a>). (To see how the different schemes behave 
with different combinations of CFL-number, and frequencies try the sliders app located in the git repo in chapter 6.
<!-- begin inline comment -->
<font color="red">(<b>Fredrik 16</b>: add a link or something?)</font>
<!-- end inline comment -->
) However if 
the solution contain big gradients or discontinuities, the second order schemes fail, and introduce nonphysical oscillations 
due to their dispersive nature. In other words the second order schemes give a much higher accuracy on smooth solutions, than 
the first order schemes, whereas the first order schemes behave better in regions containing sharp gradients or discontinuities. 
First order upwind methods are said to behave monotonically varying in regions where the solution should be monotone (cite:Second Order Positive Schemes by means of Flux Limiters for the Advection Equation.pdf). 
Figure <a href="#fig:adv_box">fig:adv_box</a> show the behavior of the different advection schemes in a solution containing discontinuities; 
oscillations arises near discontinuities for the Lax-Wendroff scheme, independent of the resolution. The dissipative nature of 
the first order schemes are evident in solutions with "low" resolution.

<p>
<!-- FIGURE:[fig-ch6/step_it/Combined.png, width=1100 height=400] Effect on refining grid on a solution containing sharp edges and discontinuities -->

<p>
<!-- FIGURE:[fig-ch6/step_it/Combined_transparent2.png, width=1100 height=400] Effect of refining grid on a solution containing discontinuities; a square box moving with wave speed a=1. Solutions are showed at t=1, using a cfl-number of 0.8. <div id="fig:adv_box"></div> -->

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 100:  Effect of refining grid on a solution containing discontinuities; a square box moving with wave speed a=1. Solutions are showed at t=1, using a cfl-number of 0.8. <div id="fig:adv_box_2"></div> </p></center>
<p><img src="fig-ch6/step_it/Combined_transparent3.png" align="bottom" width=1100 height=400></p>
</center>

<p>
The idea of Flux limiters is to combine the best features of high and low order schemes. In general a flux limiter method 
can be obtained by combining any low order flux \( F_{l} \), and high order flux \( F_h \). Further it is convenient/required to write the 
schemes in the so the so-called conservative form as in \eqref{eq:conservative_methods} repeated here for convenience

$$
\begin{align}
u_j^{n+1} = u_j^{n} + \frac{\Delta t}{\Delta x} \left ( F_{j-1/2} - F_{j+1/2} \right ) 
\label{eq:conservative_methods2}
\end{align}
$$

<p>

<!-- begin inline comment -->
<font color="red">(<b>Fredrik 17</b>: do we need clarifying more about conservative methods and Fluxes calculated at midpoints and halftime?)</font>
<!-- end inline comment -->

<br />
The general flux limiter method solves \eqref{eq:conservative_methods2} with the following definitions of the fluxes \( F_{i-1/2} \) and  \( F_{i+1/2} \)

$$
\begin{align}
F_{j-1/2} = F_l(j-1/2) + \phi(r_{j-1/2})\big[F_h(j-1/2) - F_l(j-1/2)\big] 
\label{_auto83}\\ 
F_{j+1/2} = F_l(j+1/2) + \phi(r_{j+1/2})\big[F_h(j+1/2) - F_l(j+1/2)\big]
\label{eq:Flux_limiter_Flux}
\end{align}
$$

<p>
where \( \phi(r) \) is the limiter function, and \( r \) is a measure of the smoothness of the solution. \( \phi \) is designed to be equal
to one in regions where the solution is smooth, in which \( F \) reduces to \( F_h \), and a pure high order scheme. In regions where
the solution is not smooth (i.e. in regions containing sharp gradients and discontinuities ) \( \phi \) is designed to be equal
to zero, in which \( F \) reduces to \( F_l \), and a pure low order scheme. As a measure of  the smoothness, \( r \) is commonly taken to be 
the ratio of consecutive gradients

$$
\begin{equation}
r_{j-1/2} = \frac{u_{j-1}-u_{j-2}}{u_{j}-u_{j-1}} \\ 
r_{j+1/2} = \frac{u_{j}-u_{j-1}}{u_{j+1}-u_{j}}
\label{eq:Flux_limiter_smoothness}
\end{equation}
$$

<p>
In regions where the solution is constant (zero gradients), some special treatment of \( r \) is needed to avoid division by zero. 
However the choice of this treatment is not important since in regions where the solution is not changing, 
using a high or low order method is irrelevant.

<h3 id="___sec109">Lax Wendroff limiters </h3>

<p>
The Lax Wendroff scheme for the advection equation may be written in the form of \eqref{eq:conservative_methods2} by defining the 
Lax Wendroff Flux \( F_{LW} \) as:

$$
\begin{align}
F_{LW}\left(j-1/2\right) = F_{LW}\left(u_{j-1}, u_{j}\right) = a\:u_{j-1} + \frac{1}{2}a\left(1-\frac{\Delta t}{\Delta x}a\right)\big[ u_{j}-u_{j-1}\big] 
\label{_auto84}\\ 
F_{LW}\left(j+1/2\right) = F_{LW}\left(u_{j}, u_{j+1}\right) = a\:u_{j} + \frac{1}{2}a\left(1-\frac{\Delta t}{\Delta x}a\right)\big[ u_{j+1}-u_{j}\big] 
\label{eq:Lax_Flux}
\end{align}
$$

<p>
which may be showed to be the Lax-Wendroff two step method condensed to a one step method as outlined in 
(<a href="#ch:6_Lax-Wendroff_nonlin">Lax-Wendroff for non-linear systems of hyperbolic PDEs</a>). Notice the term \( \frac{\Delta t}{\Delta x}a = c \). Now the Lax Wendroff flux 
assumes that of an upwind flux (\( a\:u_{j-1} \) or \( a\:u_{j} \)) with an additional anti diffusive term 
(\( \frac{1}{2}a\left(1-c\right)\big[ u_{j}-u_{j-1}\big] \) for \( F_{LW}\left(j-1/2\right) \)).
A flux limited version of the Lax-Wendroff scheme could thus be obtained by adding a limiter function \( \phi \) to the second term

$$
\begin{align}
F\left(j-1/2\right) = a\:u_{j-1} + \phi\left(r_{j-1/2}\right)\frac{1}{2}a\left(1-c\right)\big[ u_{j}-u_{j-1}\big] 
\label{_auto85}\\ 
F\left(j+1/2\right) = a\:u_{j} + \phi\left(r_{j+1/2}\right)\frac{1}{2}a\left(1-c\right)\big[ u_{j+1}-u_{j}\big] 
\label{eq:Flux_limiter_Lax_Flux}
\end{align}
$$

<p>
When \( \phi=0 \) the scheme is the upwind scheme, and when \( \phi=1 \) the scheme is the Lax-Wendroff scheme. Many different 
limiter functions have been proposed, the optimal function however is dependent on the solution. Sweby 
(
<!-- begin inline comment -->
<font color="red">(<b>Fredrik 18</b>: Cite sweby)</font>
<!-- end inline comment -->
) showed that in order for the Flux limiting scheme to possess the wanted properties of a low order 
scheme; TVD, or monotonically varying in regions where the solution should be monotone, the following equality must hold 

<!-- begin inline comment -->
<font color="red">(<b>Fredrik 19</b>: definition of TVD? more theory backing these statements?)</font>
<!-- end inline comment -->


$$
\begin{equation}
0 \leq \Big(\frac{\phi(r)}{r}, \phi(r)\Big) \leq 2
\label{eq:Limiter_inequlity}
\end{equation}
$$

<p>
Where we require 

$$
\begin{equation}
\phi(r) = 0, \quad r\leq 0
\label{_auto86}
\end{equation}
$$

<p>
Hence for the scheme to be TVD the limiter must lie in the shaded region of Figure <a href="#fig:TVD">101</a>, where the limiter function for 
the two second order schemes, Lax-Wendroff and Warming and Beam are also plotted.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 101:  TVD region for flux limiters (shaded), and the limiters for the second order schemes; Lax Wendroff, and Warming and Beam <div id="fig:TVD"></div> </p></center>
<p><img src="fig-ch6/TVD_transparent.png" align="bottom" width=400></p>
</center>

<p>
For the scheme 
<!-- begin inline comment -->
<font color="red">(<b>Fredrik 20</b>: maybe add only using \( u_{j-2}, u_{j-1} u_{j} u_{j+1} \))</font>
<!-- end inline comment -->
  to be second order accurate whenever possible, the limiter must be an arithmetic 
average of the limiter of Lax-Wendroff (\( \phi=1 \)) and that of Warming and Beam(\( \phi=r \)) 
<!-- begin inline comment -->
<font color="red">(<b>Fredrik 21</b>: need citing(Sweby), and maybe  more clearification)</font>
<!-- end inline comment -->
. With this extra constraint a second order TVD limiter must lie in the shaded region of Figure <a href="#fig:2nd_TVD">102</a>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 102:  Second orderTVD region for flux limiters; sweby diagram 
<!-- begin inline comment -->
<font color="red">(<b>Fredrik 22</b>: cite sweby?)</font>
<!-- end inline comment -->
 <div id="fig:2nd_TVD"></div> </p></center>
<p><img src="fig-ch6/2nd_TVD_transparent.png" align="bottom" width=400></p>
</center>

<p>
Note that \( \phi(0)=0 \), meaning that second order accuracy must be lost at extrema. All schemes pass through the point \( \phi(1)=1 \), which is a general requirement for second order schemes. Many limiters 
that pass the above constraints have been proposed. Here we will only consider a few:

$$
\begin{align}
Superbee: \quad \phi(r)=max\left(0,min(1,2r),min(2,r)\right)  
\label{eq:Superbee}\\ 
Van-Leer: \quad \phi(r)=\frac{r+\lvert r \rvert}{1+\lvert r \rvert}  
\label{eq:van-Leer}\\ 
minmod: \quad \phi(r)=minmod(1,r)
\label{eq:minmod}
\end{align}
$$

<p>
where minmod of two arguments is defined as
$$
\begin{equation}
minmod(a,b)= \left\{
        \begin{array}{ll}
            a \quad if \quad a\cdot b > 0 \quad and \quad \lvert a \rvert > \lvert b \rvert \\ 
            b \quad if \quad a\cdot b > 0 \quad and \quad \lvert b \rvert > \lvert a \rvert > 0 \\ 
            0 \quad if \quad a\cdot b < 0 
        \end{array}
    \right.
\label{_auto87}
\end{equation}
$$

The limiters given in (ref{eq:Superbee} -(ref{eq:minmod} are showed in Figure <a href="#fig:2nd_TVD_limiters">103</a>. Superbee traverses the upper bound of 
the second order TVD region, whereas minmod traverses the lower bound of the region. Keeping in mind that in our scheme, \( \phi \) 
regulates the anti diffusive flux, superbee is thus the least diffusive scheme of these.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 103:  Second order TVD limiters <div id="fig:2nd_TVD_limiters"></div> </p></center>
<p><img src="fig-ch6/2nd_TVD_limiters_transparent.png" align="bottom" width=400></p>
</center>

<p>
In addition we will consider the two base cases:
$$
\begin{align}
upwind: \quad \phi(r)=0  
\label{eq:uowind}\\ 
Lax-Wendroff: \quad \phi(r)=1 
\label{eq:Lax-Wendroff}
\end{align}
$$

in which upwind, is TVD, but first order, and Lax-Wendroff is second order, but not TVD.

<h3 id="___sec110">Example of Flux limiter schemes on a solution with continuos and discontinuous sections </h3>

<p>
All of the above schemes have been implemented in the python class <b>Fluxlimiters</b>, and a code example of their application
on a solution containing combination of box, and sine moving with wavespeed a=1, may be found in the python script 
<b>advection-schemes-flux-limiters.py</b>. The result may be seen in the video (<a href="#video:Flux_limiters">video:Flux_limiters</a>)

<p>
<!-- MOVIE:[mov-ch6/step_flux_limiter.mp4, height=400 width=600] The effect of Flux limiting schemes on solutions containing sharp edges or discontinuities -->

<p>
<!-- MOVIE:[mov-ch6/sine_flux_limiter.mp4, height=400 width=600] The effect of Flux limiting schemes on solutions containing sharp edges or discontinuities -->

<p>

<div>
<video  loop controls width='600' height='400' preload='none'>
    <source src='mov-ch6/flux_limiter.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-ch6/flux_limiter.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-ch6/flux_limiter.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em>The effect of Flux limiting schemes on solutions containing continuos and discontinuous sections <div id="video:Flux_limiters"></div></em></p>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 104:  Relationship between \( u \) and smoothness measure \( r \), and different limiters \( \phi \), on continuos and discontinuous solutions <div id="fig:limiter_example"></div> </p></center>
<p><img src="fig-ch6/limiter_example_transparent.png" align="bottom" width=400></p>
</center>

<p>
<!-- !split -->

<h1 id="examp:Burger">Example: Burgers equation</h1>

<p>
The 1D Burgers equation is a simple (if not the simplest) non-linear
hyperbolic equation commonly used as a model equation to illustrate various numerical schemes for non-linear hyperbolic differential equations. It is normally prestented as:
$$
\begin{equation}
\frac{\partial u}{\partial t} + u \frac{\partial u}{\partial x} = 0
\label{eq:burger_nc}
\end{equation}
$$

<p>
To enable us to present schemes for a greater variety of hyperbolic
differenctial equations and to better handle shocks (i.e
discontinuities in the solution), we will present our model equation
on conservative form:
$$
\begin{equation}
\frac{\partial u}{\partial t} +  \frac{\partial }{\partial x} \left (\frac{u^2}{2} \right) = 0
\label{eq:burger_co}
\end{equation}
$$

and by introducing a flux function 
$$
\begin{equation}
 F(u) = \frac{u^2}{2}
\label{eq:F}
\end{equation}
$$

<p>
the conservative formulation of the Burgers equation may be
represented by a generic transport equation:

$$
\begin{equation}
\frac{\partial u}{\partial t} +  \frac{\partial F(u)}{\partial x}  = 0
\label{eq:burger_F}
\end{equation}
$$

<h2 id="___sec112">upwind </h2>
The upwind scheme for the general conservation equation take the form:

$$
\begin{equation}
u_{j}^{n+1} = u_{j}^{n} - \frac{\Delta t}{\Delta x} 
\left ( F(u_{j+1}^{n}) - F(u_{j}^{n}) \right )
\label{eq:upwind}
\end{equation}
$$

where we have assumed a forward propagating wave (\( a(u) = F'(u)>0 \), i.e. \( u>0 \) for the burger equation). In the opposite case 
\( \frac{\partial F(u)}{\partial x} \) will be approximated by \( \frac{1}{\Delta x} 
\left ( F(u_{j}^{n}) - F(u_{j-1}^{n}) \right ) \)

<h2 id="___sec113">lax-Friedrich </h2>
The lax-Friedrich conservation equation take the form as given in \eqref{eq:LF-1}, repeated here for convinience:

$$
\begin{equation}
u_j^{n+1} = \frac{\Delta t}{2}(u^n_{j+1}+u^n_{j-1})-\frac{F^n_{j+1}-F^n_{j-1}}{2 \Delta x}
\label{eq:LF-1_2}
\end{equation}
$$

<h2 id="___sec114">Lax-Wendroff </h2>
As outlined in ((<a href="#ch:6_Lax-Wendroff_nonlin">Lax-Wendroff for non-linear systems of hyperbolic PDEs</a>)), the general Lax-Wendroff two step method takes the form as given in \eqref{eq:lw_1st} and \eqref{eq:lw_2nd} 
repeated here for convinience:

<p>
First step:
$$
\begin{align}
& u_{j+1/2}^{n+1/2} = \frac{1}{2} \left (u_{j+1}^{n} + u_{j}^{n} \right )
 - \frac{\Delta t}{2 \Delta x} \left (F(u_{j+1}^{n}) - F(u_{j}^{n}) \right ) 
\label{_auto88}\\ 
& u_{j-1/2}^{n+1/2} = \frac{1}{2} \left (u_{j}^{n} + u_{j-1}^{n} \right )
 - \frac{\Delta t}{2 \Delta x} \left (F(u_{j}^{n}) - F(u_{j-1}^{n}) \right ) 
\label{eq:lw_1st2}
\end{align}
$$


$$
\begin{equation}
u_{j}^{n+1} = u_{j}^{n} - \frac{\Delta t}{\Delta x} 
\left ( F(u_{j+1/2}^{n+1/2}) - F(u_{j-1/2}^{n+1/2}) \right )
\label{eq:lw_2nd2}
\end{equation}
$$

<p>
In the previous section ((<a href="#ch:6_Lax-Wendroff_nonlin">Lax-Wendroff for non-linear systems of hyperbolic PDEs</a>)) we showed how  the two step Lax-Wendroff method could be condensed to a one step method. 
The same procedure may be applied to a the general transport equation given by \eqref{eq:burger_F}. However for the nonlinear case \eqref{eq:6501} no longer holds. 
This may be overcome be rewriting \eqref{eq:6501}:

$$
\begin{equation}
\begin{array}{c}
\dfrac{\partial u}{\partial t}\Bigg|_j^n = -\dfrac{\partial F}{\partial x}\Bigg|_j^n 
 \qquad \text{ and} \qquad
\dfrac{\partial^2u}{\partial t^2}\Bigg|_j^n = -\dfrac{\partial^2F(u)}{\partial t \partial x }\Bigg|_j^n = -\dfrac{\partial \left(\frac{\partial F(u)}{\partial t}\right)}{\partial x }\Bigg|_j^n 
\\ = -\dfrac{\partial \left(\frac{\partial F(u)}{\partial u}  \frac{\partial u}{\partial t}\right)}{\partial x }\Bigg|_j^n = 
\dfrac{\partial \left(a(u)  \frac{\partial F}{\partial x}\right)}{\partial x }\Bigg|_j^n
\end{array}
\label{eq:6501}
\end{equation}
$$

<p>
Now inserting into the Taylor series we get

$$
\begin{equation}
u_{j}^{n+1} = u_{j}^{n} - \Delta t \frac{\partial F(u)}{\partial x} + \frac{\Delta t^2}{2} \dfrac{\partial \left(a(u)  \frac{\partial F}{\partial x}\right)}{\partial x }
\label{eq:lw_One}
\end{equation}
$$

<p>
and further we may obtain the general Lax-Wendroff one-step method for a generic transport equation

$$
\begin{equation}
u_{j}^{n+1} = u_{j}^{n} - \frac{\Delta t}{2 \Delta x}\left(F_{j+1} - F_{j-1}\right) + \frac{\Delta t^2}{2 \Delta x^2} \Big[a_{j+1/2}\left(F_{j+1} - F_{j}\right) - a_{j-1/2}\left(F_{j} - F_{j-1}\right)\Big]
\label{eq:lw_One2}
\end{equation}
$$

<p>
where \( a(u) \) is the wavespeed, or the Jacobian of F, \( F'(u) \), which is \( u \) for the burger equation. 
As indicated \( a(u) \) has to be approximated at the indice \( (j+1/2) \) and \( (j-1/2) \). 
This may simply be done by averaging the neighboring values:
$$
\begin{equation}
a_{j+1/2} = \frac{1}{2}\left(u_{j}^{n} + u_{j+1}^{n}\right)
\label{eq:a_non_conservative}
\end{equation}
$$

for the burger equation. Another method that assure conservation is to use the following approximation
$$
\begin{equation}
a_{j+1/2}= \left\{
        \begin{array}{ll}
            \frac{F_{j+1}^n-F_{j}^n}{u_{j+1}^n-u_{j}^n} \quad if \quad u_{j+1}\neq u_{j} \\ 
             u_{j} \quad \quad \quad otherwise
        \end{array}
    \right.
\label{_auto89}
\end{equation}
$$

<h2 id="___sec115">MacCormack </h2>
The MacCormack scheme was discussed in ((<a href="#ch:6_Lax-Wendroff_nonlin">Lax-Wendroff for non-linear systems of hyperbolic PDEs</a>)) and is given by \eqref{eq:maccormack2} repeated her for convinience
$$
\begin{align}
& u_j^p =u_j^n + \frac{\Delta t}{\Delta x} \left (F_{j}^{n} - F_{j+1}^{n} \right ) 
\label{_auto90}\\ 
& u_j^{n+1} =\frac{1}{2} \left (u_{j}^{n} + u_{j}^{p} \right ) + 
  \frac{1}{2} \frac{\Delta t}{\Delta x} \left (F_{j-1}^{p} - F_{j}^{p} \right ) 
\label{_auto91}\\ 
\label{eq:maccormack2}
\end{align}
$$

<h2 id="___sec116">Method of Manufactured solution </h2>

<p>
For the Advection equation we were able to verify our schemes by comparing with exact solutions, using MES. For the burger equation it is not easy to find
an analytical solution, so in  order to verify our schemes we  use the MMS approach. However this requires that our schemes can handle source terms. The new equation 
to solve is thus the modified burgers equation

$$
\begin{equation}
\frac{\partial u}{\partial t} + u \frac{\partial u}{\partial x} = Q
\label{eq:burger_nc_Source}
\end{equation}
$$

<p>
In this chapter we will consider source terms that are a function of \( x \) and \( t \) only. The basic approach to adding source terms to our schemes is to simply add a term 
\( Q_i^n \) to our discrete equations. The schemes mentioned above with possibility to handle source terms are summarized in Table (<a href="#tab:Conservation_schemes">tab:Conservation_schemes</a>).

<p>
<div id="tab:Conservation_schemes"></div>

<p>

<div class="row">
  <div class="col-xs-12">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="left"><b>Name of Scheme</b></td> <td align="left"><b>                                                                                          Scheme                                                                                         </b></td> <td align="left"><b>order</b></td> </tr>
</thead>
<tbody>
<tr><td align="left">   Upwind            </td> <td align="left">   \( u_{j}^{n+1} = u_{j}^{n} - \frac{\Delta t}{\Delta x} + \Delta t Q_j^n \)                                                                                                                   </td> <td align="left">   1        </td> </tr>
<tr><td align="left">   Lax-Friedrichs    </td> <td align="left">   \( u_j^{n+1} = \frac{\Delta t}{2}(u^n_{j+1}+u^n_{j-1})-\frac{F^n_{j+1}-F^n_{j-1}}{2 \Delta x} + \Delta t Q_j^n  \)                                                                           </td> <td align="left">   1        </td> </tr>
<tr><td align="left">                     </td> <td align="left">   \( u_{j+1/2}^{n+1/2} = \frac{1}{2} \left (u_{j+1}^{n} + u_{j}^{n} \right )- \frac{\Delta t}{2 \Delta x} \left (F(u_{j+1}^{n}) - F(u_{j}^{n}) \right ) + \frac{\Delta t}{2} Q_{j+1/2}^n \)    </td> <td align="left">            </td> </tr>
<tr><td align="left">   Lax-Wendroff      </td> <td align="left">   \( u_{j-1/2}^{n+1/2} = \frac{1}{2} \left (u_{j}^{n} + u_{j-1}^{n} \right )- \frac{\Delta t}{2 \Delta x} \left (F(u_{j}^{n}) - F(u_{j-1}^{n}) \right )+ \frac{\Delta t}{2} Q_{j-1/2}^n \)     </td> <td align="left">   2        </td> </tr>
<tr><td align="left">                     </td> <td align="left">   \( u_{j}^{n+1} = u_{j}^{n} - \frac{\Delta t}{\Delta x} \left ( F(u_{j+1/2}^{n+1/2}) - F(u_{j-1/2}^{n+1/2}) \right )+ \Delta t Q_{j}^n \)                                                     </td> <td align="left">            </td> </tr>
<tr><td align="left">   macCormack        </td> <td align="left">   \( u_j^p =u_j^n - \frac{\Delta t}{\Delta x} \left (F_{j+1}^{n} -F_{j}^{n} \right ) + \Delta t Q_{j}^{n+1/2} \)                                                                               </td> <td align="left">   2        </td> </tr>
<tr><td align="left">                     </td> <td align="left">   \( u_j^{n+1} =\frac{1}{2} \left (u_{j}^{n} + u_{j}^{p} \right ) - \frac{1}{2} \frac{\Delta t}{\Delta x} \left (F_{j}^{p} - F_{j-1}^{p} \right )+ \frac{\Delta t}{2} Q_{j}^{n+1/2} \)         </td> <td align="left">            </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-12 -->
<p>
<br />
Examples on how to implement these schemes are given below, where we have used \( RHS(x,t) \) instead of \( Q \) for the source term: 
<br />
<b>ftbs</b> or <b>upwind</b>:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ftbs</span>(u, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;method that solves u(n+1), for the scalar conservation equation with source term:</span>
<span style="color: #BA2121; font-style: italic">        du/dt + dF/dx = RHS,</span>
<span style="color: #BA2121; font-style: italic">        where F = 0.5u^2 for the burger equation</span>
<span style="color: #BA2121; font-style: italic">        with use of the forward in time backward in space (upwind) scheme</span>
<span style="color: #BA2121; font-style: italic">        </span>
<span style="color: #BA2121; font-style: italic">        Args:</span>
<span style="color: #BA2121; font-style: italic">            u(array): an array containg the previous solution of u, u(n). (RHS)</span>
<span style="color: #BA2121; font-style: italic">            t(float): an array </span>
<span style="color: #BA2121; font-style: italic">        Returns:</span>
<span style="color: #BA2121; font-style: italic">            u[1:-1](array): the solution of the interior nodes for the next timestep, u(n+1).</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span>  (dt<span style="color: #666666">/</span>dx)<span style="color: #666666">*</span>(F(u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>])<span style="color: #666666">-</span>F(u[:<span style="color: #666666">-2</span>])) <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>RHS(t<span style="color: #666666">-0.5*</span>dt, x[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>])
    <span style="color: #008000; font-weight: bold">return</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
</pre></div>
<p>
<b>Lax-Friedrichs</b>:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">lax_friedrich_Flux</span>(u, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;method that solves u(n+1), for the scalar conservation equation with source term:</span>
<span style="color: #BA2121; font-style: italic">        du/dt + dF/dx = RHS,</span>
<span style="color: #BA2121; font-style: italic">        where F = 0.5u^2 for the burger equation</span>
<span style="color: #BA2121; font-style: italic">        with use of the lax-friedrich scheme</span>
<span style="color: #BA2121; font-style: italic">        </span>
<span style="color: #BA2121; font-style: italic">        Args:</span>
<span style="color: #BA2121; font-style: italic">            u(array): an array containg the previous solution of u, u(n). (RHS)</span>
<span style="color: #BA2121; font-style: italic">            t(float): an array </span>
<span style="color: #BA2121; font-style: italic">        Returns:</span>
<span style="color: #BA2121; font-style: italic">            u[1:-1](array): the solution of the interior nodes for the next timestep, u(n+1).</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> (u[:<span style="color: #666666">-2</span>] <span style="color: #666666">+</span>u[<span style="color: #666666">2</span>:])<span style="color: #666666">/2.0</span> <span style="color: #666666">-</span>  dt<span style="color: #666666">*</span>(F(u[<span style="color: #666666">2</span>:])<span style="color: #666666">-</span>F(u[:<span style="color: #666666">-2</span>]))<span style="color: #666666">/</span>(<span style="color: #666666">2.0*</span>dx) <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>(RHS(t, x[:<span style="color: #666666">-2</span>]) <span style="color: #666666">+</span> RHS(t, x[<span style="color: #666666">2</span>:]))<span style="color: #666666">/2.0</span>
    <span style="color: #008000; font-weight: bold">return</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
</pre></div>
<p>
<b>Lax-Wendroff-Two-step</b>:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Lax_W_Two_Step</span>(u, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;method that solves u(n+1), for the scalar conservation equation with source term:</span>
<span style="color: #BA2121; font-style: italic">        du/dt + dF/dx = RHS,</span>
<span style="color: #BA2121; font-style: italic">        where F = 0.5u^2 for the burger equation</span>
<span style="color: #BA2121; font-style: italic">        with use of the Two-step Lax-Wendroff scheme</span>
<span style="color: #BA2121; font-style: italic">        </span>
<span style="color: #BA2121; font-style: italic">        Args:</span>
<span style="color: #BA2121; font-style: italic">            u(array): an array containg the previous solution of u, u(n).</span>
<span style="color: #BA2121; font-style: italic">            t(float): time at t(n+1) </span>
<span style="color: #BA2121; font-style: italic">        Returns:</span>
<span style="color: #BA2121; font-style: italic">            u[1:-1](array): the solution of the interior nodes for the next timestep, u(n+1).</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    ujm <span style="color: #666666">=</span> u[:<span style="color: #666666">-2</span>]<span style="color: #666666">.</span>copy() <span style="color: #408080; font-style: italic">#u(j-1)</span>
    uj <span style="color: #666666">=</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]<span style="color: #666666">.</span>copy() <span style="color: #408080; font-style: italic">#u(j)</span>
    ujp <span style="color: #666666">=</span> u[<span style="color: #666666">2</span>:]<span style="color: #666666">.</span>copy() <span style="color: #408080; font-style: italic">#u(j+1)</span>
    up_m <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(ujm <span style="color: #666666">+</span> uj) <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>(dt<span style="color: #666666">/</span>dx)<span style="color: #666666">*</span>(F(uj)<span style="color: #666666">-</span>F(ujm)) <span style="color: #666666">+</span> <span style="color: #666666">0.5*</span>dt<span style="color: #666666">*</span>RHS(t<span style="color: #666666">-0.5*</span>dt, x[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>dx) <span style="color: #408080; font-style: italic">#u(n+0.5dt,j-0.5dx)</span>
    up_p <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(uj <span style="color: #666666">+</span> ujp) <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>(dt<span style="color: #666666">/</span>dx)<span style="color: #666666">*</span>(F(ujp)<span style="color: #666666">-</span>F(uj)) <span style="color: #666666">+</span> <span style="color: #666666">0.5*</span>dt<span style="color: #666666">*</span>RHS(t<span style="color: #666666">-0.5*</span>dt, x[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> <span style="color: #666666">0.5*</span>dx)<span style="color: #408080; font-style: italic">#u(n+0.5dt,j+0.5dx)</span>
    
    u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> uj <span style="color: #666666">-</span>(dt<span style="color: #666666">/</span>dx)<span style="color: #666666">*</span>(F(up_p) <span style="color: #666666">-</span> F(up_m)) <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>RHS(t<span style="color: #666666">-0.5*</span>dt, x[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>])
    <span style="color: #008000; font-weight: bold">return</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
</pre></div>
<p>
<b>macCormack</b>:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">macCormack</span>(u, t):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;method that solves u(n+1), for the scalar conservation equation with source term:</span>
<span style="color: #BA2121; font-style: italic">        du/dt + dF/dx = RHS,</span>
<span style="color: #BA2121; font-style: italic">        where F = 0.5u^2 for the burger equation</span>
<span style="color: #BA2121; font-style: italic">        with use of the MacCormack scheme</span>
<span style="color: #BA2121; font-style: italic">        </span>
<span style="color: #BA2121; font-style: italic">        Args:</span>
<span style="color: #BA2121; font-style: italic">            u(array): an array containg the previous solution of u, u(n). (RHS)</span>
<span style="color: #BA2121; font-style: italic">            t(float): an array </span>
<span style="color: #BA2121; font-style: italic">        Returns:</span>
<span style="color: #BA2121; font-style: italic">            u[1:-1](array): the solution of the interior nodes for the next timestep, u(n+1).</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    up <span style="color: #666666">=</span> u<span style="color: #666666">.</span>copy()
    up[:<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> u[:<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> (dt<span style="color: #666666">/</span>dx)<span style="color: #666666">*</span>(F(u[<span style="color: #666666">1</span>:]) <span style="color: #666666">-</span> F(u[:<span style="color: #666666">-1</span>])) <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>RHS(t<span style="color: #666666">-0.5*</span>dt, x[:<span style="color: #666666">-1</span>])
    u[<span style="color: #666666">1</span>:] <span style="color: #666666">=</span> <span style="color: #666666">.5*</span>(u[<span style="color: #666666">1</span>:] <span style="color: #666666">+</span> up[<span style="color: #666666">1</span>:] <span style="color: #666666">-</span>  (dt<span style="color: #666666">/</span>dx)<span style="color: #666666">*</span>(F(up[<span style="color: #666666">1</span>:]) <span style="color: #666666">-</span> F(up[:<span style="color: #666666">-1</span>])) <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>RHS(t<span style="color: #666666">-0.5*</span>dt, x[<span style="color: #666666">1</span>:])) 
    <span style="color: #008000; font-weight: bold">return</span> u[<span style="color: #666666">1</span>:<span style="color: #666666">-1</span>]
</pre></div>
<p>
<!-- !bsol -->
<!-- !esol -->

<p>
<!-- !bsubex -->
<!-- subexercise... -->

<p>
<!-- !bsol -->
<!-- !esol -->
<!-- !esubex -->

<p>
<!-- !split -->

<p>
<!-- !split -->

<center><h1 id="___sec117">Sympolic computation with SymPy </h1></center> <!-- chapter heading -->

<p>
In this chapter we provide a very short introduction to SymPy
customized for the applications and examples in the current
setting. For a more thorough presentation see
e.g. <a href="#johansson15:_numer_python">[22]</a>.

<h1 id="___sec118">Introduction </h1>

<p>
 <a href="http://www.sympy.org" target="_self">SymPy</a> is a Python library for symbolic mathematics, with the ambition
to offer a full-featured computer algebra system (CAS). The library
design makes SymPy ideally suited to make symbolic mathematical
computations integrated in numerical Python applications.

<h1 id="___sec119">Basic features </h1>

<p>
The SymPy library is implemented in the Python module sympy. To avoid
namespace conflicts (e.g. with other modules like NumPy/SciPy) we
propose to import the SymPy as:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span>
</pre></div>

<h3 id="___sec120">Symbols </h3>

<p>
SymPy introduces the class symbols (or Symbol) to represent mathematical symbols as
Python objects. An instance of type symbols has a set of attributes to
hold the its properties and methods to operate on those
properties. Such symbols may be used to represent and manipulate
algebraic expressions. Unlike many symbolic manipulation systems,
variables in SymPy must be defined before they are used (for
justification see <a href="http://docs.sympy.org/latest/tutorial/gotchas.html#tutorial-gotchas-symbols" target="_self">sympy.org</a>)

<p>
As an example, let us define a symbolic expression, representing the mathematical expression \( x^2 + xy - y \)

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span>
x, y <span style="color: #666666">=</span> sympy<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y&#39;</span>)
expr <span style="color: #666666">=</span> x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> x<span style="color: #666666">*</span>y <span style="color: #666666">-</span>y
expr
</pre></div>
<p>
Note that we wrote the expression as if "x" and "y" were ordinary
Python variables, but instead of being evaluated the expression
remains unaltered.

<p>
To make the output look nicer we may invoke the pretty print feature of SymPy by:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">sympy<span style="color: #666666">.</span>init_printing()
expr
</pre></div>
<p>
The expression is now ready for algebraic manipulation:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">expr<span style="color: #666666">+2</span>
x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> x<span style="color: #666666">*</span>y <span style="color: #666666">-</span>y <span style="color: #666666">+</span> <span style="color: #666666">2</span>
</pre></div>
<p>
and 
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">expr <span style="color: #666666">+</span> y
x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> x<span style="color: #666666">*</span>y 
</pre></div>
<p>
Note that the result of the above is not \( x^2 + xy -y + y \) but rather
\( x^2 + xy \), i.e. the \( -y \) and the \( +y \) are added and found to cancel
automatically by SymPy and a simplified expression is outputted
accordingly. Appart from ratHer obvious simplifications like
discarding subexpression that add up to zero (e.g. \( y-y \) or
\( \sqrt{9}= 3 \)), most simplifications are not performed automatically by
SymPy.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">expr2<span style="color: #666666">=</span>x<span style="color: #666666">**2+2*</span>x<span style="color: #666666">+1</span>
expr3<span style="color: #666666">=</span>sympy<span style="color: #666666">.</span>factor(expr2)
expr3
</pre></div>

<h3 id="___sec121">Matrices </h3>

<p>
Matrices in SymPy are implemented with the Matrix class and are
constructed by providing a list of row the vectors in the following manner:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">M<span style="color: #666666">=</span>sympy<span style="color: #666666">.</span>Matrix([[<span style="color: #666666">1</span>,<span style="color: #666666">-1</span>],[<span style="color: #666666">2</span>,<span style="color: #666666">1</span>],[<span style="color: #666666">4</span>,<span style="color: #666666">4</span>]])
M
</pre></div>
<p>
A matrix with symbolic elements may be constructed by:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a,b,c,d<span style="color: #666666">=</span>sympy<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;a b c d&#39;</span>)
M<span style="color: #666666">=</span>sympy<span style="color: #666666">.</span>Matrix([[a,b],[c,d]])
M
</pre></div>
<p>
The matrices may naturally be manipulated like any other object in
SymPy or Python. To illustrate this we introduce another \( 2x2 \)-matrix

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">n1, n2, n3, n4 <span style="color: #666666">=</span>sympy<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;n1 n2 n3 n4&#39;</span>)
N<span style="color: #666666">=</span>sympy<span style="color: #666666">.</span>Matrix([[n1,n2],[n3,n4]])
N
</pre></div>
<p>
The two matrices may then be added, subtracted, multiplied, and inverted by the
following simple statements
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">M<span style="color: #666666">+</span>N, M<span style="color: #666666">-</span>N, M<span style="color: #666666">*</span>N, M<span style="color: #666666">.</span>inv()
</pre></div>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">M<span style="color: #666666">=</span>sympy<span style="color: #666666">.</span>Matrix([[<span style="color: #666666">0</span>,a],[a,<span style="color: #666666">0</span>]])
</pre></div>
<p>
Diagonaliztion:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">L, D <span style="color: #666666">=</span> M<span style="color: #666666">.</span>diagonalize()
L, D
</pre></div>
<p>
Consider also the parabolic function which may describe the velocity
profile for fully developed flow in a cylinder.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">v0, r <span style="color: #666666">=</span>sympy<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;v0 r&#39;</span>)
v <span style="color: #666666">=</span> v0<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>r<span style="color: #666666">**2</span>)
Q<span style="color: #666666">=</span>sympy<span style="color: #666666">.</span>integrate(v,r)
</pre></div>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Q<span style="color: #666666">=</span>sympy<span style="color: #666666">.</span>factor(Q)
</pre></div>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">A<span style="color: #666666">=</span>sympy<span style="color: #666666">.</span>Function(<span style="color: #BA2121">&#39;A&#39;</span>)(x)
</pre></div>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">mu,d <span style="color: #666666">=</span>sympy<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;mu d&#39;</span>)
sympy<span style="color: #666666">.</span>integrate(A<span style="color: #666666">**2*</span>A<span style="color: #666666">.</span>diff(x),x)
</pre></div>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">sympy<span style="color: #666666">.</span>integrate(<span style="color: #666666">8*</span>sympy<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>mu<span style="color: #666666">*</span>d<span style="color: #666666">**2*</span>Q,x)
</pre></div>
<p>
<!-- !split  -->

<center><h1 id="___sec122">References </h1></center> <!-- chapter heading -->

<p>
<!-- begin bibliography -->

<ol>
 <li> <div id="hairer2008solving"></div> <b>E. Hairer, S. P. Norsett and G. Wanner</b>. 
    <em>Solving Ordinary Differential Equations I: Nonstiff Problems</em>,
    Springer Science &amp; Business,
    2008.</li>
 <li> <div id="white1999fluid"></div> <b>F. White</b>. 
    <em>Fluid Mechanics</em>,
    <em>McGraw-Hill series in mechanical engineering</em>,
    WCB/McGraw-Hill,
    1999,
    <a href="http://books.google.no/books/about/Fluid_mechanics.html?id=fa_pAAAAMAAJ&redir_esc=y" target="_self"><tt>http://books.google.no/books/about/Fluid_mechanics.html?id=fa_pAAAAMAAJ&redir_esc=y</tt></a>.</li>
 <li> <div id="evett19892"></div> <b>J. Evett and C. Liu</b>. 
    <em>2,500 Solved Problems in Fluid Mechanics and Hydraulics</em>,
    <em>Schaum's Solved Problems Series</em>,
    McGraw-Hill Education,
    1989,
    <a href="http://books.google.no/books?id=NBDjWHLKwSQC" target="_self"><tt>http://books.google.no/books?id=NBDjWHLKwSQC</tt></a>.</li>
 <li> <div id="Langtangen2011primer"></div> <b>H. P. Langtangen</b>. 
    <em>A Primer on Scientific Programming With Python</em>,
    fourth edition,
    Springer,
    2011.</li>
 <li> <div id="cheney2012numerical"></div> <b>E. Cheney and D. Kincaid</b>. 
    <em>Numerical Mathematics and Computing 7th</em>,
    7th edition,
    Cengage Learning,
    2012.</li>
 <li> <div id="Bearman1976112"></div> <b>P. Bearman and J. Harvey</b>. 
    GOLF BALL AERODYNAMICS.,
    <em>Aeronaut Q</em>,
    27(pt 2),
    pp. 112-122,
    1976,
    <a href="http://www.scopus.com/inward/record.url?eid=2-s2.0-0016949854&partnerID=40&md5=a1d1cc6e8477e33fcd2d5ccf55fc29a8" target="_self"><tt>http://www.scopus.com/inward/record.url?eid=2-s2.0-0016949854&partnerID=40&md5=a1d1cc6e8477e33fcd2d5ccf55fc29a8</tt></a>.</li>
 <li> <div id="cheney1999numerical"></div> <b>E. Cheney and D. Kincaid</b>. 
    <em>Numerical Mathematics and Computing</em>,
    4th edition,
    Cengage Learning,
    1999.</li>
 <li> <div id="evans68laminar"></div> <b>H. Evans</b>. 
    <em>Laminar Boundary-Layer Theory</em>,
    Addison-Wesley Publishing Company,
    1968.</li>
 <li> <div id="white91viscous"></div> <b>F. White</b>. 
    <em>Viscous Fluid Flow</em>,
    WCB/McGraw-Hill,
    1991.</li>
<li> <div id="schlichting78boundary"></div> <b>H. Schlichting</b>. 
    <em>Boundary Layer Theory</em>,
    7th edition,
    McGraw-Hill,
    1978.</li>
<li> <div id="forsythe77numerical"></div> <b>G. Forsythe</b>. 
    <em>Computer Methods for Mathematical Computations</em>,
    Prentice-Hall,
    1977.</li>
<li> <div id="14"></div> <b>G. D. Smith</b>. 
    <em>Numerical Solution of Partial Diff. Equations : Finite Difference Methods</em>,
    3. edition,
    Oxford,
    1985.</li>
<li> <div id="23"></div> <b>L. A. Hageman and D. M. Young</b>. 
    <em>Applied Iterative Methods</em>,
    Academic Press,
    1981.</li>
<li> <div id="15"></div> <b>W. H. Press</b>. 
    <em>Numerical Recipes in Fortran. the Art of Scientific Computing</em>,
    2. edition,
    Cambridge University Press,
    1992.</li>
<li> <div id="24"></div> <b>W. L. Briggs</b>. 
    <em>A Multigrid Tutorial</em>,
    2. edition,
    SIAM,
    2000.</li>
<li> <div id="25"></div> <b>Y. Saad</b>. 
    <em>Iterative Methods for Sparse Linear Systems</em>,
    2. edition,
    SIAM,
    2003.</li>
<li> <div id="26"></div> <b>C. T. Kelley</b>. 
    <em>Iterative Methods for Linear and Nonlinear Equations</em>,
    SIAM,
    1995.</li>
<li> <div id="anderson1997computational"></div> <b>D. Anderson</b>. 
    <em>Computational Fluid Mechanics and Heat Transfer</em>,
    Taylor &amp; Francis,
    1997.</li>
<li> <div id="hirsch2007numerical"></div> <b>C. Hirsch</b>. 
    <em>Numerical Computation of Internal and External Flows</em>,
    Elsevier,
    2007.</li>
<li> <div id="lax73"></div> <b>P. D. Lax</b>. 
    <em>Hyperbolic Systems of Conservation Laws and the Mathematical Theory of Shock Waves</em>,
    Society for Industrial and Applied Mathematics,
    1973,
    <a href="http://opac.inria.fr/record=b1083269" target="_self"><tt>http://opac.inria.fr/record=b1083269</tt></a>.</li>
<li> <div id="maccormack69"></div> <b>R. W. MacCormack</b>. 
    The Effect of Viscosity in Hypervelocity Impact Cratering,
    <em>Astronautics, AIAA</em>,
    69,
    pp. 354,
    1969,
    <a href="http://opac.inria.fr/record=b1070875" target="_self"><tt>http://opac.inria.fr/record=b1070875</tt></a>.</li>
<li> <div id="johansson15:_numer_python"></div> <b>R. Johansson</b>. 
    <em>Numerical Python. a Practical Techniques Approach for Industry</em>,
    Springer,
    2015.</li>
</ol>

<!-- end bibliography -->

<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

